<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>changes.html</title>
  <meta name="generator" content="Haroopad 0.13.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}@import url(http://fonts.googleapis.com/css?family=Roboto+Condensed:300italic,400italic,700italic,400,300,700);.haroopad{padding:20px;color:#222;font-size:15px;font-family:"Roboto Condensed",Tauri,"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;background:#fff;line-height:1.6;-webkit-font-smoothing:antialiased}.haroopad a{color:#3269a0}.haroopad a:hover{color:#4183c4}.haroopad h2{border-bottom:1px solid #e6e6e6}.haroopad h6{color:#777}.haroopad hr{border:1px solid #e6e6e6}.haroopad blockquote>code,.haroopad h1>code,.haroopad h2>code,.haroopad h3>code,.haroopad h4>code,.haroopad h5>code,.haroopad h6>code,.haroopad li>code,.haroopad p>code,.haroopad td>code{font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;font-size:85%;background-color:rgba(0,0,0,.02);padding:.2em .5em;border:1px solid #efefef}.haroopad pre>code{font-size:1em;letter-spacing:-1px;font-weight:700}.haroopad blockquote{border-left:4px solid #e6e6e6;padding:0 15px;color:#777}.haroopad table{background-color:#fafafa}.haroopad table tr td,.haroopad table tr th{border:1px solid #e6e6e6}.haroopad table tr:nth-child(2n){background-color:#f2f2f2}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-pi,.lisp .hljs-string{color:#93a1a1}.css .hljs-tag,.hljs-addition,.hljs-keyword,.hljs-request,.hljs-status,.hljs-winutils,.method,.nginx .hljs-title{color:#859900}.hljs-command,.hljs-dartdoc,.hljs-hexcolor,.hljs-link_url,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-rules .hljs-value,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#2aa198}.css .hljs-function,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.vhdl .hljs-literal{color:#268bd2}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-link_reference,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.css .hljs-pseudo,.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-header,.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#eee8d5}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:2px;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:2px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:1em}.MathJax_MenuRadioCheck.RTL{right:1em;left:auto}.MathJax_MenuLabel{padding:2px 2em 4px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #CCC;margin:4px 1px 0}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:Highlight;color:HighlightText}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown haroopad">
<h1 id="changes"><a name="changes" href="#changes"></a>Changes</h1><p class="toc" style="undefined"></p><ul>
<li><ul>
<li><span class="title">
<a href="#update-13.0.0-added-some-documentation,-and-some-new-features-too-check-it-out!" title="Update 13.0.0 Added some documentation, and some new features too check it out!">Update 13.0.0 Added some documentation, and some new features too check it out!</a>
</span>
<!--span class="number">
0
</span-->
</li>
<li><span class="title">
<a href="#update-12.2.2-time-for-some-more-bug-fixes!" title="Update 12.2.2 Time for some more bug fixes!">Update 12.2.2 Time for some more bug fixes!</a>
</span>
<!--span class="number">
1
</span-->
</li>
<li><span class="title">
<a href="#update-12.2.1-time-for-some-bug-fixes!" title="Update 12.2.1 Time for some bug fixes!">Update 12.2.1 Time for some bug fixes!</a>
</span>
<!--span class="number">
2
</span-->
</li>
<li><span class="title">
<a href="#update-12.2.0" title="Update 12.2.0">Update 12.2.0</a>
</span>
<!--span class="number">
3
</span-->
</li>
<li><span class="title">
<a href="#update-12.1.0" title="Update 12.1.0">Update 12.1.0</a>
</span>
<!--span class="number">
4
</span-->
</li>
<li><span class="title">
<a href="#update:-12.0.0-big-update-(lots-of-additions-some-changes)" title="Update: 12.0.0 Big update (Lots of additions some changes)">Update: 12.0.0 Big update (Lots of additions some changes)</a>
</span>
<!--span class="number">
5
</span-->
</li>
<li><span class="title">
<a href="#update:-1.11.1" title="Update: 1.11.1">Update: 1.11.1</a>
</span>
<!--span class="number">
6
</span-->
</li>
<li><span class="title">
<a href="#update:-1.11.0" title="Update: 1.11.0">Update: 1.11.0</a>
</span>
<!--span class="number">
7
</span-->
</li>
<li><span class="title">
<a href="#update:-1.10.0" title="Update: 1.10.0">Update: 1.10.0</a>
</span>
<!--span class="number">
8
</span-->
</li>
<li><span class="title">
<a href="#update:-1.9.2" title="Update: 1.9.2">Update: 1.9.2</a>
</span>
<!--span class="number">
9
</span-->
</li>
<li><span class="title">
<a href="#update:-1.9.1" title="Update: 1.9.1">Update: 1.9.1</a>
</span>
<!--span class="number">
10
</span-->
</li>
<li><span class="title">
<a href="#update:-1.9.0" title="Update: 1.9.0">Update: 1.9.0</a>
</span>
<!--span class="number">
11
</span-->
</li>
<li><span class="title">
<a href="#update:-1.8.7" title="Update: 1.8.7">Update: 1.8.7</a>
</span>
<!--span class="number">
12
</span-->
</li>
<li><span class="title">
<a href="#update:-1.8.6" title="Update: 1.8.6">Update: 1.8.6</a>
</span>
<!--span class="number">
13
</span-->
</li>
<li><span class="title">
<a href="#update:-1.8.5" title="Update: 1.8.5">Update: 1.8.5</a>
</span>
<!--span class="number">
14
</span-->
</li>
<li><span class="title">
<a href="#update:-1.8.4" title="Update: 1.8.4">Update: 1.8.4</a>
</span>
<!--span class="number">
15
</span-->
</li>
<li><span class="title">
<a href="#update:-1.8.3" title="Update: 1.8.3">Update: 1.8.3</a>
</span>
<!--span class="number">
16
</span-->
</li>
<li><span class="title">
<a href="#update:-1.8.2" title="Update: 1.8.2">Update: 1.8.2</a>
</span>
<!--span class="number">
17
</span-->
</li>
<li><span class="title">
<a href="#update:-1.8.1" title="Update: 1.8.1">Update: 1.8.1</a>
</span>
<!--span class="number">
18
</span-->
</li>
<li><span class="title">
<a href="#update:-1.7.6" title="Update: 1.7.6">Update: 1.7.6</a>
</span>
<!--span class="number">
19
</span-->
</li>
<li><span class="title">
<a href="#update:-1.7.5" title="Update: 1.7.5">Update: 1.7.5</a>
</span>
<!--span class="number">
20
</span-->
</li>
<li><span class="title">
<a href="#update:-1.7.4" title="Update: 1.7.4">Update: 1.7.4</a>
</span>
<!--span class="number">
21
</span-->
</li>
<li><span class="title">
<a href="#update:-1.7.3" title="Update: 1.7.3">Update: 1.7.3</a>
</span>
<!--span class="number">
22
</span-->
</li>
<li><span class="title">
<a href="#update:-1.7.2" title="Update: 1.7.2">Update: 1.7.2</a>
</span>
<!--span class="number">
23
</span-->
</li>
<li><span class="title">
<a href="#update:-1.7.1-bug-fixes-only" title="Update: 1.7.1 Bug Fixes Only">Update: 1.7.1 Bug Fixes Only</a>
</span>
<!--span class="number">
24
</span-->
</li>
<li><span class="title">
<a href="#update:-1.7.0" title="Update: 1.7.0">Update: 1.7.0</a>
</span>
<!--span class="number">
25
</span-->
</li>
<li><span class="title">
<a href="#update:-1.6.0" title="Update: 1.6.0">Update: 1.6.0</a>
</span>
<!--span class="number">
26
</span-->
</li>
<li><span class="title">
<a href="#update:-1.5.0" title="Update: 1.5.0">Update: 1.5.0</a>
</span>
<!--span class="number">
27
</span-->
</li>
<li><span class="title">
<a href="#update:-1.4.1---first-public-release-of-the-library" title="Update: 1.4.1 - First Public release of the library">Update: 1.4.1 - First Public release of the library</a>
</span>
<!--span class="number">
28
</span-->
</li>
</ul>
</li>

</ul>
<p></p><h2 id="update-13.0.0-added-some-documentation,-and-some-new-features-too-check-it-out!"><a name="update-13.0.0-added-some-documentation,-and-some-new-features-too-check-it-out!" href="#update-13.0.0-added-some-documentation,-and-some-new-features-too-check-it-out!"></a>Update 13.0.0 Added some documentation, and some new features too check it out!</h2><p><strong>Quick note</strong> on the 13.0.0 update:<br>This update I went all in finding bugs and improving proformance within the library. I added some new features and the new task manager, which I used as a way to debug the library was a great help, so much so thats it is now a permanent feature. It’s been about half a year since my last update, but so much work needed to be done. I hope you can find a use in your code to use my library. I am extremely proud of my work; 7 years of development, I learned so much about lua and programming through the creation of this library. It was fun, but there will always be more to add and bugs crawling there way in. I can’t wait to see where this library goes in the future!</p><p>Fixed: Tons of bugs, I actually went through the entire library and did a full test of everything, I mean everything, while writing the documentation.<br>Changed: </p><ul>
<li>A few things, to make concepts in the library more clear.</li><li>The way functions returned paused status. Before it would return “PAUSED” now it returns nil, true if paused</li><li>Modified the connection object to allow for some more syntaxial suger!</li><li>System threads now trigger an OnError connection that is a member of the object itself. multi.OnError() is no longer triggered for a system thread that crashes!</li></ul><p>Connection Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>loop = multi:newTLoop(function(self)
    self:OnLoops() -- new way to Fire a connection! Only works when used on a multi object, bin objects, or any object that contains a Type variable
end,1)
loop.OnLoops = multi:newConnection()
loop.OnLoops(function()
    print(&quot;Looping&quot;)
end)
multi:mainloop()
</code></pre>">loop = multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    self:OnLoops() <span class="hljs-comment">-- new way to Fire a connection! Only works when used on a multi object, bin objects, or any object that contains a Type variable</span>
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
loop.OnLoops = multi:newConnection()
loop.OnLoops(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Looping"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><p>Function Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>func = multi:newFunction(function(self,a,b)
    self:Pause()
    return 1,2,3
end)
print(func()) -- returns: 1, 2, 3
print(func()) -- nil, true
</code></pre>">func = multi:newFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,a,b)</span></span>
    self:Pause()
    <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>
<span class="hljs-keyword">end</span>)
<span class="hljs-built_in">print</span>(func()) <span class="hljs-comment">-- returns: 1, 2, 3</span>
<span class="hljs-built_in">print</span>(func()) <span class="hljs-comment">-- nil, true</span>
</code></pre><p>Removed:</p><ul>
<li>Ranges and conditions — corutine based threads can emulate what these objects did and much better!</li><li>Due to the creation of hyper threaded processes the following objects are no more!<br>— <del>multi:newThreadedEvent()</del><br>— <del>multi:newThreadedLoop()</del><br>— <del>multi:newThreadedTLoop()</del><br>— <del>multi:newThreadedStep()</del><br>— <del>multi:newThreadedTStep()</del><br>— <del>multi:newThreadedAlarm()</del><br>— <del>multi:newThreadedUpdater()</del><br>— <del>multi:newTBase()</del> — Acted as the base for creating the other objects</li></ul><p>These didn’t have much use in their previous form, but with the addition of hyper threaded processes the goals that these objects aimed to solve are now possible using a process</p><p>Fixed:</p><ul>
<li>There were some bugs in the networkmanager.lua file. Desrtoy -&gt; Destroy some misspellings.</li><li>Massive object management bugs which caused performance to drop like a rock.</li><li>Found a bug with processors not having the Destroy() function implemented properly.</li><li>Found an issue with the rockspec which is due to the networkManager additon. The net Library and the multi Library are now codependent if using that feature. Going forward you will have to now install the network library separately</li><li>Insane proformance bug found in the networkManager file, where each connection to a node created a new thread (VERY BAD) If say you connected to 100s of threads, you would lose a lot of processing power due to a bad implementation of this feature. But it goes futhur than this, the net library also creates a new thread for each connection made, so times that initial 100 by about 3, you end up with a system that quickly eats itself. I have to do tons of rewriting of everything. Yet another setback for the 13.0.0 release (Im releasing 13.0.0 though this hasn’t been ironed out just yet)</li><li>Fixed an issue where any argument greater than 256^2 or 65536 bytes is sent the networkmanager would soft crash. This was fixed by increading the limit to 256^4 or 4294967296. The fix was changing a 2 to a 4. Arguments greater than 256^4 would be impossible in 32 bit lua, and highly unlikely even in lua 64 bit. Perhaps someone is reading an entire file into ram and then sending the entire file that they read over a socket for some reason all at once!?</li><li>Fixed an issue with processors not properly destroying objects within them and not being destroyable themselves</li><li>Fixed a bug where pause and resume would duplicate objects! Not good</li><li>Noticed that the switching of lua states, corutine based threading, is slower than multi-objs (Not by much though).</li><li>multi:newSystemThreadedConnection(name,protect) — I did it! It works and I believe all the gotchas are fixed as well.<br>— Issue one, if a thread died that was connected to that connection all connections would stop since the queue would get clogged! FIXED<br>— There is one thing, the connection does have some handshakes that need to be done before it functions as normal!</li></ul><p>Added:</p><ul>
<li>Documentation, the purpose of 13.0.0, orginally going to be 12.2.3, but due to the amount of bugs and features added it couldn’t be a simple bug fix update.</li><li>multi:newHyperThreadedProcess(STRING name) — This is a version of the threaded process that gives each object created its own coroutine based thread which means you can use thread.* without affecting other objects created within the hyper threaded processes. Though, creating a self contained single thread is a better idea which when I eventually create the wiki page I’ll discuss</li><li>multi:newConnector() — A simple object that allows you to use the new connection Fire syntax without using a multi obj or the standard object format that I follow.</li><li>multi:purge() — Removes all references to objects that are contained withing the processes list of tasks to do. Doing this will stop all objects from functioning. Calling Resume on an object should make it work again.</li><li>multi:getTasksDetails(STRING format) — Simple function, will get massive updates in the future, as of right now It will print out the current processes that are running; listing their type, uptime, and priority. More useful additions will be added in due time. Format can be either a string “s” or “t” see below for the table format</li><li>multi:endTask(TID) — Use multi:getTasksDetails(“t”) to get the tid of a task</li><li>multi:enableLoadDetection() — Reworked how load detection works. It gives better values now, but it still needs some work before I am happy with it</li><li>THREAD.getID() — returns a unique ID for the current thread. This varaiable is visible to the main thread as well by accessing it through the returned thread object. OBJ.Id Do not confuse this with thread.* this refers to the system threading interface. Each thread, including the main thread has a threadID the main thread has an ID of 0!</li><li>multi.print(…) works like normal print, but only prints if the setting print is set to true</li><li>setting: <code>print</code> enables multi.print() to work</li><li>STC: IgnoreSelf defaults to false, if true a Fire command will not be sent to the self</li><li>STC: OnConnectionAdded(function(connID)) — Is fired when a connection is added you can use STC:FireTo(id,…) to trigger a specific connection. Works like the named non threaded connections, only the id’s are genereated for you.</li><li>STC: FireTo(id,…) — Described above.</li></ul><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
conn = multi:newConnector()
conn.OnTest = multi:newConnection()
conn.OnTest(function()
    print(&quot;Yes!&quot;)
end)
test = multi:newHyperThreadedProcess(&quot;test&quot;)
test:newTLoop(function()
    print(&quot;HI!&quot;)
    conn:OnTest()
end,1)
test:newLoop(function()
    print(&quot;HEY!&quot;)
    thread.sleep(.5)
end)
multi:newAlarm(3):OnRing(function()
    test:Sleep(10)
end)
test:Start()
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
conn = multi:newConnector()
conn.OnTest = multi:newConnection()
conn.OnTest(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Yes!"</span>)
<span class="hljs-keyword">end</span>)
test = multi:newHyperThreadedProcess(<span class="hljs-string">"test"</span>)
test:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"HI!"</span>)
    conn:OnTest()
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
test:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"HEY!"</span>)
    thread.sleep(.<span class="hljs-number">5</span>)
<span class="hljs-keyword">end</span>)
multi:newAlarm(<span class="hljs-number">3</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    test:Sleep(<span class="hljs-number">10</span>)
<span class="hljs-keyword">end</span>)
test:Start()
multi:mainloop()
</code></pre><p>Table format for getTasksDetails(STRING format)</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>{
    {TID = 1,Type=&quot;&quot;,Priority=&quot;&quot;,Uptime=0}
    {TID = 2,Type=&quot;&quot;,Priority=&quot;&quot;,Uptime=0}
    ...
    {TID = n,Type=&quot;&quot;,Priority=&quot;&quot;,Uptime=0}
    ThreadCount = 0
    threads={
        [Thread_Name]={
            Uptime = 0
        }
    }
}
</code></pre>">{
    {TID = <span class="hljs-number">1</span>,Type=<span class="hljs-string">""</span>,Priority=<span class="hljs-string">""</span>,Uptime=<span class="hljs-number">0</span>}
    {TID = <span class="hljs-number">2</span>,Type=<span class="hljs-string">""</span>,Priority=<span class="hljs-string">""</span>,Uptime=<span class="hljs-number">0</span>}
    ...
    {TID = n,Type=<span class="hljs-string">""</span>,Priority=<span class="hljs-string">""</span>,Uptime=<span class="hljs-number">0</span>}
    ThreadCount = <span class="hljs-number">0</span>
    threads={
        [Thread_Name]={
            Uptime = <span class="hljs-number">0</span>
        }
    }
}
</code></pre><p><strong>Note:</strong> After adding the getTasksDetails() function I noticed many areas where threads, and tasks were not being cleaned up and fixed the leaks. I also found out that a lot of tasks were starting by default and made them enable only. If you compare the benchmark from this version to last version you;ll notice a signifacant increase in performance.</p><p><strong>Going forward:</strong></p><ul>
<li>Work on system threaded functions</li><li>work on the node manager</li><li>patch up bugs</li><li>finish documentstion</li></ul><h2 id="update-12.2.2-time-for-some-more-bug-fixes!"><a name="update-12.2.2-time-for-some-more-bug-fixes!" href="#update-12.2.2-time-for-some-more-bug-fixes!"></a>Update 12.2.2 Time for some more bug fixes!</h2><p>Fixed: multi.Stop() not actually stopping due to the new pirority management scheme and preformance boost changes.<br>Thats all for this update</p><h2 id="update-12.2.1-time-for-some-bug-fixes!"><a name="update-12.2.1-time-for-some-bug-fixes!" href="#update-12.2.1-time-for-some-bug-fixes!"></a>Update 12.2.1 Time for some bug fixes!</h2><p>Fixed: SystemThreadedJobQueues</p><ul>
<li>You can now make as many job queues as you want! Just a warning when using a large amount of cores for the queue it takes a second or 2 to set up the jobqueues for data transfer. I am unsure if this is a lanes thing or not, but love2d has no such delay when setting up the jobqueue!</li><li>You now connect to the OnReady in the jobqueue object. No more holding everything else as you wait for a job queue to be ready</li><li>Jobqueues:doToAll now passes the queues multi interface as the first and currently only argument</li><li>No longer need to use jobqueue.OnReady() The code is smarter and will send the pushed jobs automatically when the threads are ready</li></ul><p>Fixed: SystemThreadedConnection</p><ul>
<li>They work the exact same way as before, but actually work as expected now. The issue before was how i implemented it. Now each connection knows the number of instances of that object that ecist. This way I no longer have to do fancy timings that may or may not work. I can send exactly enough info for each connection to consume from the queue.</li></ul><p>Removed: multi:newQueuer</p><ul>
<li>This feature has no real use after corutine based threads were introduced. You can use those to get the same effect as the queuer and do it better too. </li></ul><p>Going forwardGoing forward:</p><ul>
<li>Will I ever finish steralization? Who knows, but being able to save state would be nice. The main issue is there is no simple way to save state. While I can provide methods to allow one to turn the objects into strings and back, there is no way for me to make your code work with it in a simple way. For now only the basic functions will be here.</li><li>I need to make better documentation for this library as well. In its current state, all I have are examples and not a list of what is what.</li></ul><h1 id="example"><a name="example" href="#example"></a>Example</h1><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
multi = require(&quot;multi&quot;)
GLOBAL, THREAD = require(&quot;multi.integration.lanesManager&quot;).init()
jq = multi:newSystemThreadedJobQueue()
jq:registerJob(&quot;test&quot;,function(a)
    return &quot;Hello&quot;,a
end)
jq.OnJobCompleted(function(ID,...)
    print(ID,...)
end)
for i=1,16 do
    jq:pushJob(&quot;test&quot;,5)
end
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
jq = multi:newSystemThreadedJobQueue()
jq:registerJob(<span class="hljs-string">"test"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello"</span>,a
<span class="hljs-keyword">end</span>)
jq.OnJobCompleted(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(ID,...)</span></span>
    <span class="hljs-built_in">print</span>(ID,...)
<span class="hljs-keyword">end</span>)
<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">16</span> <span class="hljs-keyword">do</span>
    jq:pushJob(<span class="hljs-string">"test"</span>,<span class="hljs-number">5</span>)
<span class="hljs-keyword">end</span>
multi:mainloop()
</code></pre><h2 id="update-12.2.0"><a name="update-12.2.0" href="#update-12.2.0"></a>Update 12.2.0</h2><p><strong>Added:</strong></p><ul>
<li>multi.nextStep(func)</li><li>Method chaining</li><li>Priority 3 has been added!</li><li>ResetPriority() — This will set a flag for a process to be re evaluated for how much of an impact it is having on the performance of the system.</li><li>setting: auto_priority added! — If only lua os.clock was more fine tuned… milliseconds are not enough for this to work</li><li>setting: auto_lowerbound added! — when using auto_priority this will allow you to set the lowbound for pirority. The defualt is a hyrid value that was calculated to reach the max potential with a delay of .001, but can be changed to whatever. Remember this is set to processes that preform really badly! If lua could handle more detail in regards to os.clock() then i would set the value a bit lower like .0005 or something like that</li><li>setting: auto_stretch added! — This is another way to modify the extent of the lowest setting. This reduces the impact that a low preforming process has! Setting this higher reduces the number of times that a process is called. Only in effect when using auto_priotity</li><li>setting: auto_delay added! — sets the time in seconds that the system will recheck for low performing processes and manage them. Will also upgrade a process if it starts to run better.<pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- All methods that did not return before now return a copy of itself. Thus allowing chaining. Most if not all mutators returned nil, so chaining can now be done. I will eventually write up a full documentation of everything which will show this.
multi = require(&quot;multi&quot;)
multi:newStep(1,100):OnStep(function(self,i)
  print(&quot;Index: &quot;..i)
end):OnEnd(function(self)
  print(&quot;Step is done!&quot;)
end)
multi:mainloop{
  priority = 3
}
</code></pre>"><span class="hljs-comment">-- All methods that did not return before now return a copy of itself. Thus allowing chaining. Most if not all mutators returned nil, so chaining can now be done. I will eventually write up a full documentation of everything which will show this.</span>
multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
multi:newStep(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>):OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,i)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Index: "</span>..i)
<span class="hljs-keyword">end</span>):OnEnd(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Step is done!"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop{
  priority = <span class="hljs-number">3</span>
}
</code></pre>
Priority 3 works a bit differently than the other 2.</li></ul><p>P1 follows a forumla that resembles this: ~n=I*PRank where n is the amount of steps given to an object with PRank and where I is the idle time see chart below. The aim of this priority scheme was to make core objects run fastest while letting idle processes get decent time as well.</p><pre><code data-origin="<pre><code>C: 3322269    ~I*7
H: 2847660    ~I*6
A: 2373050    ~I*5
N: 1898440    ~I*4
B: 1423830    ~I*3
L: 949220     ~I*2
I: 474610     ~I
~n=I*PRank
</code></pre>">C: 3322269    ~I*7
H: 2847660    ~I*6
A: 2373050    ~I*5
N: 1898440    ~I*4
B: 1423830    ~I*3
L: 949220     ~I*2
I: 474610     ~I
~n=I*PRank
</code></pre><p>P2 follows a formula that resembles this: ~n=n*4 where n is the idle time, see chart below. The goal of this one was to make core process’ higher while keeping idle process’ low.</p><pre><code data-origin="<pre><code>C: 6700821
H: 1675205
A: 418801
N: 104700
B: 26175
L: 6543
I: 1635
~n=n*4
</code></pre>">C: 6700821
H: 1675205
A: 418801
N: 104700
B: 26175
L: 6543
I: 1635
~n=n*4
</code></pre><p>P3 Ignores using a basic funceion and instead bases its processing time on the amount of cpu time is there. If  cpu-time is low and a process is set at a lower priority it will get its time reduced. There is no formula, at idle almost all process work at the same speed!</p><pre><code data-origin="<pre><code>C: 2120906
H: 2120906
A: 2120906
N: 2120906
B: 2120906
L: 2120906
I: 2120506
</code></pre>">C: 2120906
H: 2120906
A: 2120906
N: 2120906
B: 2120906
L: 2120906
I: 2120506
</code></pre><p>Auto Priority works by seeing what should be set high or low. Due to lua not having more persicion than milliseconds, I was unable to have a detailed manager that can set things to high, above normal, normal, ect. This has either high or low. If a process takes longer than .001 millisecond it will be set to low priority. You can change this by using the setting auto<em>lowest = multi.Priority</em>[PLevel] the defualt is low, not idle, since idle tends to get about 1 process each second though you can change it to idle using that setting.</p><p><strong>Improved:</strong></p><ul>
<li>Performance at the base level has been doubled! On my machine benchmark went from ~9mil to ~20 mil steps/s.<br>Note: If you write slow code this library’s improbements wont make much of a difference.</li><li>Loops have been optimised as well! Being the most used objects I felt they needed to be made as fast as possible</li></ul><p>I usually give an example of the changes made, but this time I have an explantion for multi.nextStep(). It’s not an entirely new feature since multi:newJob() does something like this, but is completely different. nextStep addes a function that is executed first on the next step. If multiple things are added to next step, then they will be executed in the order that they were added.</p><p>Note:<br>The upper limit of this libraries performance on my machine is ~39mil. This is simply a while loop counting up from 0 and stops after 1 second. The 20mil that I am currently getting is probably as fast as it can get since its half of the max performance possible, and each layer I have noticed that it doubles complexity. Throughout the years with this library I have seen massive improvements in speed. In the beginning we had only ~2000 steps per second. Fast right? then after some tweaks we went to about 300000 steps per second, then 600000. Some more tweaks brought me to ~1mil steps per second, then to ~4 mil then ~9 mil and now finally ~20 mil… the doubling effect that i have now been seeing means that odds are I have reach the limit. I will aim to add more features and optimize individule objects. If its possible to make the library even faster then I will go for it.</p><h2 id="update-12.1.0"><a name="update-12.1.0" href="#update-12.1.0"></a>Update 12.1.0</h2><p>Fixed:</p><ul>
<li>bug causing arguments when spawning a new thread not going through</li></ul><p>Changed:</p><ul>
<li>thread.hold() now returns the arguments that were pass by the event function</li><li>event objexts now contain a copy of what returns were made by the function that called it in a table called returns that exist inside of the object</li></ul><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
multi = require(&quot;multi&quot;)
local a = 0
multi:newThread(&quot;test&quot;,function()
    print(&quot;lets go&quot;)
    b,c = thread.hold(function() -- This now returns what was managed here
        return b,&quot;We did it!&quot;
    end)
    print(b,c)
end)
multi:newTLoop(function()
    a=a+1
    if a == 5 then
        b = &quot;Hello&quot;
    end
end,1)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-keyword">local</span> a = <span class="hljs-number">0</span>
multi:newThread(<span class="hljs-string">"test"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"lets go"</span>)
    b,c = thread.hold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- This now returns what was managed here</span>
        <span class="hljs-keyword">return</span> b,<span class="hljs-string">"We did it!"</span>
    <span class="hljs-keyword">end</span>)
    <span class="hljs-built_in">print</span>(b,c)
<span class="hljs-keyword">end</span>)
multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    a=a+<span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> a == <span class="hljs-number">5</span> <span class="hljs-keyword">then</span>
        b = <span class="hljs-string">"Hello"</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
multi:mainloop()
</code></pre><p><strong>Note:</strong> Only if the first return is non-nil/false will any other returns be passed! So while variable b above is nil the string “We did it!” will not be passed. Also while this seems simple enough to get working, I had to modify a bit on how the scheduler worked to add such a simple feature. Quite a bit is going on behind the scenes which made this a bit tricky to implement, but not hard. Just needed a bit of tinkering. Plus event objects have not been edited since the creation of the EventManager. They have remained mostly the same since 2011</p><h1 id="going-forward:"><a name="going-forward:" href="#going-forward:"></a>Going forward:</h1><p>Contunue to make small changes as I come about them. This change was inspired when working of the net library. I was addind simple binary file support over tcp, and needed to pass the data from the socket when the requested amount has been recieved. While upvalues did work, i felt returning data was cleaner and added this feature.</p><h2 id="update:-12.0.0-big-update-(lots-of-additions-some-changes)"><a name="update:-12.0.0-big-update-(lots-of-additions-some-changes)" href="#update:-12.0.0-big-update-(lots-of-additions-some-changes)"></a>Update: 12.0.0 Big update (Lots of additions some changes)</h2><p><strong>Note:</strong> <del>After doing some testing, I have noticed that using multi-objects are slightly, quite a bit, faster than using (coroutines)multi:newthread(). Only create a thread if there is no other possibility! System threads are different and will improve performance if you know what you are doing. Using a (coroutine)thread as a loop with a<br>is slower than using a TLoop! If you do not need the holding features I strongly recommend that you use the multi-objects. This could be due to the scheduler that I am using, and I am looking into improving the performance of the scheduler for (coroutine)threads. This is still a work in progress so expect things to only get better as time passes!</del> This was the reason threadloop was added. It binds the thread scheduler into the mainloop allowing threads to run much faster than before. Also the use of locals is now possible since I am not dealing with seperate objects. And finally, reduced function overhead help keeps the threads running better.</p><h1 id="added:"><a name="added:" href="#added:"></a>Added:</h1><ul>
<li><code>nGLOBAL = require("multi.integration.networkManager").init()</code></li><li><code>node = multi:newNode(tbl: settings)</code></li><li><code>master = multi:newMaster(tbl: settings)</code></li><li><code>multi:nodeManager(port)</code></li><li><code>thread.isThread()</code> — for coroutine based threads</li><li>New setting to the main loop, stopOnError which defaults to true. This will cause the objects that crash, when under protect, to be destroyed. So the error does not keep happening.</li><li>multi:threadloop(settings) works just like mainloop, but prioritizes (corutine based) threads. Regular multi-objects will still work. This improves the preformance of (coroutine based) threads greatly.</li><li>multi.OnPreLoad — an event that is triggered right before the mainloop starts</li></ul><p>Changed:</p><ul>
<li>When a (corutine based)thread errors it does not print anymore! Conect to multi.OnError() to get errors when they happen!</li><li>Connections get yet another update. Connect takes an additional argument now which is the position in the table that the func should be called. Note: Fire calls methods backwards so 1 is the back and the # of connections (the default value) is the beginning of the call table</li><li>The love2d compat layer has now been revamped allowing module creators to connect to events without the user having to add likes of code for those events. Its all done automagically.</li><li>This library is about 8 years old and using 2.0.0 makes it seem young. I changed it to 12.0.0 since it has some huge changes and there were indeed 12 major releases that added some cool things. Going forward I’ll use major.minor.bugfix</li><li>multi.OnError() is now required to capture errors that are thrown when in prorected mode.</li></ul><h1 id="node:"><a name="node:" href="#node:"></a>Node:</h1><ul>
<li>node:sendTo(name,data)</li><li>node:pushTo(name,data)</li><li>node:peek()</li><li>node:pop()</li><li>node:getConsole() — has only 1 function print which allows you to print to the master.</li></ul><h1 id="master:"><a name="master:" href="#master:"></a>Master:</h1><ul>
<li>master:doToAll(func)</li><li>master:register(name,node,func)</li><li>master:execute(name,node,…)</li><li>master:newNetworkThread(tname,func,name,…)</li><li>master:getFreeNode()</li><li>master:getRandomNode()</li><li>master:sendTo(name,data)</li><li>master:pushTo(name,data)</li><li>master:peek()</li><li>master:pop()</li><li>master:OnError(nodename, error) — if a node has an error this is triggered.</li></ul><h1 id="bugs"><a name="bugs" href="#bugs"></a>Bugs</h1><ul>
<li>Fixed a small typo I made which caused a hard crash when a (coroutine) thread crashes. This only happened if protect was true.</li></ul><h1 id="going-forward:"><a name="going-forward:" href="#going-forward:"></a>Going forward:</h1><ul>
<li>I am really excited to finally get this update out there, but left one important thing out. enabling of enviroments for each master connected to a node. This would allow a node to isolate code from multiple masters so they cannot interact with each other. This will come out in version 12.1.0 But might take a while due to the job hunt that I am currently going through.</li><li>Another feature that I am on the fence about is adding channels. They would work like queues, but are named so you can seperate the data from different channels where only one portion of can see certain data. </li><li>I also might add a feature that allows different system threads to consume from a network queue if they are spaned on the same physical machine. This is possible at the moment, just doesn’t have a dedicated object for handling this seamlessly. You can do this yourself though.</li><li>Another feature that I am thinking of adding is crosstalk which is a setting that would allow nodes to talk to other nodes. I did not add it in this release since there are some issues that need to be worked out and its very messy atm. however since nodes are named. I may allow by default pushing data to another node, but not have the global table to sync since this is where the issue lies.</li><li>Improve Performance</li><li>Fix supporting libraries (Bin, and net need tons of work)</li><li>Look for the bugs</li><li>Figure out what I can do to make this library more awesome</li></ul><p><strong>Note On Queues:</strong> When it comes to network queues, they only send 1 way. What I mean by that is that if the master sends a message to a node, its own queue will not get populated at all. The reason for this is because syncing between which popped from what network queue would make things really slow and would not perform well at all. This means you have to code a bit differently. Use: master getFreeNode() to get the name of the node under the least amount of load. Then handle the sending of data to each node that way.</p><p>Now there is a little trick you can do. If you combine both networkmanager and systemthreading manager, then you could have a proxy queue for all system threads that can pull from that “node”. Now data passing within a lan network, (And wan network if using the node manager, though p2p isn’t working as i would like and you would need to open ports and make things work. Remember you can define an port for your node so you can port forward that if you want), is fast enough, but the waiting problem is something to consider. Ask yourseld what you are coding and if network paralisim is worth using.</p><p><strong>Note:</strong> These examples assume that you have already connected the nodes to the node manager. Also you do not need to use the node manager, but sometimes broadcast does not work as expected and the master doesnot connect to the nodes. Using the node manager offers nice features like: removing nodes from the master when they have disconnected, and automatically telling the master when nodes have been added. A more complete example showing connections regardless of order will be shown in the example folder check it out. New naming scheme too.</p><p><strong>NodeManager.lua</strong></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
multi = require(&quot;multi&quot;)
local GLOBAL, THREAD = require(&quot;multi.integration.lanesManager&quot;).init()
nGLOBAL = require(&quot;multi.integration.networkManager&quot;).init()
multi:nodeManager(12345) -- Host a node manager on port: 12345
print(&quot;Node Manager Running...&quot;)
settings = {
    priority = 0, -- 1 or 2
    protect = false,
}
multi:mainloop(settings)
-- Thats all you need to run the node manager, everything else is done automatically
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-keyword">local</span> GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
nGLOBAL = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.networkManager"</span>).init()
multi:nodeManager(<span class="hljs-number">12345</span>) <span class="hljs-comment">-- Host a node manager on port: 12345</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"Node Manager Running..."</span>)
settings = {
    priority = <span class="hljs-number">0</span>, <span class="hljs-comment">-- 1 or 2</span>
    protect = <span class="hljs-keyword">false</span>,
}
multi:mainloop(settings)
<span class="hljs-comment">-- Thats all you need to run the node manager, everything else is done automatically</span>
</code></pre><p>Side note: I had a setting called cross talk that would allow nodes to talk to each other. After some tought I decided to not allow nodes to talk to each other directly! You however can create another master withing the node. (The node will connect to its own master as well). This will give you the ability “Cross talk” with each node. Reimplementing the master features into each node directly was un nessacery. </p><p><strong>Node.lua</strong></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
multi = require(&quot;multi&quot;)
local GLOBAL, THREAD = require(&quot;multi.integration.lanesManager&quot;).init()
nGLOBAL = require(&quot;multi.integration.networkManager&quot;).init()
master = multi:newNode{
    allowRemoteRegistering = true, -- allows you to register functions from the master on the node, default is false
    name = nil, -- default value
    noBroadCast = true, -- if using the node manager, set this to true to prevent the node from broadcasting
    managerDetails = {&quot;localhost&quot;,12345}, -- connects to the node manager if one exists
}
function RemoteTest(a,b,c) -- a function that we will be executing remotely
    print(&quot;Yes I work!&quot;,a,b,c)
end
settings = {
    priority = 0, -- 1 or 2
    protect = false, -- if something goes wrong we will crash hard, but the speed gain is good
}
multi:mainloop(settings)
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-keyword">local</span> GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
nGLOBAL = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.networkManager"</span>).init()
master = multi:newNode{
    allowRemoteRegistering = <span class="hljs-keyword">true</span>, <span class="hljs-comment">-- allows you to register functions from the master on the node, default is false</span>
    name = <span class="hljs-keyword">nil</span>, <span class="hljs-comment">-- default value</span>
    noBroadCast = <span class="hljs-keyword">true</span>, <span class="hljs-comment">-- if using the node manager, set this to true to prevent the node from broadcasting</span>
    managerDetails = {<span class="hljs-string">"localhost"</span>,<span class="hljs-number">12345</span>}, <span class="hljs-comment">-- connects to the node manager if one exists</span>
}
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">RemoteTest</span><span class="hljs-params">(a,b,c)</span></span> <span class="hljs-comment">-- a function that we will be executing remotely</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Yes I work!"</span>,a,b,c)
<span class="hljs-keyword">end</span>
settings = {
    priority = <span class="hljs-number">0</span>, <span class="hljs-comment">-- 1 or 2</span>
    protect = <span class="hljs-keyword">false</span>, <span class="hljs-comment">-- if something goes wrong we will crash hard, but the speed gain is good</span>
}
multi:mainloop(settings)
</code></pre><p><strong>Master.lua</strong></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- set up the package
package.path=&quot;?/init.lua;?.lua;&quot;..package.path
-- Import the libraries
multi = require(&quot;multi&quot;)
local GLOBAL, THREAD = require(&quot;multi.integration.lanesManager&quot;).init()
nGLOBAL = require(&quot;multi.integration.networkManager&quot;).init()
-- Act as a master node
master = multi:newMaster{
    name = &quot;Main&quot;, -- the name of the master
    noBroadCast = true, -- if using the node manager, set this to true to avoid double connections
    managerDetails = {&quot;localhost&quot;,12345}, -- the details to connect to the node manager (ip,port)
}
-- Send to all the nodes that are connected to the master
master:doToAll(function(node_name)
    master:register(&quot;TestFunc&quot;,node_name,function(msg)
        print(&quot;It works: &quot;..msg)
    end)
    multi:newAlarm(2):OnRing(function(alarm)
        master:execute(&quot;TestFunc&quot;,node_name,&quot;Hello!&quot;)
        alarm:Destroy()
    end)
    multi:newThread(&quot;Checker&quot;,function()
        while true do
            thread.sleep(1)
            if nGLOBAL[&quot;test&quot;] then
                print(nGLOBAL[&quot;test&quot;])
                thread.kill()
            end
        end
    end)
    nGLOBAL[&quot;test2&quot;]={age=22}
end)

-- Starting the multitasker
settings = {
    priority = 0, -- 0, 1 or 2
    protect = false,
}
multi:mainloop(settings)
</code></pre>"><span class="hljs-comment">-- set up the package</span>
<span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-comment">-- Import the libraries</span>
multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-keyword">local</span> GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
nGLOBAL = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.networkManager"</span>).init()
<span class="hljs-comment">-- Act as a master node</span>
master = multi:newMaster{
    name = <span class="hljs-string">"Main"</span>, <span class="hljs-comment">-- the name of the master</span>
    noBroadCast = <span class="hljs-keyword">true</span>, <span class="hljs-comment">-- if using the node manager, set this to true to avoid double connections</span>
    managerDetails = {<span class="hljs-string">"localhost"</span>,<span class="hljs-number">12345</span>}, <span class="hljs-comment">-- the details to connect to the node manager (ip,port)</span>
}
<span class="hljs-comment">-- Send to all the nodes that are connected to the master</span>
master:doToAll(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(node_name)</span></span>
    master:register(<span class="hljs-string">"TestFunc"</span>,node_name,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(msg)</span></span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"It works: "</span>..msg)
    <span class="hljs-keyword">end</span>)
    multi:newAlarm(<span class="hljs-number">2</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(alarm)</span></span>
        master:execute(<span class="hljs-string">"TestFunc"</span>,node_name,<span class="hljs-string">"Hello!"</span>)
        alarm:Destroy()
    <span class="hljs-keyword">end</span>)
    multi:newThread(<span class="hljs-string">"Checker"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">do</span>
            thread.sleep(<span class="hljs-number">1</span>)
            <span class="hljs-keyword">if</span> nGLOBAL[<span class="hljs-string">"test"</span>] <span class="hljs-keyword">then</span>
                <span class="hljs-built_in">print</span>(nGLOBAL[<span class="hljs-string">"test"</span>])
                thread.kill()
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>)
    nGLOBAL[<span class="hljs-string">"test2"</span>]={age=<span class="hljs-number">22</span>}
<span class="hljs-keyword">end</span>)

<span class="hljs-comment">-- Starting the multitasker</span>
settings = {
    priority = <span class="hljs-number">0</span>, <span class="hljs-comment">-- 0, 1 or 2</span>
    protect = <span class="hljs-keyword">false</span>,
}
multi:mainloop(settings)
</code></pre><p><strong>Note:</strong> There are many ways to work this. You could send functions/methods to a node like haw systemThreadedJobQueue work. Or you could write the methods you want in advance in each node file and send over the command to run the method with arguments … and it will return the results. Network threading is different than system threading. Data transfer is really slow compared to system threading. In fact the main usage for this feature in the library is mearly for experments. Right now I honestly do not know what I want to do with this feature and what I am going to add to this feature. The ablitiy to use this frature like a system thread will be possible, but there are some things that differ.</p><h1 id="changed:"><a name="changed:" href="#changed:"></a>Changed:</h1><ul>
<li>multi:mainloop(settings) — now takes a table of settings</li><li>multi:uManager(settings) — now takes a table of settings</li><li>connections:holdUT(n) can take a number now. Where they will not continue until it gets triggered <strong>n</strong> times Added 3 updated ago, forgot to list it as a new feature</li><li>The way you require the library has changed a bit! This will change how you start your code, but it isn’t a big change.</li><li>These changes have led to significant performance improvements</li></ul><p>Modifying the global stack is not the best way to manage or load in the library.</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Base Library
multi = require(&quot;multi&quot;)
-- In Lanes
multi = require(&quot;multi&quot;)
local GLOBAL, THREAD = require(&quot;multi.integration.lanesManager&quot;).init()
-- In Love2d
multi = require(&quot;multi&quot;)
GLOBAL, THREAD = require(&quot;multi.integration.loveManager&quot;).init()
-- In Luvit
local timer = require(&quot;timer&quot;)
local thread = require(&quot;thread&quot;)
multi = require(&quot;multi&quot;)
require(&quot;multi.integration.luvitManager&quot;).init(thread,timer) -- Luvit does not cuttently have support for the global table or threads.
</code></pre>"><span class="hljs-comment">-- Base Library</span>
multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-comment">-- In Lanes</span>
multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-keyword">local</span> GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
<span class="hljs-comment">-- In Love2d</span>
multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.loveManager"</span>).init()
<span class="hljs-comment">-- In Luvit</span>
<span class="hljs-keyword">local</span> timer = <span class="hljs-built_in">require</span>(<span class="hljs-string">"timer"</span>)
<span class="hljs-keyword">local</span> thread = <span class="hljs-built_in">require</span>(<span class="hljs-string">"thread"</span>)
multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.luvitManager"</span>).init(thread,timer) <span class="hljs-comment">-- Luvit does not cuttently have support for the global table or threads.</span>
</code></pre><h1 id="improvements:"><a name="improvements:" href="#improvements:"></a>Improvements:</h1><ul>
<li>Updated the ThreadedConsole, now 100x faster!</li><li>Updated the ThreadedConections, .5x faster!</li><li>Both multi:uManager(settings) and multi:mainloop(settings) provide about the same performance! Though uManager is slightly slower due to function overhead, but still really close.</li><li>Revamped pausing mulit-objects they now take up less memory when being used</li></ul><h1 id="removed:"><a name="removed:" href="#removed:"></a>Removed:</h1><ul>
<li>require(“multi.all”) — We are going into a new version of the library so this is nolonger needed</li><li>require(“multi.compat.backwards[1,5,0]”) — This is really old and is no longer supported going forward</li><li>multi:Do_Order()</li><li>multi:enablePriority()</li><li>multi:enablePriority2()</li><li>multi:protect()</li><li>multi:unProtect()</li><li>multi:protectedMainloop()</li><li>multi:unprotectedMainloop()</li><li>multi:prioritizedMainloop1()</li><li>multi:prioritizedMainloop2()</li><li>Removed Tasks</li><li>multi:oneTime(func,…) — never seen use of this, plus multi-functions can do this by pausing the function after the first use, and is much faster anyway</li><li>multi:reboot() — removed due to having no real use</li><li>multi:hold() — removed due to threads being able to do the same thing and way better too</li><li>multi:waitFor() — the thread variant does something completely different</li><li>multi.resurrect() — removed due to being useless</li></ul><p>The new settings table makes all of these possible and removes a lot of function overhead that was going on before.</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>multi:mainloop{
    priority = 1, -- 1 or 2
    protect = true, -- Should I use pcall to ignore errors?
    preLoop = function(self) -- a function that is called before the mainloop does its thing
        multi:newTLoop(function()
            print(&quot;Hello whats up!&quot;)
            error(&quot;:P&quot;)
        end,1)
        multi.OnError(function(obj,err)
            print(err)
            obj:Destroy()
        end)
    end,
}
</code></pre>">multi:mainloop{
    priority = <span class="hljs-number">1</span>, <span class="hljs-comment">-- 1 or 2</span>
    protect = <span class="hljs-keyword">true</span>, <span class="hljs-comment">-- Should I use pcall to ignore errors?</span>
    preLoop = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span> <span class="hljs-comment">-- a function that is called before the mainloop does its thing</span>
        multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello whats up!"</span>)
            <span class="hljs-built_in">error</span>(<span class="hljs-string">":P"</span>)
        <span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
        multi.OnError(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(obj,err)</span></span>
            <span class="hljs-built_in">print</span>(err)
            obj:Destroy()
        <span class="hljs-keyword">end</span>)
    <span class="hljs-keyword">end</span>,
}
</code></pre><h2 id="update:-1.11.1"><a name="update:-1.11.1" href="#update:-1.11.1"></a>Update: 1.11.1</h2><p>Love2d change:<br>I didn’t make a mistake but didn’t fully understand how the new love.run function worked.<br>So, it works by returning a function that allows for running the mainloop. So, this means that we can do something like this:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>multi:newLoop(love.run()) -- Run the mainloop here, cannot use thread.* when using this object

-- or

multi:newThread(&quot;MainLoop&quot;,love.run()) -- allows you to use the thread.*

--And you'll need to throw this in at the end
multi:mainloop()
</code></pre>">multi:newLoop(love.run()) <span class="hljs-comment">-- Run the mainloop here, cannot use thread.* when using this object</span>

<span class="hljs-comment">-- or</span>

multi:newThread(<span class="hljs-string">"MainLoop"</span>,love.run()) <span class="hljs-comment">-- allows you to use the thread.*</span>

<span class="hljs-comment">--And you'll need to throw this in at the end</span>
multi:mainloop()
</code></pre><p>For the long-time users of this library you know of the amazing multitasking features that the library has. Used correctly you can have insane power. The priority management system should be quite useful with this change.<br>NOTE: <strong>multiobj:hold() will be removed in the next version!</strong> This is something I feel should be changed, since threads(coroutines) do the job great, and way better than my holding method that I throw together 5 years ago. I doubt this is being used by many anyway. Version 1.11.2 or version 2.0.0 will have this change. The next update may be either, bug fixes if any or network parallelism.</p><p>TODO: Add auto priority adjustments when working with priority and stuff… If the system is under heavy load it will dial some things deemed as less important down and raise the core processes.</p><h2 id="update:-1.11.0"><a name="update:-1.11.0" href="#update:-1.11.0"></a>Update: 1.11.0</h2><p>Added:</p><ul>
<li>SystemThreadedConsole(name) — Allow each thread to print without the sync issues that make prints merge and hard to read.</li></ul><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- MainThread:
console = multi:newSystemThreadedConsole(&quot;console&quot;):init()
-- Thread:
console = THREAD.waitFor(&quot;console&quot;):init()

-- using the console
console:print(...)
console:write(...) -- kind of useless for formatting code though. other threads can eaisly mess this up.
</code></pre>"><span class="hljs-comment">-- MainThread:</span>
console = multi:newSystemThreadedConsole(<span class="hljs-string">"console"</span>):init()
<span class="hljs-comment">-- Thread:</span>
console = THREAD.waitFor(<span class="hljs-string">"console"</span>):init()

<span class="hljs-comment">-- using the console</span>
console:<span class="hljs-built_in">print</span>(...)
console:write(...) <span class="hljs-comment">-- kind of useless for formatting code though. other threads can eaisly mess this up.</span>
</code></pre><p>Fixed/Updated:</p><ul>
<li>Love2d 11.1 support is now here! Will now require these lines in your main.lua file</li></ul><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>function love.update(dt)
    multi:uManager(dt) -- runs the main loop of the multitasking library
end
function love.draw()
    multi.dManager() -- If using my guimanager, if not omit this
end
</code></pre>"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">love.update</span><span class="hljs-params">(dt)</span></span>
    multi:uManager(dt) <span class="hljs-comment">-- runs the main loop of the multitasking library</span>
<span class="hljs-keyword">end</span>
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">love.draw</span><span class="hljs-params">()</span></span>
    multi.dManager() <span class="hljs-comment">-- If using my guimanager, if not omit this</span>
<span class="hljs-keyword">end</span>
</code></pre><h2 id="update:-1.10.0"><a name="update:-1.10.0" href="#update:-1.10.0"></a>Update: 1.10.0</h2><p><strong>Note:</strong> The library is now considered to be stable!<br><strong>Upcoming:</strong> Network parallelism is on the way. It is in the works and should be released soon</p><h1 id="added:"><a name="added:" href="#added:"></a>Added:</h1><ul>
<li>isMainThread true/nil</li><li>multi:newSystemThreadedConnection(name,protect) — Works like normal connections, but are able to trigger events across threads</li></ul><p>Example of threaded connections</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local GLOBAL,THREAD=require(&quot;multi.integration.lanesManager&quot;).init()
multi:newSystemThread(&quot;Test_Thread_1&quot;,function()
    connOut = THREAD.waitFor(&quot;ConnectionNAMEHERE&quot;):init()
    connOut(function(arg)
        print(THREAD.getName(),arg)
    end)
    multi:mainloop()
end)
multi:newSystemThread(&quot;Test_Thread_2&quot;,function()
    connOut = THREAD.waitFor(&quot;ConnectionNAMEHERE&quot;):init()
    connOut(function(arg)
        print(THREAD.getName(),arg)
    end)
    multi:mainloop()
end)
connOut = multi:newSystemThreadedConnection(&quot;ConnectionNAMEHERE&quot;):init()
a=0
connOut(function(arg)
    print(&quot;Main&quot;,arg)
end)
multi:newTLoop(function()
    a=a+1
    connOut:Fire(&quot;Test From Main Thread: &quot;..a..&quot;\n&quot;)
end,1)
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> GLOBAL,THREAD=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
multi:newSystemThread(<span class="hljs-string">"Test_Thread_1"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    connOut = THREAD.waitFor(<span class="hljs-string">"ConnectionNAMEHERE"</span>):init()
    connOut(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg)</span></span>
        <span class="hljs-built_in">print</span>(THREAD.getName(),arg)
    <span class="hljs-keyword">end</span>)
    multi:mainloop()
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"Test_Thread_2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    connOut = THREAD.waitFor(<span class="hljs-string">"ConnectionNAMEHERE"</span>):init()
    connOut(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg)</span></span>
        <span class="hljs-built_in">print</span>(THREAD.getName(),arg)
    <span class="hljs-keyword">end</span>)
    multi:mainloop()
<span class="hljs-keyword">end</span>)
connOut = multi:newSystemThreadedConnection(<span class="hljs-string">"ConnectionNAMEHERE"</span>):init()
a=<span class="hljs-number">0</span>
connOut(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Main"</span>,arg)
<span class="hljs-keyword">end</span>)
multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    a=a+<span class="hljs-number">1</span>
    connOut:Fire(<span class="hljs-string">"Test From Main Thread: "</span>..a..<span class="hljs-string">"\n"</span>)
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
</code></pre><h1 id="fixed:"><a name="fixed:" href="#fixed:"></a>Fixed:</h1><p><strong>loveManager</strong> and <strong>shared threading objects</strong></p><ul>
<li>sThread.waitFor()</li><li>sThread.hold()</li><li>some typos</li><li>SystemThreadedTables (They now work on both lanes and love2d as expected)</li></ul><p>Example of threaded tables</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local GLOBAL,sThread=require(&quot;multi.integration.lanesManager&quot;).init()
multi:newSystemThread(&quot;Test_Thread_1&quot;,function()
    require(&quot;multi&quot;)
    test = sThread.waitFor(&quot;testthing&quot;):init()
    multi:newTLoop(function()
        print(&quot;------&quot;)
        for i,v in pairs(test.tab) do
            print(&quot;T1&quot;,i,v)
        end
    end,1)
    multi:mainloop()
end)
multi:newSystemThread(&quot;Test_Thread_1&quot;,function()
    require(&quot;multi&quot;)
    test = sThread.waitFor(&quot;testthing&quot;):init()
    multi:newTLoop(function()
        print(&quot;------&quot;)
        for i,v in pairs(test.tab) do
            print(&quot;T2&quot;,i,v)
        end
    end,1)
    multi:mainloop()
end)
test = multi:newSystemThreadedTable(&quot;testthing&quot;):init()
multi:newTLoop(function()
    local a,b = multi.randomString(8),multi.randomString(4)
    print(&quot;&amp;gt;&quot;,a,b)
    test[a]=b
end,1)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
multi:newSystemThread(<span class="hljs-string">"Test_Thread_1"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
    test = sThread.waitFor(<span class="hljs-string">"testthing"</span>):init()
    multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"------"</span>)
        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(test.tab) <span class="hljs-keyword">do</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"T1"</span>,i,v)
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
    multi:mainloop()
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"Test_Thread_1"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
    test = sThread.waitFor(<span class="hljs-string">"testthing"</span>):init()
    multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"------"</span>)
        <span class="hljs-keyword">for</span> i,v <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(test.tab) <span class="hljs-keyword">do</span>
            <span class="hljs-built_in">print</span>(<span class="hljs-string">"T2"</span>,i,v)
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
    multi:mainloop()
<span class="hljs-keyword">end</span>)
test = multi:newSystemThreadedTable(<span class="hljs-string">"testthing"</span>):init()
multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-keyword">local</span> a,b = multi.randomString(<span class="hljs-number">8</span>),multi.randomString(<span class="hljs-number">4</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"&gt;"</span>,a,b)
    test[a]=b
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
multi:mainloop()
</code></pre><h2 id="update:-1.9.2"><a name="update:-1.9.2" href="#update:-1.9.2"></a>Update: 1.9.2</h2><p>Added:</p><ul>
<li>(THREAD).kill() kills a thread. Note: THREAD is based on what you name it</li><li>newTimeStamper() Part of the persistent systems… Useful for when you are running this library for a long amount of time… like months and years! Though daily, hourly, minute events do also exist.<br>Allows one to hook to timed events such as whenever the clock strikes midnight or when the day turns to Monday. The event is only done once though. so as soon as Monday is set it would trigger then not trigger again until next Monday<br>works for seconds, minutes, days, months, year.<pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>stamper = multi:newTimeStamper()
stamper:OnTime(int hour,int minute,int second,func) or stamper:OnTime(string time,func) time as 00:00:00
stamper:OnHour(int hour,func)
stamper:OnMinute(int minute,func)
stamper:OnSecond(int second,func)
stamper:OnDay(int day,func) or stamper:OnDay(string day,func) Mon, Tues, Wed, etc...
stamper:OnMonth(int month,func)
stamper:OnYear(int year,func)
</code></pre>">stamper = multi:newTimeStamper()
stamper:OnTime(int hour,int minute,int second,func) <span class="hljs-keyword">or</span> stamper:OnTime(<span class="hljs-built_in">string</span> time,func) time as <span class="hljs-number">00</span>:<span class="hljs-number">00</span>:<span class="hljs-number">00</span>
stamper:OnHour(int hour,func)
stamper:OnMinute(int minute,func)
stamper:OnSecond(int second,func)
stamper:OnDay(int day,func) <span class="hljs-keyword">or</span> stamper:OnDay(<span class="hljs-built_in">string</span> day,func) Mon, Tues, Wed, etc...
stamper:OnMonth(int month,func)
stamper:OnYear(int year,func)
</code></pre>
Updated:</li><li>LoadBalancing, well better load balancing than existed before. This one allowed for multiple processes to have their own load reading. Calling this on the multi object will return the total load for the entire multi environment… loads of other processes are indeed affected by what other processes are doing. However, if you combine propriety to the mix of things then you will get differing results… these results however will most likely be higher than normal… different priorities will have different default thresholds of performance.</li></ul><p>Fixed:</p><ul>
<li>Thread.getName() should now work on lanes and love2d, haven’t tested it much with the luvit side of things…</li><li>A bug with the lovemanager table.remove arguments were backwards</li><li>The queue object in the love2d threading has been fixed! It now supports sending all objects (even functions if no upvalues are present!)</li></ul><p>Changed:</p><ul>
<li>SystemThreadedJobQueues now have built in load management so they are not constantly at 100% CPU usage.</li><li>SystemThreadedJobQueues pushJob now returns an id of that job which will match the same one that OnJobCompleted returns</li></ul><h2 id="update:-1.9.1"><a name="update:-1.9.1" href="#update:-1.9.1"></a>Update: 1.9.1</h2><p>Added:</p><ul>
<li>Integration “multi.integration.luvitManager”</li><li>Limited… Only the basic multi:newSystemThread(…) will work</li><li>Not even data passing will work other than arguments… If using the bin library, you can pass tables and function… Even full objects if inner recursion is not present.</li></ul><p>Updated:</p><ul>
<li>multi:newSystemThread(name,func,…)</li><li>It will not pass the … to the func(). Do not know why this wasn’t done in the first place</li><li>Also multi:getPlatform(will now return “luvit” if using luvit… Though Idk if module creators would use the multi library when inside the luvit environment</li></ul><h2 id="update:-1.9.0"><a name="update:-1.9.0" href="#update:-1.9.0"></a>Update: 1.9.0</h2><p>Added:</p><ul>
<li>multiobj:ToString() — returns a string representing the object</li><li>multi:newFromString(str) — creates an object from a string</li></ul><p>Works on threads and regular objects. Requires the latest bin library to work!</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>talarm=multi:newThreadedAlarm(&quot;AlarmTest&quot;,5)
talarm:OnRing(function()
     print(&quot;Ring!&quot;)
end)
bin.new(talarm:ToString()):tofile(&quot;test.dat&quot;)
-- multi:newFromString(bin.load(&quot;test.dat&quot;))
</code></pre>">talarm=multi:newThreadedAlarm(<span class="hljs-string">"AlarmTest"</span>,<span class="hljs-number">5</span>)
talarm:OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
     <span class="hljs-built_in">print</span>(<span class="hljs-string">"Ring!"</span>)
<span class="hljs-keyword">end</span>)
bin.new(talarm:ToString()):tofile(<span class="hljs-string">"test.dat"</span>)
<span class="hljs-comment">-- multi:newFromString(bin.load("test.dat"))</span>
</code></pre><p>— A more seamless way to use this will be made in the form of state saving.<br>This is still a WIP<br>processes, timers, timemasters, watchers, and queuers have not been worked on yet</p><h2 id="update:-1.8.7"><a name="update:-1.8.7" href="#update:-1.8.7"></a>Update: 1.8.7</h2><p>Added:</p><ul>
<li>multi.timer(func,…)</li></ul><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>function test(a,b,c)
    print(&quot;Running...&quot;)
    a=0
    for i=1,1000000000 do
        a=a+1
    end
    return a,b+c
end
print(multi.timer(test,1,2,3))
print(multi.timer(test,1,2,3))
-- multi.timer returns the time taken then the arguments from the function... Uses unpack so careful of nil values!
</code></pre>"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">test</span><span class="hljs-params">(a,b,c)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Running..."</span>)
    a=<span class="hljs-number">0</span>
    <span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">1000000000</span> <span class="hljs-keyword">do</span>
        a=a+<span class="hljs-number">1</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> a,b+c
<span class="hljs-keyword">end</span>
<span class="hljs-built_in">print</span>(multi.timer(test,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))
<span class="hljs-built_in">print</span>(multi.timer(test,<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>))
<span class="hljs-comment">-- multi.timer returns the time taken then the arguments from the function... Uses unpack so careful of nil values!</span>
</code></pre><h2 id="update:-1.8.6"><a name="update:-1.8.6" href="#update:-1.8.6"></a>Update: 1.8.6</h2><p>Added:</p><ul>
<li>jobQueue:doToAll(function)</li><li>jobQueue:start() is now required Call this after all calls to registerJob()’s. Calling it afterwards will not guarantee your next push job with that job will work. Not calling this will make pushing jobs impossible!</li><li>Fixed a bug with love2d Threaded Queue</li><li>Fixed some bugs</li><li>Old versions of this library! It stems back from 2012 see rambling for more info…</li></ul><p>This will run said function in every thread.</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Going to use love2d code this time, almost the same as last time... See ramblings
require(&quot;core.Library&quot;)
GLOBAL,sThread=require(&quot;multi.integration.loveManager&quot;).init() -- load the love2d version of the lanesManager and requires the entire multi library
require(&quot;core.GuiManager&quot;)
gui.ff.Color=Color.Black
jQueue=multi:newSystemThreadedJobQueue()
jQueue:registerJob(&quot;TEST_JOB&quot;,function(a,s)
    math.randomseed(s)
    TEST_JOB2()
    return math.random(0,255)
end)
jQueue:registerJob(&quot;TEST_JOB2&quot;,function()
    print(&quot;Test Works!&quot;)
end)
-- 1.8.6 EXAMPLE Change
jQueue:start() -- This is now needed!
--
jQueue:doToAll(function()
    print(&quot;Doing this 2? times!&quot;)
end)
tableOfOrder={}
jQueue.OnJobCompleted(function(JOBID,n)
    tableOfOrder[JOBID]=n
    if #tableOfOrder==10 then
        t.text=&quot;We got all of the pieces!&quot;
    end
end)
for i=1,10 do -- Job Name of registered function, ... varargs
    jQueue:pushJob(&quot;TEST_JOB&quot;,&quot;This is a test!&quot;,math.random(1,1000000))
end
t=gui:newTextLabel(&quot;no done yet!&quot;,0,0,300,100)
t:centerX()
t:centerY()
</code></pre>"><span class="hljs-comment">-- Going to use love2d code this time, almost the same as last time... See ramblings</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core.Library"</span>)
GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.loveManager"</span>).init() <span class="hljs-comment">-- load the love2d version of the lanesManager and requires the entire multi library</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core.GuiManager"</span>)
gui.ff.Color=Color.Black
jQueue=multi:newSystemThreadedJobQueue()
jQueue:registerJob(<span class="hljs-string">"TEST_JOB"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,s)</span></span>
    <span class="hljs-built_in">math</span>.randomseed(s)
    TEST_JOB2()
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">math</span>.random(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>)
<span class="hljs-keyword">end</span>)
jQueue:registerJob(<span class="hljs-string">"TEST_JOB2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Test Works!"</span>)
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- 1.8.6 EXAMPLE Change</span>
jQueue:start() <span class="hljs-comment">-- This is now needed!</span>
<span class="hljs-comment">--</span>
jQueue:doToAll(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Doing this 2? times!"</span>)
<span class="hljs-keyword">end</span>)
tableOfOrder={}
jQueue.OnJobCompleted(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(JOBID,n)</span></span>
    tableOfOrder[JOBID]=n
    <span class="hljs-keyword">if</span> #tableOfOrder==<span class="hljs-number">10</span> <span class="hljs-keyword">then</span>
        t.text=<span class="hljs-string">"We got all of the pieces!"</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span> <span class="hljs-keyword">do</span> <span class="hljs-comment">-- Job Name of registered function, ... varargs</span>
    jQueue:pushJob(<span class="hljs-string">"TEST_JOB"</span>,<span class="hljs-string">"This is a test!"</span>,<span class="hljs-built_in">math</span>.random(<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span>))
<span class="hljs-keyword">end</span>
t=gui:newTextLabel(<span class="hljs-string">"no done yet!"</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">300</span>,<span class="hljs-number">100</span>)
t:centerX()
t:centerY()
</code></pre><h2 id="update:-1.8.5"><a name="update:-1.8.5" href="#update:-1.8.5"></a>Update: 1.8.5</h2><p>Added:</p><ul>
<li>SystemThreadedExecute(cmd)</li></ul><p>Allows the execution of system calls without hold up. It is possible to do the same using io.popen()! You decide which works best for you!</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>local GLOBAL,sThread=require(&quot;multi.integration.lanesManager&quot;).init()
cmd=multi:newSystemThreadedExecute(&quot;SystemThreadedExecuteTest.lua&quot;) -- This file is important!
cmd.OnCMDFinished(function(code) -- callback function to grab the exit code... Called when the command goes through
    print(&quot;Got Code: &quot;..code)
end)
multi:newTLoop(function()
    print(&quot;...&quot;) -- lets show that we aren't being held up
end,1)
multi:mainloop()
</code></pre>"><span class="hljs-keyword">local</span> GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
cmd=multi:newSystemThreadedExecute(<span class="hljs-string">"SystemThreadedExecuteTest.lua"</span>) <span class="hljs-comment">-- This file is important!</span>
cmd.OnCMDFinished(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(code)</span></span> <span class="hljs-comment">-- callback function to grab the exit code... Called when the command goes through</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Got Code: "</span>..code)
<span class="hljs-keyword">end</span>)
multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"..."</span>) <span class="hljs-comment">-- lets show that we aren't being held up</span>
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
multi:mainloop()
</code></pre><h2 id="update:-1.8.4"><a name="update:-1.8.4" href="#update:-1.8.4"></a>Update: 1.8.4</h2><p>Added:</p><ul>
<li>multi:newSystemThreadedJobQueue()</li><li>Improved stability of the library</li><li>Fixed a bug that made the benchmark and getload commands non-thread(coroutine) safe</li><li>Tweaked the loveManager to help improve idle CPU usage</li><li>Minor tweaks to the coroutine scheduling</li></ul><h1 id="using-multi:newsystemthreadedjobqueue()"><a name="using-multi:newsystemthreadedjobqueue()" href="#using-multi:newsystemthreadedjobqueue()"></a>Using multi:newSystemThreadedJobQueue()</h1><p>First you need to create the object<br>This works the same way as love2d as it does with lanes… It is getting harder to make both work the same way with speed in mind… Anyway…</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Creating the object using lanes manager to show case this. Examples has the file for love2d
local GLOBAL,sThread=require(&quot;multi.integration.lanesManager&quot;).init()
jQueue=multi:newSystemThreadedJobQueue(n) -- this internally creates System threads. By default it will use the # of processors on your system You can set this number though.
-- Only create 1 jobqueue! For now, making more than 1 is not supported. You only really need one though. Just register new functions if you want 1 queue to do more. The one reason though is keeping track of jobIDs. I have an idea that I will roll out in the ~~next update~~ eventually.
jQueue:registerJob(&quot;TEST_JOB&quot;,function(a,s)
    math.randomseed(s)
    -- We will push a random #
    TEST_JOB2() -- You can call other registered functions as well!
    return math.random(0,255) -- send the result to the main thread
end)
jQueue:registerJob(&quot;TEST_JOB2&quot;,function()
    print(&quot;Test Works!&quot;) -- this is called from the job since it is registered on the same queue
end)
tableOfOrder={} -- This is how we will keep order of our completed jobs. There is no guarantee that the order will be correct
jQueue.OnJobCompleted(function(JOBID,n) -- whenever a job is completed you hook to the event that is called. This passes the JOBID filled by the returns of the job
    -- JOBID is the completed job, starts at 1 and counts up by 1.
    -- Threads finish at different times so jobIDs may be passed out of order! Be sure to have a way to order them
    tableOfOrder[JOBID]=n -- we order ours by putting them into a table
    if #tableOfOrder==10 then
        print(&quot;We got all of the pieces!&quot;)
    end
end)
-- Lets push the jobs now
for i=1,10 do -- Job Name of registered function, ... varargs
    jQueue:pushJob(&quot;TEST_JOB&quot;,&quot;This is a test!&quot;,math.random(1,1000000))
end
print(&quot;I pushed all of the jobs :)&quot;)
multi:mainloop() -- Start the main loop :D
</code></pre>"><span class="hljs-comment">-- Creating the object using lanes manager to show case this. Examples has the file for love2d</span>
<span class="hljs-keyword">local</span> GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
jQueue=multi:newSystemThreadedJobQueue(n) <span class="hljs-comment">-- this internally creates System threads. By default it will use the # of processors on your system You can set this number though.</span>
<span class="hljs-comment">-- Only create 1 jobqueue! For now, making more than 1 is not supported. You only really need one though. Just register new functions if you want 1 queue to do more. The one reason though is keeping track of jobIDs. I have an idea that I will roll out in the ~~next update~~ eventually.</span>
jQueue:registerJob(<span class="hljs-string">"TEST_JOB"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,s)</span></span>
    <span class="hljs-built_in">math</span>.randomseed(s)
    <span class="hljs-comment">-- We will push a random #</span>
    TEST_JOB2() <span class="hljs-comment">-- You can call other registered functions as well!</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">math</span>.random(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>) <span class="hljs-comment">-- send the result to the main thread</span>
<span class="hljs-keyword">end</span>)
jQueue:registerJob(<span class="hljs-string">"TEST_JOB2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Test Works!"</span>) <span class="hljs-comment">-- this is called from the job since it is registered on the same queue</span>
<span class="hljs-keyword">end</span>)
tableOfOrder={} <span class="hljs-comment">-- This is how we will keep order of our completed jobs. There is no guarantee that the order will be correct</span>
jQueue.OnJobCompleted(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(JOBID,n)</span></span> <span class="hljs-comment">-- whenever a job is completed you hook to the event that is called. This passes the JOBID filled by the returns of the job</span>
    <span class="hljs-comment">-- JOBID is the completed job, starts at 1 and counts up by 1.</span>
    <span class="hljs-comment">-- Threads finish at different times so jobIDs may be passed out of order! Be sure to have a way to order them</span>
    tableOfOrder[JOBID]=n <span class="hljs-comment">-- we order ours by putting them into a table</span>
    <span class="hljs-keyword">if</span> #tableOfOrder==<span class="hljs-number">10</span> <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"We got all of the pieces!"</span>)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- Lets push the jobs now</span>
<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span> <span class="hljs-keyword">do</span> <span class="hljs-comment">-- Job Name of registered function, ... varargs</span>
    jQueue:pushJob(<span class="hljs-string">"TEST_JOB"</span>,<span class="hljs-string">"This is a test!"</span>,<span class="hljs-built_in">math</span>.random(<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span>))
<span class="hljs-keyword">end</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"I pushed all of the jobs :)"</span>)
multi:mainloop() <span class="hljs-comment">-- Start the main loop :D</span>
</code></pre><p>That’s it from this version!</p><h2 id="update:-1.8.3"><a name="update:-1.8.3" href="#update:-1.8.3"></a>Update: 1.8.3</h2><p>Added:<br><br><strong>New Mainloop functions</strong> Below you can see the slight differences… Function overhead is not too bad in lua but has a real difference. multi:mainloop() and multi:unprotectedMainloop() use the same algorithm yet the dedicated unprotected one is slightly faster due to having less function overhead.</p><ul>
<li>multi:mainloop()* — Bench:  16830003 Steps in 3 second(s)!</li><li>multi:protectedMainloop() — Bench:  16699308 Steps in 3 second(s)!</li><li>multi:unprotectedMainloop() — Bench:  16976627 Steps in 3 second(s)!</li><li>multi:prioritizedMainloop1() — Bench:  15007133 Steps in 3 second(s)!</li><li>multi:prioritizedMainloop2() — Bench:  15526248 Steps in 3 second(s)!</li></ul><p>* The OG mainloop function remains the same and old methods to achieve what we have with the new ones still exist</p><p>These new methods help by removing function overhead that is caused through the original mainloop function. The one downside is that you no longer have the flexibility to change the processing during runtime.</p><p>However there is a work around! You can use processes to run multiobjs as well and use the other methods on them.</p><p>I may make a full comparison between each method and which is faster, but for now trust that the dedicated ones with less function overhead are infect faster. Not by much but still faster.</p><h2 id="update:-1.8.2"><a name="update:-1.8.2" href="#update:-1.8.2"></a>Update: 1.8.2</h2><p>Added:<br></p><ul>
<li>multi:newsystemThreadedTable(name) NOTE: Metatables are not supported in transfers. However there is a work around obj:init() does this. Look in the multi/integration/shared/shared.lua files to see how I did it!</li><li>Modified the GLOBAL metatable to sync before doing its tests</li><li>multi._VERSION was multi.Version, felt it would be more consistent this way… I left the old way of getting the version just in case someone has used that way. It will eventually be gone. Also multi:getVersion() will do the job just as well and keep your code nice and update related bug free!</li><li>Also everything that is included in the: multi/integration/shared/shared.lua (Which is loaded automatically) works in both lanes and love2d environments!</li></ul><p>The threaded table is setup just like the threaded queue.<br><br>It provids GLOBAL like features without having to write to GLOBAL!<br><br>This is useful for module creators who want to keep their data private, but also use GLOBAL like coding.<br><br>It has a few features that makes it a bit better than plain ol GLOBAL (For now…)<br>(ThreadedTable - TT for short) This was modified by a recent version that removed the need for a sync command</p><ul>
<li>TT:waitFor(name)</li><li>TT:sync()</li><li>TT[“var”]=value</li><li>print(TT[“var”])</li></ul><p>we also have the “sync” method, this one was made for love2d because we do a syncing trick to get data in a table format. The lanes side has a sync method as well so no worries. Using indexing calls sync once and may grab your variable. This allows you to have the lanes indexing ‘like’ syntax when doing regular indexing in love2d side of the module. As of right now both sides work flawlessly! And this effect is now the GLOBAL as well<br></p><p>On GLOBALS sync is a internal method for keeping the GLOBAL table in order. You can still use sThread.waitFor(name) to wait for variables that may or may not yet exist!</p><p>Time for some examples:</p><h1 id="using-multi:newsystemthreadedtable(name)"><a name="using-multi:newsystemthreadedtable(name)" href="#using-multi:newsystemthreadedtable(name)"></a>Using multi:newSystemThreadedTable(name)</h1><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- lanes Desktop lua! NOTE: this is in lanesintergratetest6.lua in the examples folder
local GLOBAL,sThread=require(&quot;multi.integration.lanesManager&quot;).init()
test=multi:newSystemThreadedTable(&quot;YO&quot;):init()
test[&quot;test1&quot;]=&quot;lol&quot;
multi:newSystemThread(&quot;test&quot;,function()
    tab=sThread.waitFor(&quot;YO&quot;):init()
    print(tab:has(&quot;test1&quot;))
    sThread.sleep(3)
    tab[&quot;test2&quot;]=&quot;Whats so funny?&quot;
end)
multi:newThread(&quot;test2&quot;,function()
    print(test:waitFor(&quot;test2&quot;))
end)
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- lanes Desktop lua! NOTE: this is in lanesintergratetest6.lua in the examples folder</span>
<span class="hljs-keyword">local</span> GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
test=multi:newSystemThreadedTable(<span class="hljs-string">"YO"</span>):init()
test[<span class="hljs-string">"test1"</span>]=<span class="hljs-string">"lol"</span>
multi:newSystemThread(<span class="hljs-string">"test"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    tab=sThread.waitFor(<span class="hljs-string">"YO"</span>):init()
    <span class="hljs-built_in">print</span>(tab:has(<span class="hljs-string">"test1"</span>))
    sThread.sleep(<span class="hljs-number">3</span>)
    tab[<span class="hljs-string">"test2"</span>]=<span class="hljs-string">"Whats so funny?"</span>
<span class="hljs-keyword">end</span>)
multi:newThread(<span class="hljs-string">"test2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(test:waitFor(<span class="hljs-string">"test2"</span>))
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- love2d lua! NOTE: this is in main4.lua in the love2d examples
require(&quot;core.Library&quot;)
GLOBAL,sThread=require(&quot;multi.integration.loveManager&quot;).init() -- load the love2d version of the lanesManager and requires the entire multi library
require(&quot;core.GuiManager&quot;)
gui.ff.Color=Color.Black
test=multi:newSystemThreadedTable(&quot;YO&quot;):init()
test[&quot;test1&quot;]=&quot;lol&quot;
multi:newSystemThread(&quot;test&quot;,function()
    tab=sThread.waitFor(&quot;YO&quot;):init()
    print(tab[&quot;test1&quot;])
    sThread.sleep(3)
    tab[&quot;test2&quot;]=&quot;Whats so funny?&quot;
end)
multi:newThread(&quot;test2&quot;,function()
    print(test:waitFor(&quot;test2&quot;))
    t.text=&quot;DONE!&quot;
end)
t=gui:newTextLabel(&quot;not done yet!&quot;,0,0,300,100)
t:centerX()
t:centerY()
</code></pre>"><span class="hljs-comment">-- love2d lua! NOTE: this is in main4.lua in the love2d examples</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core.Library"</span>)
GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.loveManager"</span>).init() <span class="hljs-comment">-- load the love2d version of the lanesManager and requires the entire multi library</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core.GuiManager"</span>)
gui.ff.Color=Color.Black
test=multi:newSystemThreadedTable(<span class="hljs-string">"YO"</span>):init()
test[<span class="hljs-string">"test1"</span>]=<span class="hljs-string">"lol"</span>
multi:newSystemThread(<span class="hljs-string">"test"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    tab=sThread.waitFor(<span class="hljs-string">"YO"</span>):init()
    <span class="hljs-built_in">print</span>(tab[<span class="hljs-string">"test1"</span>])
    sThread.sleep(<span class="hljs-number">3</span>)
    tab[<span class="hljs-string">"test2"</span>]=<span class="hljs-string">"Whats so funny?"</span>
<span class="hljs-keyword">end</span>)
multi:newThread(<span class="hljs-string">"test2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(test:waitFor(<span class="hljs-string">"test2"</span>))
    t.text=<span class="hljs-string">"DONE!"</span>
<span class="hljs-keyword">end</span>)
t=gui:newTextLabel(<span class="hljs-string">"not done yet!"</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">300</span>,<span class="hljs-number">100</span>)
t:centerX()
t:centerY()
</code></pre><h2 id="update:-1.8.1"><a name="update:-1.8.1" href="#update:-1.8.1"></a>Update: 1.8.1</h2><p>No real change!<br><br>Changed the structure of the library. Combined the coroutine based threads into the core!<br><br>Only compat and integrations are not part of the core and never will be by nature.<br><br>This should make the library more convent to use.<br><br>I left multi/all.lua file so if anyone had libraries/projects that used that it will still work!<br><br>Updated from 1.7.6 to 1.8.0<br> (How much thread could a thread htread if a thread could thread thread?)<br>Added:<br></p><ul>
<li>multi:newSystemThreadedQueue()</li><li>multi:systemThreadedBenchmark()</li><li>More example files</li><li>multi:canSystemThread() — true if an integration was added false otherwise (For module creation)</li><li>Fixed a few bugs in the loveManager</li></ul><h1 id="using-multi:systemthreadedbenchmark()"><a name="using-multi:systemthreadedbenchmark()" href="#using-multi:systemthreadedbenchmark()"></a>Using multi:systemThreadedBenchmark()</h1><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;&quot;..package.path
local GLOBAL,sThread=require(&quot;multi.integration.lanesManager&quot;).init()
multi:systemThreadedBenchmark(3):OnBench(function(self,count)
    print(&quot;First Bench: &quot;..count)
    multi:systemThreadedBenchmark(3,&quot;All Threads: &quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
multi:systemThreadedBenchmark(<span class="hljs-number">3</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,count)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"First Bench: "</span>..count)
    multi:systemThreadedBenchmark(<span class="hljs-number">3</span>,<span class="hljs-string">"All Threads: "</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="using-multi:newsystemthreadedqueue()"><a name="using-multi:newsystemthreadedqueue()" href="#using-multi:newsystemthreadedqueue()"></a>Using multi:newSystemThreadedQueue()</h1><p>Quick Note: queues shared across multiple objects will be pulling from the same “queue” keep this in mind when coding! <del>Also the queue respects direction a push on the thread side cannot be popped on the thread side… Same goes for the mainthread!<br></del> Turns out I was wrong about this…</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- in love2d, this file will be in the same example folder as before, but is named main2.lua
require(&quot;core.Library&quot;)
GLOBAL,sThread=require(&quot;multi.integration.loveManager&quot;).init() -- load the love2d version of the lanesManager and requires the entire multi library
--IMPORTANT
-- Do not make the above local, this is the one difference that the lanesManager does not have
-- If these are local the functions will have the upvalues put into them that do not exist on the threaded side
-- You will need to ensure that the function does not refer to any upvalues in its code. It will print an error if it does though
-- Also, each thread has a .1 second delay! This is used to generate a random value for each thread!
require(&quot;core.GuiManager&quot;)
gui.ff.Color=Color.Black
function multi:newSystemThreadedQueue(name) -- in love2d this will spawn a channel on both ends
    local c={}
    c.name=name
    if love then
        if love.thread then
            function c:init()
                self.chan=love.thread.getChannel(self.name)
                function self:push(v)
                    self.chan:push(v)
                end
                function self:pop()
                    return self.chan:pop()
                end
                GLOBAL[self.name]=self
                return self
            end
            return c
        else
            error(&quot;Make sure you required the love.thread module!&quot;)
        end
    else
        c.linda=lanes.linda()
        function c:push(v)
            self.linda:send(&quot;Q&quot;,v)
        end
        function c:pop()
            return ({self.linda:receive(0,&quot;Q&quot;)})[2]
        end
        function c:init()
            return self
        end
        GLOBAL[name]=c
    end
    return c
end
queue=multi:newSystemThreadedQueue(&quot;QUEUE&quot;):init()
queue:push(&quot;This is a test&quot;)
queue:push(&quot;This is a test2&quot;)
queue:push(&quot;This is a test3&quot;)
queue:push(&quot;This is a test4&quot;)
multi:newSystemThread(&quot;test2&quot;,function()
    queue=sThread.waitFor(&quot;QUEUE&quot;):init()
    data=queue:pop()
    while data do
        print(data)
        data=queue:pop()
    end
    queue:push(&quot;DONE!&quot;)
end)
multi:newThread(&quot;test!&quot;,function()
    thread.hold(function() return queue:pop() end)
    t.text=&quot;Done!&quot;
end)
t=gui:newTextLabel(&quot;no done yet!&quot;,0,0,300,100)
t:centerX()
t:centerY()
</code></pre>"><span class="hljs-comment">-- in love2d, this file will be in the same example folder as before, but is named main2.lua</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core.Library"</span>)
GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.loveManager"</span>).init() <span class="hljs-comment">-- load the love2d version of the lanesManager and requires the entire multi library</span>
<span class="hljs-comment">--IMPORTANT</span>
<span class="hljs-comment">-- Do not make the above local, this is the one difference that the lanesManager does not have</span>
<span class="hljs-comment">-- If these are local the functions will have the upvalues put into them that do not exist on the threaded side</span>
<span class="hljs-comment">-- You will need to ensure that the function does not refer to any upvalues in its code. It will print an error if it does though</span>
<span class="hljs-comment">-- Also, each thread has a .1 second delay! This is used to generate a random value for each thread!</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core.GuiManager"</span>)
gui.ff.Color=Color.Black
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multi:newSystemThreadedQueue</span><span class="hljs-params">(name)</span></span> <span class="hljs-comment">-- in love2d this will spawn a channel on both ends</span>
    <span class="hljs-keyword">local</span> c={}
    c.name=name
    <span class="hljs-keyword">if</span> love <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">if</span> love.thread <span class="hljs-keyword">then</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c:init</span><span class="hljs-params">()</span></span>
                self.chan=love.thread.getChannel(self.name)
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">self:push</span><span class="hljs-params">(v)</span></span>
                    self.chan:push(v)
                <span class="hljs-keyword">end</span>
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">self:pop</span><span class="hljs-params">()</span></span>
                    <span class="hljs-keyword">return</span> self.chan:pop()
                <span class="hljs-keyword">end</span>
                GLOBAL[self.name]=self
                <span class="hljs-keyword">return</span> self
            <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">return</span> c
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">error</span>(<span class="hljs-string">"Make sure you required the love.thread module!"</span>)
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">else</span>
        c.linda=lanes.linda()
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c:push</span><span class="hljs-params">(v)</span></span>
            self.linda:send(<span class="hljs-string">"Q"</span>,v)
        <span class="hljs-keyword">end</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c:pop</span><span class="hljs-params">()</span></span>
            <span class="hljs-keyword">return</span> ({self.linda:receive(<span class="hljs-number">0</span>,<span class="hljs-string">"Q"</span>)})[<span class="hljs-number">2</span>]
        <span class="hljs-keyword">end</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c:init</span><span class="hljs-params">()</span></span>
            <span class="hljs-keyword">return</span> self
        <span class="hljs-keyword">end</span>
        GLOBAL[name]=c
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> c
<span class="hljs-keyword">end</span>
queue=multi:newSystemThreadedQueue(<span class="hljs-string">"QUEUE"</span>):init()
queue:push(<span class="hljs-string">"This is a test"</span>)
queue:push(<span class="hljs-string">"This is a test2"</span>)
queue:push(<span class="hljs-string">"This is a test3"</span>)
queue:push(<span class="hljs-string">"This is a test4"</span>)
multi:newSystemThread(<span class="hljs-string">"test2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    queue=sThread.waitFor(<span class="hljs-string">"QUEUE"</span>):init()
    data=queue:pop()
    <span class="hljs-keyword">while</span> data <span class="hljs-keyword">do</span>
        <span class="hljs-built_in">print</span>(data)
        data=queue:pop()
    <span class="hljs-keyword">end</span>
    queue:push(<span class="hljs-string">"DONE!"</span>)
<span class="hljs-keyword">end</span>)
multi:newThread(<span class="hljs-string">"test!"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    thread.hold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> queue:pop() <span class="hljs-keyword">end</span>)
    t.text=<span class="hljs-string">"Done!"</span>
<span class="hljs-keyword">end</span>)
t=gui:newTextLabel(<span class="hljs-string">"no done yet!"</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">300</span>,<span class="hljs-number">100</span>)
t:centerX()
t:centerY()
</code></pre><h1 id="in-lanes"><a name="in-lanes" href="#in-lanes"></a>In Lanes</h1><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- The code is compatible with each other, I just wanted to show different things you can do in both examples
-- This file can be found in the examples folder as lanesintegrationtest4.lua
local GLOBAL,sThread=require(&quot;multi.integration.lanesManager&quot;).init()
queue=multi:newSystemThreadedQueue(&quot;QUEUE&quot;):init()
queue:push(&quot;This is a test&quot;)
queue:push(&quot;This is a test2&quot;)
queue:push(&quot;This is a test3&quot;)
queue:push(&quot;This is a test4&quot;)
multi:newSystemThread(&quot;test2&quot;,function()
    queue=sThread.waitFor(&quot;QUEUE&quot;):init()
    data=queue:pop()
    while data do
        print(data)
        data=queue:pop()
    end
    queue:push(&quot;This is a test5&quot;)
    queue:push(&quot;This is a test6&quot;)
    queue:push(&quot;This is a test7&quot;)
    queue:push(&quot;This is a test8&quot;)
end)
multi:newThread(&quot;test!&quot;,function() -- this is a lua thread
    thread.sleep(.1)
    data=queue:pop()
    while data do
        print(data)
        data=queue:pop()
    end
end)
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- The code is compatible with each other, I just wanted to show different things you can do in both examples</span>
<span class="hljs-comment">-- This file can be found in the examples folder as lanesintegrationtest4.lua</span>
<span class="hljs-keyword">local</span> GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
queue=multi:newSystemThreadedQueue(<span class="hljs-string">"QUEUE"</span>):init()
queue:push(<span class="hljs-string">"This is a test"</span>)
queue:push(<span class="hljs-string">"This is a test2"</span>)
queue:push(<span class="hljs-string">"This is a test3"</span>)
queue:push(<span class="hljs-string">"This is a test4"</span>)
multi:newSystemThread(<span class="hljs-string">"test2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    queue=sThread.waitFor(<span class="hljs-string">"QUEUE"</span>):init()
    data=queue:pop()
    <span class="hljs-keyword">while</span> data <span class="hljs-keyword">do</span>
        <span class="hljs-built_in">print</span>(data)
        data=queue:pop()
    <span class="hljs-keyword">end</span>
    queue:push(<span class="hljs-string">"This is a test5"</span>)
    queue:push(<span class="hljs-string">"This is a test6"</span>)
    queue:push(<span class="hljs-string">"This is a test7"</span>)
    queue:push(<span class="hljs-string">"This is a test8"</span>)
<span class="hljs-keyword">end</span>)
multi:newThread(<span class="hljs-string">"test!"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- this is a lua thread</span>
    thread.sleep(.<span class="hljs-number">1</span>)
    data=queue:pop()
    <span class="hljs-keyword">while</span> data <span class="hljs-keyword">do</span>
        <span class="hljs-built_in">print</span>(data)
        data=queue:pop()
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="update:-1.7.6"><a name="update:-1.7.6" href="#update:-1.7.6"></a>Update: 1.7.6</h2><p>Fixed:<br>Typos like always<br>Added:<br><br>multi:getPlatform() — returns “love2d” if using the love2d platform or returns “lanes” if using lanes for threading<br><br>examples files<br><br>In Events added method setTask(func)<br><br>The old way still works and is more convent to be honest, but I felt a method to do this was needed for completeness.<br></p><p>Updated:<br>some example files to reflect changes to the core. Changes allow for less typing<br><br>loveManager to require the compat if used so you don’t need 2 require line to retrieve the library<br></p><h2 id="update:-1.7.5"><a name="update:-1.7.5" href="#update:-1.7.5"></a>Update: 1.7.5</h2><p>Fixed some typos in the readme… (I am sure there are more there are always more)<br><br>Added more features for module support<br><br>TODO:<br><br>Work on performance of the library… I see 3 places where I can make this thing run quicker<br></p><p>I’ll show case some old versions of the multitasking library eventually so you can see its changes in days past!<br></p><h2 id="update:-1.7.4"><a name="update:-1.7.4" href="#update:-1.7.4"></a>Update: 1.7.4</h2><p>Added: the example folder which will be populated with more examples in the near future!<br><br>The loveManager integration that mimics the lanesManager integration almost exactly to keep coding in both environments as close to possible. This is done mostly for library creation support!<br><br>An example of the loveManager in action using almost the same code as the lanesintergreationtest2.lua<br><br>NOTE: This code has only been tested to work on love2d version 1.10.2 though it should work version 0.9.0</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;core.Library&quot;) -- Didn't add this to a repo yet! Will do eventually... Allows for injections and other cool things
require(&quot;multi.compat.love2d&quot;) -- allows for multitasking and binds my libraries to the love2d engine that i am using
GLOBAL,sThread=require(&quot;multi.integration.loveManager&quot;).init() -- load the love2d version of the lanesManager
--IMPORTANT
-- Do not make the above local, this is the one difference that the lanesManager does not have
-- If these are local the functions will have the upvalues put into them that do not exist on the threaded side
-- You will need to ensure that the function does not refer to any upvalues in its code. It will print an error if it does though
-- Also each thread has a .1 second delay! This is used to generate a random values for each thread!
require(&quot;core.GuiManager&quot;) -- allows the use of graphics in the program.
gui.ff.Color=Color.Black
function comma_value(amount)
    local formatted = amount
    while true do
        formatted, k = string.gsub(formatted, &quot;^(-?%d+)(%d%d%d)&quot;, '%1,%2')
        if (k==0) then
            break
        end
    end
    return formatted
end
multi:newSystemThread(&quot;test1&quot;,function() -- Another difference is that the multi library is already loaded in the threaded enviroment as well as a call to multi:mainloop()
    multi:benchMark(sThread.waitFor(&quot;Bench&quot;),nil,&quot;Thread 1&quot;):OnBench(function(self,c) GLOBAL[&quot;T1&quot;]=c multi:Stop() end)
end)
multi:newSystemThread(&quot;test2&quot;,function() -- spawns a thread in another lua process
    multi:benchMark(sThread.waitFor(&quot;Bench&quot;),nil,&quot;Thread 2&quot;):OnBench(function(self,c) GLOBAL[&quot;T2&quot;]=c multi:Stop() end)
end)
multi:newSystemThread(&quot;test3&quot;,function() -- spawns a thread in another lua process
    multi:benchMark(sThread.waitFor(&quot;Bench&quot;),nil,&quot;Thread 3&quot;):OnBench(function(self,c) GLOBAL[&quot;T3&quot;]=c multi:Stop() end)
end)
multi:newSystemThread(&quot;test4&quot;,function() -- spawns a thread in another lua process
    multi:benchMark(sThread.waitFor(&quot;Bench&quot;),nil,&quot;Thread 4&quot;):OnBench(function(self,c) GLOBAL[&quot;T4&quot;]=c multi:Stop() end)
end)
multi:newSystemThread(&quot;test5&quot;,function() -- spawns a thread in another lua process
    multi:benchMark(sThread.waitFor(&quot;Bench&quot;),nil,&quot;Thread 5&quot;):OnBench(function(self,c) GLOBAL[&quot;T5&quot;]=c multi:Stop() end)
end)
multi:newSystemThread(&quot;test6&quot;,function() -- spawns a thread in another lua process
    multi:benchMark(sThread.waitFor(&quot;Bench&quot;),nil,&quot;Thread 6&quot;):OnBench(function(self,c) GLOBAL[&quot;T6&quot;]=c multi:Stop() end)
end)
multi:newSystemThread(&quot;Combiner&quot;,function() -- spawns a thread in another lua process
    function comma_value(amount)
        local formatted = amount
        while true do
            formatted, k = string.gsub(formatted, &quot;^(-?%d+)(%d%d%d)&quot;, '%1,%2')
            if (k==0) then
                break
            end
        end
        return formatted
    end
    local b=comma_value(tostring(sThread.waitFor(&quot;T1&quot;)+sThread.waitFor(&quot;T2&quot;)+sThread.waitFor(&quot;T3&quot;)+sThread.waitFor(&quot;T4&quot;)+sThread.waitFor(&quot;T5&quot;)+sThread.waitFor(&quot;T6&quot;)))
    GLOBAL[&quot;DONE&quot;]=b
end)
multi:newThread(&quot;test0&quot;,function()
    -- sThread.waitFor(&quot;DONE&quot;) -- lets hold the main thread completely so we don't eat up cpu
    -- os.exit()
    -- when the main thread is holding there is a chance that error handling on the system threads may not work!
    -- instead we can do this
    while true do
        thread.skip(1) -- allow error handling to take place... Otherwise let’s keep the main thread running on the low
        -- Before we held just because we could... But this is a game and we need to have logic continue
        --sThreadM.sleep(.001) -- Sleeping for .001 is a great way to keep cpu usage down. Make sure if you aren't doing work to rest. Abuse the hell out of GLOBAL if you need to :P
        if GLOBAL[&quot;DONE&quot;] then
            t.text=&quot;Bench: &quot;..GLOBAL[&quot;DONE&quot;]
        end
    end
end)
GLOBAL[&quot;Bench&quot;]=3
t=gui:newTextLabel(&quot;no done yet!&quot;,0,0,300,100)
t:centerX()
t:centerY()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"core.Library"</span>) <span class="hljs-comment">-- Didn't add this to a repo yet! Will do eventually... Allows for injections and other cool things</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.compat.love2d"</span>) <span class="hljs-comment">-- allows for multitasking and binds my libraries to the love2d engine that i am using</span>
GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.loveManager"</span>).init() <span class="hljs-comment">-- load the love2d version of the lanesManager</span>
<span class="hljs-comment">--IMPORTANT</span>
<span class="hljs-comment">-- Do not make the above local, this is the one difference that the lanesManager does not have</span>
<span class="hljs-comment">-- If these are local the functions will have the upvalues put into them that do not exist on the threaded side</span>
<span class="hljs-comment">-- You will need to ensure that the function does not refer to any upvalues in its code. It will print an error if it does though</span>
<span class="hljs-comment">-- Also each thread has a .1 second delay! This is used to generate a random values for each thread!</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core.GuiManager"</span>) <span class="hljs-comment">-- allows the use of graphics in the program.</span>
gui.ff.Color=Color.Black
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">comma_value</span><span class="hljs-params">(amount)</span></span>
    <span class="hljs-keyword">local</span> formatted = amount
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">do</span>
        formatted, k = <span class="hljs-built_in">string</span>.gsub(formatted, <span class="hljs-string">"^(-?%d+)(%d%d%d)"</span>, <span class="hljs-string">'%1,%2'</span>)
        <span class="hljs-keyword">if</span> (k==<span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> formatted
<span class="hljs-keyword">end</span>
multi:newSystemThread(<span class="hljs-string">"test1"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- Another difference is that the multi library is already loaded in the threaded enviroment as well as a call to multi:mainloop()</span>
    multi:benchMark(sThread.waitFor(<span class="hljs-string">"Bench"</span>),<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Thread 1"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,c)</span></span> GLOBAL[<span class="hljs-string">"T1"</span>]=c multi:Stop() <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"test2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    multi:benchMark(sThread.waitFor(<span class="hljs-string">"Bench"</span>),<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Thread 2"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,c)</span></span> GLOBAL[<span class="hljs-string">"T2"</span>]=c multi:Stop() <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"test3"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    multi:benchMark(sThread.waitFor(<span class="hljs-string">"Bench"</span>),<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Thread 3"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,c)</span></span> GLOBAL[<span class="hljs-string">"T3"</span>]=c multi:Stop() <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"test4"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    multi:benchMark(sThread.waitFor(<span class="hljs-string">"Bench"</span>),<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Thread 4"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,c)</span></span> GLOBAL[<span class="hljs-string">"T4"</span>]=c multi:Stop() <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"test5"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    multi:benchMark(sThread.waitFor(<span class="hljs-string">"Bench"</span>),<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Thread 5"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,c)</span></span> GLOBAL[<span class="hljs-string">"T5"</span>]=c multi:Stop() <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"test6"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    multi:benchMark(sThread.waitFor(<span class="hljs-string">"Bench"</span>),<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Thread 6"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,c)</span></span> GLOBAL[<span class="hljs-string">"T6"</span>]=c multi:Stop() <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"Combiner"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">comma_value</span><span class="hljs-params">(amount)</span></span>
        <span class="hljs-keyword">local</span> formatted = amount
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">do</span>
            formatted, k = <span class="hljs-built_in">string</span>.gsub(formatted, <span class="hljs-string">"^(-?%d+)(%d%d%d)"</span>, <span class="hljs-string">'%1,%2'</span>)
            <span class="hljs-keyword">if</span> (k==<span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">return</span> formatted
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">local</span> b=comma_value(<span class="hljs-built_in">tostring</span>(sThread.waitFor(<span class="hljs-string">"T1"</span>)+sThread.waitFor(<span class="hljs-string">"T2"</span>)+sThread.waitFor(<span class="hljs-string">"T3"</span>)+sThread.waitFor(<span class="hljs-string">"T4"</span>)+sThread.waitFor(<span class="hljs-string">"T5"</span>)+sThread.waitFor(<span class="hljs-string">"T6"</span>)))
    GLOBAL[<span class="hljs-string">"DONE"</span>]=b
<span class="hljs-keyword">end</span>)
multi:newThread(<span class="hljs-string">"test0"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-comment">-- sThread.waitFor("DONE") -- lets hold the main thread completely so we don't eat up cpu</span>
    <span class="hljs-comment">-- os.exit()</span>
    <span class="hljs-comment">-- when the main thread is holding there is a chance that error handling on the system threads may not work!</span>
    <span class="hljs-comment">-- instead we can do this</span>
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">do</span>
        thread.skip(<span class="hljs-number">1</span>) <span class="hljs-comment">-- allow error handling to take place... Otherwise let’s keep the main thread running on the low</span>
        <span class="hljs-comment">-- Before we held just because we could... But this is a game and we need to have logic continue</span>
        <span class="hljs-comment">--sThreadM.sleep(.001) -- Sleeping for .001 is a great way to keep cpu usage down. Make sure if you aren't doing work to rest. Abuse the hell out of GLOBAL if you need to :P</span>
        <span class="hljs-keyword">if</span> GLOBAL[<span class="hljs-string">"DONE"</span>] <span class="hljs-keyword">then</span>
            t.text=<span class="hljs-string">"Bench: "</span>..GLOBAL[<span class="hljs-string">"DONE"</span>]
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
GLOBAL[<span class="hljs-string">"Bench"</span>]=<span class="hljs-number">3</span>
t=gui:newTextLabel(<span class="hljs-string">"no done yet!"</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">300</span>,<span class="hljs-number">100</span>)
t:centerX()
t:centerY()
</code></pre><h2 id="update:-1.7.3"><a name="update:-1.7.3" href="#update:-1.7.3"></a>Update: 1.7.3</h2><p>Changed how requiring the library works!<br><code>require("multi.all")</code> Will still work as expected; however, with the exception of threading, compat, and integrations everything else has been moved into the core of the library.</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- This means that these are no longer required and will cause an error if done so
require(&quot;multi.loop&quot;)
require(&quot;multi.alarm&quot;)
require(&quot;multi.updater&quot;)
require(&quot;multi.tloop&quot;)
require(&quot;multi.watcher&quot;)
require(&quot;multi.tstep&quot;)
require(&quot;multi.step&quot;)
require(&quot;multi.task&quot;)
-- ^ they are all part of the core now
</code></pre>"><span class="hljs-comment">-- This means that these are no longer required and will cause an error if done so</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.loop"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.alarm"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.updater"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.tloop"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.watcher"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.tstep"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.step"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.task"</span>)
<span class="hljs-comment">-- ^ they are all part of the core now</span>
</code></pre><h2 id="update:-1.7.2"><a name="update:-1.7.2" href="#update:-1.7.2"></a>Update: 1.7.2</h2><p>Moved updaters, loops, and alarms into the init.lua file. I consider them core features and they are referenced in the init.lua file so they need to exist there. Threaded versions are still separate though. Added another example file</p><h2 id="update:-1.7.1-bug-fixes-only"><a name="update:-1.7.1-bug-fixes-only" href="#update:-1.7.1-bug-fixes-only"></a>Update: 1.7.1 Bug Fixes Only</h2><h2 id="update:-1.7.0"><a name="update:-1.7.0" href="#update:-1.7.0"></a>Update: 1.7.0</h2><p>Modified: multi.integration.lanesManager.lua<br>It is now in a stable and simple state Works with the latest lanes version! Tested with version 3.11 I cannot promise that everything will work with earlier versions. Future versions are good though.<br><br>Example Usage:<br><br>sThread is a handle to a global interface for system threads to interact with themselves<br><br>thread is the interface for multithreads as seen in the threading section<br></p><p>GLOBAL a table that can be used throughout each and every thread</p><p>sThreads have a few methods<br><br>sThread.set(name,val) — you can use the GLOBAL table instead modifies the same table anyway<br><br>sThread.get(name) — you can use the GLOBAL table instead modifies the same table anyway<br><br>sThread.waitFor(name) — waits until a value exists, if it does it returns it<br><br>sThread.getCores() — returns the number of cores on your cpu<br><br>sThread.sleep(n) — sleeps for a bit stopping the entire thread from running<br><br>sThread.hold(n) — sleeps until a condition is met<br></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>local GLOBAL,sThread=require(&quot;multi.integration.lanesManager&quot;).init()
require(&quot;multi.all&quot;)
multi:newAlarm(2):OnRing(function(self)
    GLOBAL[&quot;NumOfCores&quot;]=sThread.getCores()
end)
multi:newAlarm(7):OnRing(function(self)
    GLOBAL[&quot;AnotherTest&quot;]=true
end)
multi:newAlarm(13):OnRing(function(self)
    GLOBAL[&quot;FinalTest&quot;]=true
end)
multi:newSystemThread(&quot;test&quot;,function() -- spawns a thread in another lua process
    require(&quot;multi.all&quot;) -- now you can do all of your coding with the multi library! You could even spawn more threads from here with the integration. You would need to require the interaction again though
    print(&quot;Waiting for variable: NumOfCores&quot;)
    print(&quot;Got it: &quot;,sThread.waitFor(&quot;NumOfCores&quot;))
    sThread.hold(function()
        return GLOBAL[&quot;AnotherTest&quot;] -- note this would hold the entire systemthread. Spawn a coroutine thread using multi:newThread() or multi:newThreaded...
    end)
    print(&quot;Holding works!&quot;)
    multi:newThread(&quot;tests&quot;,function()
        thread.hold(function()
            return GLOBAL[&quot;FinalTest&quot;] -- note this will not hold the entire systemthread. As seen with the TLoop constantly going!
        end)
        print(&quot;Final test works!&quot;)
        os.exit()
    end)
    local a=0
    multi:newTLoop(function()
        a=a+1
        print(a)
    end,.5)
    multi:mainloop()
end)
multi:mainloop()
</code></pre>"><span class="hljs-keyword">local</span> GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.all"</span>)
multi:newAlarm(<span class="hljs-number">2</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    GLOBAL[<span class="hljs-string">"NumOfCores"</span>]=sThread.getCores()
<span class="hljs-keyword">end</span>)
multi:newAlarm(<span class="hljs-number">7</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    GLOBAL[<span class="hljs-string">"AnotherTest"</span>]=<span class="hljs-keyword">true</span>
<span class="hljs-keyword">end</span>)
multi:newAlarm(<span class="hljs-number">13</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    GLOBAL[<span class="hljs-string">"FinalTest"</span>]=<span class="hljs-keyword">true</span>
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"test"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.all"</span>) <span class="hljs-comment">-- now you can do all of your coding with the multi library! You could even spawn more threads from here with the integration. You would need to require the interaction again though</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Waiting for variable: NumOfCores"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Got it: "</span>,sThread.waitFor(<span class="hljs-string">"NumOfCores"</span>))
    sThread.hold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        <span class="hljs-keyword">return</span> GLOBAL[<span class="hljs-string">"AnotherTest"</span>] <span class="hljs-comment">-- note this would hold the entire systemthread. Spawn a coroutine thread using multi:newThread() or multi:newThreaded...</span>
    <span class="hljs-keyword">end</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Holding works!"</span>)
    multi:newThread(<span class="hljs-string">"tests"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        thread.hold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
            <span class="hljs-keyword">return</span> GLOBAL[<span class="hljs-string">"FinalTest"</span>] <span class="hljs-comment">-- note this will not hold the entire systemthread. As seen with the TLoop constantly going!</span>
        <span class="hljs-keyword">end</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Final test works!"</span>)
        <span class="hljs-built_in">os</span>.exit()
    <span class="hljs-keyword">end</span>)
    <span class="hljs-keyword">local</span> a=<span class="hljs-number">0</span>
    multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        a=a+<span class="hljs-number">1</span>
        <span class="hljs-built_in">print</span>(a)
    <span class="hljs-keyword">end</span>,.<span class="hljs-number">5</span>)
    multi:mainloop()
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="update:-1.6.0"><a name="update:-1.6.0" href="#update:-1.6.0"></a>Update: 1.6.0</h2><p>Changed: steps and loops</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Was
step:OnStep(function(pos,self) -- same goes for tsteps as well
    print(pos)
end)
multi:newLoop(function(dt,self)
    print(dt)
end)
-- Is now
step:OnStep(function(self,pos) -- same goes for tsteps as wellc
    print(pos)
end)
multi:newLoop(function(self,dt)
    print(dt)
end)
</code></pre>"><span class="hljs-comment">-- Was</span>
step:OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(pos,self)</span></span> <span class="hljs-comment">-- same goes for tsteps as well</span>
    <span class="hljs-built_in">print</span>(pos)
<span class="hljs-keyword">end</span>)
multi:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(dt,self)</span></span>
    <span class="hljs-built_in">print</span>(dt)
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- Is now</span>
step:OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,pos)</span></span> <span class="hljs-comment">-- same goes for tsteps as wellc</span>
    <span class="hljs-built_in">print</span>(pos)
<span class="hljs-keyword">end</span>)
multi:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-built_in">print</span>(dt)
<span class="hljs-keyword">end</span>)
</code></pre><p>Reasoning I wanted to keep objects consistent, but a lot of my older libraries use the old way of doing things. Therefore, I added a backwards module</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi.all&quot;)
require(&quot;multi.compat.backwards[1,5,0]&quot;) -- allows for the use of features that were scrapped/changed in 1.6.0+
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.all"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.compat.backwards[1,5,0]"</span>) <span class="hljs-comment">-- allows for the use of features that were scrapped/changed in 1.6.0+</span>
</code></pre><h2 id="update:-1.5.0"><a name="update:-1.5.0" href="#update:-1.5.0"></a>Update: 1.5.0</h2><p>Added:</p><ul>
<li>An easy way to manage timeouts</li><li>Small bug fixes</li></ul><h2 id="update:-1.4.1---first-public-release-of-the-library"><a name="update:-1.4.1---first-public-release-of-the-library" href="#update:-1.4.1---first-public-release-of-the-library"></a>Update: 1.4.1 - First Public release of the library</h2><p><strong>IMPORTANT:</strong><br>Every update I make aims to make things simpler more efficient and just better, but a lot of old code, which can be really big, uses a lot of older features. I know the pain of having to rewrite everything. My promise to my library users is that I will always have backwards support for older features! New ways may exist that are quicker and easier, but the old features/methods will be supported.<br><strong>Note:</strong> Version 2.x.x sort of breaks this promise. Sorry about that, but a new major version means changes that had to be made. Not too much has changed though and base code is 100% compatiable. What changed was how you init the library and some files that were removed due to not really being used by what i have seen. The older backwards compat file was for an older version of the library that was changed before the public release had any traction. The goal is still to provide a easy way to multitask in lua. I’ll try my best however to ensure that not much changes and that changes are easy to make if they are introduced.</p>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
