<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>Documentation.html</title>
  <meta name="generator" content="Haroopad 0.13.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}@import url(http://fonts.googleapis.com/css?family=Roboto+Condensed:300italic,400italic,700italic,400,300,700);.haroopad{padding:20px;color:#222;font-size:15px;font-family:"Roboto Condensed",Tauri,"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;background:#fff;line-height:1.6;-webkit-font-smoothing:antialiased}.haroopad a{color:#3269a0}.haroopad a:hover{color:#4183c4}.haroopad h2{border-bottom:1px solid #e6e6e6}.haroopad h6{color:#777}.haroopad hr{border:1px solid #e6e6e6}.haroopad blockquote>code,.haroopad h1>code,.haroopad h2>code,.haroopad h3>code,.haroopad h4>code,.haroopad h5>code,.haroopad h6>code,.haroopad li>code,.haroopad p>code,.haroopad td>code{font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;font-size:85%;background-color:rgba(0,0,0,.02);padding:.2em .5em;border:1px solid #efefef}.haroopad pre>code{font-size:1em;letter-spacing:-1px;font-weight:700}.haroopad blockquote{border-left:4px solid #e6e6e6;padding:0 15px;color:#777}.haroopad table{background-color:#fafafa}.haroopad table tr td,.haroopad table tr th{border:1px solid #e6e6e6}.haroopad table tr:nth-child(2n){background-color:#f2f2f2}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-pi,.lisp .hljs-string{color:#93a1a1}.css .hljs-tag,.hljs-addition,.hljs-keyword,.hljs-request,.hljs-status,.hljs-winutils,.method,.nginx .hljs-title{color:#859900}.hljs-command,.hljs-dartdoc,.hljs-hexcolor,.hljs-link_url,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-rules .hljs-value,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#2aa198}.css .hljs-function,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.vhdl .hljs-literal{color:#268bd2}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-link_reference,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.css .hljs-pseudo,.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-header,.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#eee8d5}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:2px;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:2px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:1em}.MathJax_MenuRadioCheck.RTL{right:1em;left:auto}.MathJax_MenuLabel{padding:2px 2em 4px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #CCC;margin:4px 1px 0}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:Highlight;color:HighlightText}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown haroopad">
<p>Current Multi Version: 13.0.0</p><h2 id="table-of-contents"><a name="table-of-contents" href="#table-of-contents"></a>Table of contents</h2><p class="toc" style="undefined"></p><ul>
<li><ul>
<li><span class="title">
<a href="#table-of-contents" title="Table of contents">Table of contents</a>
</span>
<!--span class="number">
0
</span-->
</li>
<li><span class="title">
<a href="#multi-static-variables" title="Multi static variables">Multi static variables</a>
</span>
<!--span class="number">
1
</span-->
</li>
<li><span class="title">
<a href="#multi-runners" title="Multi Runners">Multi Runners</a>
</span>
<!--span class="number">
2
</span-->
</li>
<li><span class="title">
<a href="#multi-settings" title="Multi Settings">Multi Settings</a>
</span>
<!--span class="number">
3
</span-->
</li>
<li><span class="title">
<a href="#multi-constructors---multi-objs" title="Multi constructors - Multi-Objs">Multi constructors - Multi-Objs</a>
</span>
<!--span class="number">
4
</span-->
</li>
<li><span class="title">
<a href="#processor" title="Processor">Processor</a>
</span>
<!--span class="number">
5
</span-->
</li>
<li><span class="title">
<a href="#non-actor:-timers" title="Non-Actor: Timers">Non-Actor: Timers</a>
</span>
<!--span class="number">
6
</span-->
</li>
<li><span class="title">
<a href="#non-actor:-connections" title="Non-Actor: Connections">Non-Actor: Connections</a>
</span>
<!--span class="number">
7
</span-->
</li>
<li><span class="title">
<a href="#non-actor:-jobs" title="Non-Actor: Jobs">Non-Actor: Jobs</a>
</span>
<!--span class="number">
8
</span-->
</li>
<li><span class="title">
<a href="#non-actor:-functions" title="Non-Actor: Functions">Non-Actor: Functions</a>
</span>
<!--span class="number">
9
</span-->
</li>
<li><span class="title">
<a href="#non-actor:-triggers" title="Non-Actor: Triggers ">Non-Actor: Triggers </a>
</span>
<!--span class="number">
10
</span-->
</li>
<li><span class="title">
<a href="#universal-actor-functions" title="Universal Actor functions">Universal Actor functions</a>
</span>
<!--span class="number">
11
</span-->
</li>
<li><span class="title">
<a href="#actor:-events" title="Actor: Events">Actor: Events</a>
</span>
<!--span class="number">
12
</span-->
</li>
<li><span class="title">
<a href="#actor:-updates" title="Actor: Updates">Actor: Updates</a>
</span>
<!--span class="number">
13
</span-->
</li>
<li><span class="title">
<a href="#actor:-alarms" title="Actor: Alarms">Actor: Alarms</a>
</span>
<!--span class="number">
14
</span-->
</li>
<li><span class="title">
<a href="#actor:-loops" title="Actor: Loops">Actor: Loops</a>
</span>
<!--span class="number">
15
</span-->
</li>
<li><span class="title">
<a href="#actor:-tloops" title="Actor: TLoops">Actor: TLoops</a>
</span>
<!--span class="number">
16
</span-->
</li>
<li><span class="title">
<a href="#actor:-steps" title="Actor: Steps">Actor: Steps</a>
</span>
<!--span class="number">
17
</span-->
</li>
<li><span class="title">
<a href="#actor:-tsteps" title="Actor: TSteps">Actor: TSteps</a>
</span>
<!--span class="number">
18
</span-->
</li>
<li><span class="title">
<a href="#actor:-time-stampers" title="Actor: Time Stampers">Actor: Time Stampers</a>
</span>
<!--span class="number">
19
</span-->
</li>
<li><span class="title">
<a href="#actor:-watchers" title="Actor: Watchers ">Actor: Watchers </a>
</span>
<!--span class="number">
20
</span-->
</li>
<li><span class="title">
<a href="#actor:-custom-object" title="Actor: Custom Object">Actor: Custom Object</a>
</span>
<!--span class="number">
21
</span-->
</li>
<li><span class="title">
<a href="#coroutine-based-threading-(cbt)" title="Coroutine based Threading (CBT)">Coroutine based Threading (CBT)</a>
</span>
<!--span class="number">
22
</span-->
</li>
<li><span class="title">
<a href="#threads.*" title="threads.*">threads.*</a>
</span>
<!--span class="number">
23
</span-->
</li>
<li><span class="title">
<a href="#cbt:-thread" title="CBT: Thread">CBT: Thread</a>
</span>
<!--span class="number">
24
</span-->
</li>
<li><span class="title">
<a href="#cbt:-threaded-process" title="CBT: Threaded Process">CBT: Threaded Process</a>
</span>
<!--span class="number">
25
</span-->
</li>
<li><span class="title">
<a href="#cbt:-hyper-threaded-process" title="CBT: Hyper Threaded Process">CBT: Hyper Threaded Process</a>
</span>
<!--span class="number">
26
</span-->
</li>
<li><span class="title">
<a href="#system-threads-(st)---multi-integration-getting-started" title="System Threads (ST) - Multi-Integration Getting Started">System Threads (ST) - Multi-Integration Getting Started</a>
</span>
<!--span class="number">
27
</span-->
</li>
<li><span class="title">
<a href="#st---thread-namespace" title="ST - THREAD namespace">ST - THREAD namespace</a>
</span>
<!--span class="number">
28
</span-->
</li>
<li><span class="title">
<a href="#st---global-namespace" title="ST - GLOBAL namespace">ST - GLOBAL namespace</a>
</span>
<!--span class="number">
29
</span-->
</li>
<li><span class="title">
<a href="#st---system-threads" title="ST - System Threads">ST - System Threads</a>
</span>
<!--span class="number">
30
</span-->
</li>
<li><span class="title">
<a href="#st---system-threaded-objects" title="ST - System Threaded Objects">ST - System Threaded Objects</a>
</span>
<!--span class="number">
31
</span-->
</li>
<li><span class="title">
<a href="#st---systemthreadedqueue" title="ST - SystemThreadedQueue">ST - SystemThreadedQueue</a>
</span>
<!--span class="number">
32
</span-->
</li>
<li><span class="title">
<a href="#st---systemthreadedconsole" title="ST - SystemThreadedConsole">ST - SystemThreadedConsole</a>
</span>
<!--span class="number">
33
</span-->
</li>
<li><span class="title">
<a href="#st---systemthreadedjobqueue" title="ST - SystemThreadedJobQueue">ST - SystemThreadedJobQueue</a>
</span>
<!--span class="number">
34
</span-->
</li>
<li><span class="title">
<a href="#st---systemthreadedconnection---wip*" title="ST - SystemThreadedConnection - WIP*">ST - SystemThreadedConnection - WIP*</a>
</span>
<!--span class="number">
35
</span-->
</li>
<li><span class="title">
<a href="#st---systemthreadedtable---wip*" title="ST - SystemThreadedTable - WIP*">ST - SystemThreadedTable - WIP*</a>
</span>
<!--span class="number">
36
</span-->
</li>
<li><span class="title">
<a href="#st---systemthreadedbenchmark" title="ST - SystemThreadedBenchmark">ST - SystemThreadedBenchmark</a>
</span>
<!--span class="number">
37
</span-->
</li>
<li><span class="title">
<a href="#st---systemthreadedexecute-wip*-might-remove" title="ST - SystemThreadedExecute WIP* Might remove">ST - SystemThreadedExecute WIP* Might remove</a>
</span>
<!--span class="number">
38
</span-->
</li>
<li><span class="title">
<a href="#network-threads---multi-integration" title="Network Threads - Multi-Integration">Network Threads - Multi-Integration</a>
</span>
<!--span class="number">
39
</span-->
</li>
</ul>
</li>

</ul>
<p></p><h2 id="multi-static-variables"><a name="multi-static-variables" href="#multi-static-variables"></a>Multi static variables</h2><p><code>multi.Version</code> — The current version of the library<br><code>multi.Priority_Core</code> — Highest level of pirority that can be given to a process<br><code>multi.Priority_High</code><br><code>multi.Priority_Above_Normal</code><br><code>multi.Priority_Normal</code> — The default level of pirority that is given to a process<br><code>multi.Priority_Below_Normal</code><br><code>multi.Priority_Low</code><br><code>multi.Priority_Idle</code> — Lowest level of pirority that can be given to a process</p><h2 id="multi-runners"><a name="multi-runners" href="#multi-runners"></a>Multi Runners</h2><p><code>multi:mainloop([TABLE settings])</code> — This runs the mainloop by having its own internal while loop running<br><code>multi:threadloop([TABLE settings])</code> — This runs the mainloop by having its own internal while loop running, but prioritizes threads over multi-objects<br><code>multi:uManager([TABLE settings])</code> — This runs the mainloop, but does not have its own while loop and thus needs to be within a loop of some kind.</p><h2 id="multi-settings"><a name="multi-settings" href="#multi-settings"></a>Multi Settings</h2><p><strong>Note:</strong> Most settings have been fined tuned to be at the peak of performance already, however preLoop, protect (Which drastically lowers preformance), and stopOnError should be used freely to fit your needs.</p><table>
<thead>
<tr>
<th>Setting</th>
<th>Type: default</th>
<th>Purpose</th>
</tr>
</thead>
<tbody>
<tr>
<td>preLoop</td>
<td>function: nil</td>
<td>This is a function that is called after all the important components of the library are loaded. This is called once only. The first and only argument passed is a reference to itself.</td>
</tr>
<tr>
<td>protect</td>
<td>boolean: false</td>
<td>This runs code within a protected call. To catch when errors happen see built in connections</td>
</tr>
<tr>
<td>stopOnError</td>
<td>boolean: false</td>
<td>This setting is used with protect. If an object crashes due to some error should it be paused?</td>
</tr>
<tr>
<td>priority</td>
<td>number: 0</td>
<td>This sets the priority scheme. Look at the P-Charts below for examples.</td>
</tr>
<tr>
<td>auto_priority</td>
<td>boolean: false</td>
<td><strong>Note: This overrides any value set for priority!</strong> If auto priority is enabled then priority scheme 3 is used and processes are considered for “recheck” after a certain amount of time. If a process isn’t taking too long to complete anymore then it will be reset to core, if it starts to take a lot of time all of a sudden it will be set to idle.</td>
</tr>
<tr>
<td>auto_stretch</td>
<td>number: 1</td>
<td>For use with auto_priority. Modifies the internal reperesentation of idle time by multiplying multi.Priority_Idle by the value given</td>
</tr>
<tr>
<td>auto_delay</td>
<td>number: 3</td>
<td>For use with auto_priority. This changes the time in seconds that process are “rechecked”</td>
</tr>
<tr>
<td>auto_lowerbound</td>
<td>number: multi.Priority_Idle</td>
<td>For use with auto_priority. The lowerbound is what is considered to be idle time. A higher value combined with auto_stretch allows one to fine tune how pirority is managed.</td>
</tr>
</tbody>
</table><h1 id="p-chart:-priority-1"><a name="p-chart:-priority-1" href="#p-chart:-priority-1"></a>P-Chart: Priority 1</h1><p>P1 follows a forumla that resembles this: ~n=I*PRank where n is the amount of steps given to an object with PRank and where I is the idle time see chart below. The aim of this priority scheme was to make core objects run fastest while letting idle processes get decent time as well.</p><table>
<thead>
<tr>
<th>Priority: n</th>
<th>PRank</th>
<th>Formula</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core: 3322269</td>
<td>7</td>
<td>n = ~<strong>I*</strong>7</td>
</tr>
<tr>
<td>High: 2847660</td>
<td>6</td>
<td>n = ~<strong>I*</strong>6</td>
</tr>
<tr>
<td>Above_Normal: 2373050</td>
<td>5</td>
<td>n = ~<strong>I*</strong>5</td>
</tr>
<tr>
<td>Normal: 1898440</td>
<td>4</td>
<td>n = ~<strong>I*</strong>4</td>
</tr>
<tr>
<td>Below_Normal: 1423830</td>
<td>3</td>
<td>n = ~<strong>I*</strong>3</td>
</tr>
<tr>
<td>Low: 949220</td>
<td>2</td>
<td>n = ~<strong>I*</strong>2</td>
</tr>
<tr>
<td><strong>I</strong>dle: 474610</td>
<td>1</td>
<td>n = ~<strong>I*</strong>1</td>
</tr>
</tbody>
</table><p><strong>General Rule:</strong> ~n=<strong>I*</strong>PRank</p><h1 id="p-chart:-priority-2"><a name="p-chart:-priority-2" href="#p-chart:-priority-2"></a>P-Chart: Priority 2</h1><p>P2 follows a formula that resembles this: ~n=n*4 where n starts as the initial idle time, see chart below. The goal of this one was to make core process’ higher while keeping idle process’ low.</p><table>
<thead>
<tr>
<th>Priority: n</th>
</tr>
</thead>
<tbody>
<tr>
<td>Core: 6700821</td>
</tr>
<tr>
<td>High: 1675205</td>
</tr>
<tr>
<td>Above_Normal: 418801</td>
</tr>
<tr>
<td>Normal: 104700</td>
</tr>
<tr>
<td>Below_Normal: 26175</td>
</tr>
<tr>
<td>Low: 6543</td>
</tr>
<tr>
<td><strong>I</strong>dle: 1635</td>
</tr>
</tbody>
</table><p><strong>General Rule:</strong> <code>~n=n*4</code> Where the inital n = <strong>I</strong></p><h1 id="p-chart:-priority-3"><a name="p-chart:-priority-3" href="#p-chart:-priority-3"></a>P-Chart: Priority 3</h1><p>P3 Ignores using a basic formula and instead bases its processing time on the amount of cpu time is there. If cpu-time is low and a process is set at a lower priority it will get its time reduced. There is no formula, at idle almost all process work at the same speed!</p><p>There are 2 settings for this: Core and Idle. If a process takes too long then it is set to idle. Otherwise it will stay core.</p><p>Example of settings:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>settings = {
    preLoop = function(m)
        print(&quot;All settings have been loaded!&quot;)
    end,
    protect = false,
    stopOnError = false,
    priority = 0,
    auto_priority = false,
    auto_stretch = 1,
    auto_delay = 3,
    auto_lowerbound = multi.Priority_Idle
}

-- Below are how the runners work

multi:mainloop(settings)

-- or

multi:threadloop(settings)

-- or

while true do
    multi:uManager(settings)
end
</code></pre>">settings = {
    preLoop = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(m)</span></span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"All settings have been loaded!"</span>)
    <span class="hljs-keyword">end</span>,
    protect = <span class="hljs-keyword">false</span>,
    stopOnError = <span class="hljs-keyword">false</span>,
    priority = <span class="hljs-number">0</span>,
    auto_priority = <span class="hljs-keyword">false</span>,
    auto_stretch = <span class="hljs-number">1</span>,
    auto_delay = <span class="hljs-number">3</span>,
    auto_lowerbound = multi.Priority_Idle
}

<span class="hljs-comment">-- Below are how the runners work</span>

multi:mainloop(settings)

<span class="hljs-comment">-- or</span>

multi:threadloop(settings)

<span class="hljs-comment">-- or</span>

<span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">do</span>
    multi:uManager(settings)
<span class="hljs-keyword">end</span>
</code></pre><h2 id="multi-constructors---multi-objs"><a name="multi-constructors---multi-objs" href="#multi-constructors---multi-objs"></a>Multi constructors - Multi-Objs</h2><p><strong>Processors</strong><br><code>proc = multi:newProcessor([STRING: file nil])</code></p><p><strong>Non-Actors</strong><br><code>timer = multi:newTimer()</code><br><code>conn = multi:newConnection([BOOLEAN protect true])</code><br><code>nil = multi:newJob(FUNCTION func, STRING name)</code><br><code>func = multi:newFunction(FUNCTION func)</code><br><code>trigger = multi:newTrigger(FUNCTION: func)</code></p><p><strong>Actors</strong><br><code>event = multi:newEvent(FUNCTION task)</code><br><code>updater =  multi:newUpdater([NUMBER skip 1])</code><br><code>alarm = multi:newAlarm([NUMBER 0])</code><br><code>loop = multi:newLoop(FUNCTION func)</code><br><code>tloop = multi:newTLoop(FUNCTION func ,NUMBER: [set 1])</code><br><code>step = multi:newStep(NUMBER start,*NUMBER reset, [NUMBER count 1], [NUMBER skip 0])</code><br><code>tstep = multi:newStep(NUMBER start, NUMBER reset, [NUMBER count 1], [NUMBER set 1])</code><br><code>trigger = multi:newTrigger(FUNCTION: func)</code><br><code>stamper = multi:newTimeStamper()</code><br><code>watcher = multi:newWatcher(STRING name)</code><br><code>watcher = multi:newWatcher(TABLE namespace, STRING name)</code><br><code>cobj = multi:newCustomObject(TABLE objRef, BOOLEAN isActor)</code></p><p>Note: A lot of methods will return self as a return. This is due to the ability to chain that was added in 12.x.x</p><h2 id="processor"><a name="processor" href="#processor"></a>Processor</h2><p><code>proc = multi:newProcessor([STRING file nil])</code><br>Creates a processor runner that acts like the multi runner. Actors and Non-Actors can be created on these objects. Pausing a process pauses all objects that are running on that process.</p><p>An optional argument file is used if you want to load a file containing the processor data.<br>Note: This isn’t portable on all areas where lua is used. Some interperters disable loadstring so it is not encouraged to use the file method for creating processors</p><p><code>loop = Processor:getController()</code> — returns the loop that runs the “runner” that drives this processor<br><code>self = Processor:Start()</code> — Starts the processor<br><code>self = Processor:Pause()</code> — Pauses the processor<br><code>self = Processor:Resume()</code> — Resumes a paused processor<br><code>nil = Processor:Destroy()</code> — Destroys the processor and all of the Actors running on it</p><p>Example</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>multi = require(&quot;multi&quot;)
proc = multi:newProcessor()
proc:newTLoop(function() -- create a t loop that runs every second
    print(&quot;Hi!&quot;)
end,1) -- where we set the 1 second
proc:Start() -- let's start the processor
multi:mainloop() -- the main runner that drives everything
</code></pre>">multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
proc = multi:newProcessor()
proc:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- create a t loop that runs every second</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hi!"</span>)
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">-- where we set the 1 second</span>
proc:Start() <span class="hljs-comment">-- let's start the processor</span>
multi:mainloop() <span class="hljs-comment">-- the main runner that drives everything</span>
</code></pre><h2 id="non-actor:-timers"><a name="non-actor:-timers" href="#non-actor:-timers"></a>Non-Actor: Timers</h2><p>timer = multi:newTimer()<br>Creates a timer object that can keep track of time</p><p><strong>self</strong> = timer:Start() — Starts the timer<br>time_elapsed = timer:Get() — Returns the time elapsed since timer:Start() was called<br>boolean = timer:isPaused() — Returns if the timer is paused or not<br><strong>self</strong> = timer:Pause() — Pauses the timer, it skips time that would be counted during the time that it is paused<br><strong>self</strong> = timer:Resume() — Resumes a paused timer. <strong>See note below</strong><br><strong>self</strong> = timer:tofile(<strong>STRING</strong> path) — Saves the object to a file at location path</p><p><strong>Note:</strong> If a timer was paused after 1 second then resumed a second later and Get() was called a second later, timer would have 2 seconds counted though 3 really have passed.</p><h2 id="non-actor:-connections"><a name="non-actor:-connections" href="#non-actor:-connections"></a>Non-Actor: Connections</h2><p>Arguable my favorite object in this library, next to threads</p><p><code>conn = multi:newConnection([BOOLEAN protect true])</code><br>Creates a connection object and defaults to a protective state. All calls will run within pcall()</p><p><code>self = conn:HoldUT([NUMBER n 0])</code> — Will hold futhur execution of the thread until the connection was triggered. If n is supplied the connection must be triggered n times before it will allow ececution to continue.<br><code>self = conn:FConnect(FUNCTION func)</code> — Creates a connection that is forced to execute when Fire() is called.  returns or nil = conn:Fire(…) — Triggers the connection with arguments …, “returns” if non-nil is a table containing return values from the triggered connections. [<strong>Deprecated:</strong>  Planned removal in 14.x.x]<br><code>self = conn:Bind(TABLE t)</code> — sets the table to hold the connections. Leaving it alone is best unless you know what you are doing<br><code>self = conn:Remove()</code> — removes the bind that was put in place. This will also destroy all connections that existed before.<br><code>link = conn:connect(FUNCTION func, [STRING name nil], [NUMBER num #conns+1])</code> — Connects to the object using function func which will recieve the arguments passed by Fire(…). You can name a connection, which allows you to use conn:getConnection(name). Names must be unique! num is simple the position in the order in which connections are triggered. The return Link is the link to the connected event that was made. You can remove this event or even trigger it specifically if need be.<br><code>link:Fire(...)</code> — Fires the created event<br><code>bool = link:Destroy()</code> — returns true if success.<br><code>subConn = conn:getConnection(STRING name, BOOLEAN ingore)</code> — returns the sub connection which matches name.<br>returns or nil subConn:Fire() — “returns” if non-nil is a table containing return values from the triggered connections.<br><code>self = conn:tofile(STRING path)</code> — Saves the object to a file at location path</p><p>The connect feature has some syntax sugar to it as seen below<br><code>link = conn(FUNCTION func, [STRING name nil], [NUMBER #conns+1])</code></p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>local multi = require(&quot;multi&quot;)
-- Let’s create the events
yawn={}
OnCustomSafeEvent=multi:newConnection(true) -- lets pcall the calls in case something goes wrong default
OnCustomEvent=multi:newConnection(false) -- let’s not pcall the calls and let errors happen.
OnCustomEvent:Bind(yawn) -- create the connection lookup data in yawn

-- Let’s connect to them, a recent update adds a nice syntax to connect to these
cd1=OnCustomSafeEvent:Connect(function(arg1,arg2,...)
  print(&quot;CSE1&quot;,arg1,arg2,...)
end,&quot;bob&quot;) -- let’s give this connection a name
cd2=OnCustomSafeEvent:Connect(function(arg1,arg2,...)
  print(&quot;CSE2&quot;,arg1,arg2,...)
end,&quot;joe&quot;) -- let’s give this connection a name
cd3=OnCustomSafeEvent:Connect(function(arg1,arg2,...)
  print(&quot;CSE3&quot;,arg1,arg2,...)
end) -- let’s not give this connection a name

-- Using syntax sugar
OnCustomEvent(function(arg1,arg2,...)
  print(arg1,arg2,...)
end)

-- Now within some loop/other object you trigger the connection like
OnCustomEvent:Fire(1,2,&quot;Hello!!!&quot;) -- fire all connections

-- You may have noticed that some events have names! See the following example!
OnCustomSafeEvent:getConnection(&quot;bob&quot;):Fire(1,100,&quot;Bye!&quot;) -- fire only bob!
OnCustomSafeEvent:getConnection(&quot;joe&quot;):Fire(1,100,&quot;Hello!&quot;) -- fire only joe!!
OnCustomSafeEvent:Fire(1,100,&quot;Hi Ya Folks!!!&quot;) -- fire them all!!!

-- Connections have more to them than that though!
-- As seen above cd1-cd3 these are hooks to the connection object. This allows you to remove a connection
-- For Example:
cd1:Remove() -- remove this connection from the master connection object
print(&quot;------&quot;)
OnCustomSafeEvent:Fire(1,100,&quot;Hi Ya Folks!!!&quot;) -- fire them all again!!!
-- To remove all connections use:
OnCustomSafeEvent:Remove()
print(&quot;------&quot;)
OnCustomSafeEvent:Fire(1,100,&quot;Hi Ya Folks!!!&quot;) -- fire them all again!!!
</code></pre>"><span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-comment">-- Let’s create the events</span>
yawn={}
OnCustomSafeEvent=multi:newConnection(<span class="hljs-keyword">true</span>) <span class="hljs-comment">-- lets pcall the calls in case something goes wrong default</span>
OnCustomEvent=multi:newConnection(<span class="hljs-keyword">false</span>) <span class="hljs-comment">-- let’s not pcall the calls and let errors happen.</span>
OnCustomEvent:Bind(yawn) <span class="hljs-comment">-- create the connection lookup data in yawn</span>

<span class="hljs-comment">-- Let’s connect to them, a recent update adds a nice syntax to connect to these</span>
cd1=OnCustomSafeEvent:Connect(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1,arg2,...)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"CSE1"</span>,arg1,arg2,...)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"bob"</span>) <span class="hljs-comment">-- let’s give this connection a name</span>
cd2=OnCustomSafeEvent:Connect(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1,arg2,...)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"CSE2"</span>,arg1,arg2,...)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"joe"</span>) <span class="hljs-comment">-- let’s give this connection a name</span>
cd3=OnCustomSafeEvent:Connect(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1,arg2,...)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"CSE3"</span>,arg1,arg2,...)
<span class="hljs-keyword">end</span>) <span class="hljs-comment">-- let’s not give this connection a name</span>

<span class="hljs-comment">-- Using syntax sugar</span>
OnCustomEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1,arg2,...)</span></span>
  <span class="hljs-built_in">print</span>(arg1,arg2,...)
<span class="hljs-keyword">end</span>)

<span class="hljs-comment">-- Now within some loop/other object you trigger the connection like</span>
OnCustomEvent:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"Hello!!!"</span>) <span class="hljs-comment">-- fire all connections</span>

<span class="hljs-comment">-- You may have noticed that some events have names! See the following example!</span>
OnCustomSafeEvent:getConnection(<span class="hljs-string">"bob"</span>):Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Bye!"</span>) <span class="hljs-comment">-- fire only bob!</span>
OnCustomSafeEvent:getConnection(<span class="hljs-string">"joe"</span>):Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Hello!"</span>) <span class="hljs-comment">-- fire only joe!!</span>
OnCustomSafeEvent:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Hi Ya Folks!!!"</span>) <span class="hljs-comment">-- fire them all!!!</span>

<span class="hljs-comment">-- Connections have more to them than that though!</span>
<span class="hljs-comment">-- As seen above cd1-cd3 these are hooks to the connection object. This allows you to remove a connection</span>
<span class="hljs-comment">-- For Example:</span>
cd1:Remove() <span class="hljs-comment">-- remove this connection from the master connection object</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"------"</span>)
OnCustomSafeEvent:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Hi Ya Folks!!!"</span>) <span class="hljs-comment">-- fire them all again!!!</span>
<span class="hljs-comment">-- To remove all connections use:</span>
OnCustomSafeEvent:Remove()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"------"</span>)
OnCustomSafeEvent:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Hi Ya Folks!!!"</span>) <span class="hljs-comment">-- fire them all again!!!</span>
</code></pre><h2 id="non-actor:-jobs"><a name="non-actor:-jobs" href="#non-actor:-jobs"></a>Non-Actor: Jobs</h2><p><code>nil = multi:newJob(FUNCTION func, STRING name)</code> — Adds a job to a queue of jobs that get executed after some time. func is the job that is being ran, name is the name of the job.<br><code>nil = multi:setJobSpeed(NUMBER n)</code> — seconds between when each job should be done.<br><code>bool, number = multi:hasJobs()</code> — returns true if there are jobs to be processed. And the number of jobs to be processed<br><code>num = multi:getJobs()</code> — returns the number of jobs left to be processed.<br><code>number = multi:removeJob(STRING name)</code> — removes all jobs of name, name. Returns the number of jobs removed</p><p><strong>Note:</strong> Jobs may be turned into actual objects in the future.</p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>local multi = require(&quot;multi&quot;)
print(multi:hasJobs())
multi:setJobSpeed(1) -- set job speed to 1 second
multi:newJob(function()
    print(&quot;A job!&quot;)
end,&quot;test&quot;)

multi:newJob(function()
    print(&quot;Another job!&quot;)
    multi:removeJob(&quot;test&quot;) -- removes all jobs with name &quot;test&quot;
end,&quot;test&quot;)

multi:newJob(function()
    print(&quot;Almost done!&quot;)
end,&quot;test&quot;)

multi:newJob(function()
    print(&quot;Final job!&quot;)
end,&quot;test&quot;)
print(multi:hasJobs())
print(&quot;There are &quot;..multi:getJobs()..&quot; jobs in the queue!&quot;)
multi:mainloop()
</code></pre>"><span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-built_in">print</span>(multi:hasJobs())
multi:setJobSpeed(<span class="hljs-number">1</span>) <span class="hljs-comment">-- set job speed to 1 second</span>
multi:newJob(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"A job!"</span>)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"test"</span>)

multi:newJob(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Another job!"</span>)
    multi:removeJob(<span class="hljs-string">"test"</span>) <span class="hljs-comment">-- removes all jobs with name "test"</span>
<span class="hljs-keyword">end</span>,<span class="hljs-string">"test"</span>)

multi:newJob(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Almost done!"</span>)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"test"</span>)

multi:newJob(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Final job!"</span>)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"test"</span>)
<span class="hljs-built_in">print</span>(multi:hasJobs())
<span class="hljs-built_in">print</span>(<span class="hljs-string">"There are "</span>..multi:getJobs()..<span class="hljs-string">" jobs in the queue!"</span>)
multi:mainloop()
</code></pre><h2 id="non-actor:-functions"><a name="non-actor:-functions" href="#non-actor:-functions"></a>Non-Actor: Functions</h2><p><code>func = multi:newFunction(FUNCTION func)</code><br>These objects used to have more of a <em>function</em> before corutine based threads came around, but the main purpose now is the ablity to have pausable function calls</p><p><code>... = func(...)</code> — This is how you call your function. The first argument passed is itself when your function is triggered. See example.<br><code>self = func:Pause()</code><br><code>self = func:Resume()</code></p><p>Note: A paused function will return: nil, true</p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>local multi = require(&quot;multi&quot;)
printOnce = multi:newFunction(function(self,msg)
    print(msg)
    self:Pause()
    return &quot;I won't work anymore&quot;
end)
a=printOnce(&quot;Hello World!&quot;)
b,c=printOnce(&quot;Hello World!&quot;)
print(a,b,c)
</code></pre>"><span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
printOnce = multi:newFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,msg)</span></span>
    <span class="hljs-built_in">print</span>(msg)
    self:Pause()
    <span class="hljs-keyword">return</span> <span class="hljs-string">"I won't work anymore"</span>
<span class="hljs-keyword">end</span>)
a=printOnce(<span class="hljs-string">"Hello World!"</span>)
b,c=printOnce(<span class="hljs-string">"Hello World!"</span>)
<span class="hljs-built_in">print</span>(a,b,c)
</code></pre><h2 id="non-actor:-triggers"><a name="non-actor:-triggers" href="#non-actor:-triggers"></a>Non-Actor: Triggers </h2><p><code>trigger = multi:newTrigger(FUNCTION: func(...))</code> — A trigger is the precursor of connection objects. The main difference is that only one function can be binded to the trigger.<br><code>self = trigger:Fire(...)</code> — Fires the function that was connected to the trigger and passes the arguments supplied in Fire to the function given.</p><h2 id="universal-actor-functions"><a name="universal-actor-functions" href="#universal-actor-functions"></a>Universal Actor functions</h2><p>All of these functions are found on actors<br><code>self = multiObj:Pause()</code> — Pauses the actor from running<br><code>self = multiObj:Resume()</code> — Resumes the actor that was paused<br><code>nil = multiObj:Destroy()</code> — Removes the object from the mainloop<br><code>bool = multiObj:isPaused()</code> — Returns true if the object is paused, false otherwise<br><code>string = multiObj:getType()</code> — Returns the type of the object<br><code>self = multiObj:SetTime(n)</code> — Sets a timer, and creates a special “timemaster” actor, which will timeout unless ResolveTimer is called<br><code>self = multiObj:ResolveTimer(...)</code> — Stops the timer that was put onto the multiObj from timing out<br><code>self = multiObj:OnTimedOut(func)</code> — If ResolveTimer was not called in time this event will be triggered. The function connected to it get a refrence of the original object that the timer was created on as the first argument.<br><code>self = multiObj:OnTimerResolved(func)</code> — This event is triggered when the timer gets resolved. Same argument as above is passed, but the variable arguments that are accepted in resolvetimer are also passed as well.<br><code>self = multiObj:Reset(n)</code> — In the cases where it isn’t obvious what it does, it acts as Resume()<br><code>self = multiObj:SetName(STRING name)</code></p><h2 id="actor:-events"><a name="actor:-events" href="#actor:-events"></a>Actor: Events</h2><p><code>event = multi:newEvent(FUNCTION task)</code><br>The object that started it all. These are simply actors that wait for a condition to take place, then auto triggers an event. The event when triggered once isn’t triggered again unless you Reset() it.</p><p><code>self = SetTask(FUNCTION func)</code> — This function is not needed if you supplied task at construction time<br><code>self = OnEvent(FUNCTION func)</code> — Connects to the OnEvent event passes argument self to the connectee</p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>local multi = require(&quot;multi&quot;)
count=0
-- A loop object is used to demostrate how one could use an event object.
loop=multi:newLoop(function(self,dt)
    count=count+1
end)
event=multi:newEvent(function() return count==100 end) -- set the event
event:OnEvent(function(self) -- connect to the event object
    loop:Destroy() -- destroys the loop from running!
    print(&quot;Stopped that loop!&quot;,count)
end) -- events like alarms need to be reset the Reset() command works here as well
multi:mainloop()
</code></pre>"><span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
count=<span class="hljs-number">0</span>
<span class="hljs-comment">-- A loop object is used to demostrate how one could use an event object.</span>
loop=multi:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    count=count+<span class="hljs-number">1</span>
<span class="hljs-keyword">end</span>)
event=multi:newEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> count==<span class="hljs-number">100</span> <span class="hljs-keyword">end</span>) <span class="hljs-comment">-- set the event</span>
event:OnEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span> <span class="hljs-comment">-- connect to the event object</span>
    loop:Destroy() <span class="hljs-comment">-- destroys the loop from running!</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Stopped that loop!"</span>,count)
<span class="hljs-keyword">end</span>) <span class="hljs-comment">-- events like alarms need to be reset the Reset() command works here as well</span>
multi:mainloop()
</code></pre><h2 id="actor:-updates"><a name="actor:-updates" href="#actor:-updates"></a>Actor: Updates</h2><p><code>updater =  multi:newUpdater([NUMBER skip 1])</code> — set the amount of steps that are skipped<br>Updaters are a mix between both loops and steps. They were a way to add basic priority management to loops (until a better way was added). Now they aren’t as useful, but if you do not want the performance hit of turning on priority then they are useful to auro skip some loops. Note: The performance hit due to priority management is not as bas as it used to be. </p><p><code>self = updater:SetSkip(NUMBER n)</code> — sets the amount of steps that are skipped<br><code>self = OnUpdate(FUNCTION func)</code> — connects to the main trigger of the updater which is called every nth step</p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>local multi = require(&quot;multi&quot;)
updater=multi:newUpdater(5000) -- simple, think of a loop with the skip feature of a step
updater:OnUpdate(function(self)
    print(&quot;updating...&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
updater=multi:newUpdater(<span class="hljs-number">5000</span>) <span class="hljs-comment">-- simple, think of a loop with the skip feature of a step</span>
updater:OnUpdate(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"updating..."</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="actor:-alarms"><a name="actor:-alarms" href="#actor:-alarms"></a>Actor: Alarms</h2><p><code>alarm = multi:newAlarm([NUMBER 0])</code> — creates an alarm which waits n seconds<br>Alarms ring after a certain amount of time, but you need to reset the alarm every time it rings! Use a TLoop if you do not want to have to reset.</p><p><code>self = alarm:Reset([NUMBER sec current_time_set])</code> — Allows one to reset an alarm, optional argument to change the time until the next ring.<br><code>self = alarm:OnRing(FUNCTION func</code> — Allows one to connect to the alarm event which is triggerd after a certain amount of time has passed.</p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>local multi = require(&quot;multi&quot;)
alarm=multi:newAlarm(3) -- in seconds can go to .001 uses the built in os.clock()
alarm:OnRing(function(a)
    print(&quot;3 Seconds have passed!&quot;)
    a:Reset(n) -- if n were nil it will reset back to 3, or it would reset to n seconds
end)
multi:mainloop()
</code></pre>"><span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
alarm=multi:newAlarm(<span class="hljs-number">3</span>) <span class="hljs-comment">-- in seconds can go to .001 uses the built in os.clock()</span>
alarm:OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"3 Seconds have passed!"</span>)
    a:Reset(n) <span class="hljs-comment">-- if n were nil it will reset back to 3, or it would reset to n seconds</span>
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="actor:-loops"><a name="actor:-loops" href="#actor:-loops"></a>Actor: Loops</h2><p><code>loop = multi:newLoop(FUNCTION func)</code> — func the main connection that you can connect to. Is optional, but you can also use OnLoop(func) to connect as well.<br>Loops are events that happen over and over until paused. They act like a while loop.</p><p><code>self = OnLoop(FUNCTION func)</code>  — func the main connection that you can connect to. Alllows multiple connections to one loop if need be.</p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
local a = 0
loop = multi:newLoop(function()
    a = a + 1
    if a == 1000 then
        print(&quot;a = 1000&quot;)
        loop:Pause()
    end
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-keyword">local</span> a = <span class="hljs-number">0</span>
loop = multi:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    a = a + <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> a == <span class="hljs-number">1000</span> <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"a = 1000"</span>)
        loop:Pause()
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="actor:-tloops"><a name="actor:-tloops" href="#actor:-tloops"></a>Actor: TLoops</h2><p><code>tloop = multi:newTLoop(FUNCTION func ,NUMBER: [set 1])</code> — TLoops are pretty much the same as loops. The only difference is that they take set which is how long it waits, in seconds, before triggering function func.</p><p><code>self = OnLoop(FUNCTION func)</code>  — func the main connection that you can connect to. Alllows multiple connections to one TLoop if need be.</p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
local a = 0
loop = multi:newTLoop(function()
    a = a + 1
    if a == 10 then
        print(&quot;a = 10&quot;)
        loop:Pause()
    end
end,1)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-keyword">local</span> a = <span class="hljs-number">0</span>
loop = multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    a = a + <span class="hljs-number">1</span>
    <span class="hljs-keyword">if</span> a == <span class="hljs-number">10</span> <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"a = 10"</span>)
        loop:Pause()
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
multi:mainloop()
</code></pre><h2 id="actor:-steps"><a name="actor:-steps" href="#actor:-steps"></a>Actor: Steps</h2><p><code>step = multi:newStep(NUMBER start,*NUMBER reset, [NUMBER count 1], [NUMBER skip 0])</code> — Steps were originally introduced to bs used as for loops that can run parallel with other code. When using steps think of it like this: <code>for i=start,reset,count do</code> When the skip argument is given, each time the step object is given cpu cycles it will be skipped by n cycles. So if skip is 1 every other cpu cycle will be alloted to the step object.</p><p><code>self = step:OnStart(FUNCTION func(self))</code> — This connects a function to an event that is triggered everytime a step starts.<br><code>self = step:OnStep(FUNCTION func(self,i))</code> — This connects a function to an event that is triggered every step or cycle that is alloted to the step object<br><code>self = step:OnEnd(FUNCTION func(self))</code> — This connects a function to an event that is triggered when a step reaches its goal<br><code>self = step:Update(NUMBER start,*NUMBER reset, [NUMBER count 1], [NUMBER skip 0])</code> — Update can be used to change the goals of the step. You should call step:Reset() after using Update to restart the step.</p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
multi:newStep(1,10,1,0):OnStep(function(step,pos)
    print(step,pos)
end):OnEnd(fucntion(step)
    step:Destroy()
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
multi:newStep(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>):OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(step,pos)</span></span>
    <span class="hljs-built_in">print</span>(step,pos)
<span class="hljs-keyword">end</span>):OnEnd(fucntion(step)
    step:Destroy()
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="actor:-tsteps"><a name="actor:-tsteps" href="#actor:-tsteps"></a>Actor: TSteps</h2><p><code>tstep = multi:newStep(NUMBER start, NUMBER reset, [NUMBER count 1], [NUMBER set 1])</code> — TSteps work just like steps, the only difference is that instead of skip, we have set which is how long in seconds it should wait before triggering the OnStep() event.</p><p><code>self = tstep:OnStart(FUNCTION func(self))</code> — This connects a function to an event that is triggered everytime a step starts.<br><code>self = tstep:OnStep(FUNCTION func(self,i))</code> — This connects a function to an event that is triggered every step or cycle that is alloted to the step object<br><code>self = tstep:OnEnd(FUNCTION func(self))</code> — This connects a function to an event that is triggered when a step reaches its goal<br><code>self = tstep:Update(NUMBER start,*NUMBER reset, [NUMBER count 1], [NUMBER set 1])</code> — Update can be used to change the goals of the step. You should call step:Reset() after using Update to restart the step.<br><code>self = tstep:Reset([NUMBER n set])</code> — Allows you to reset a tstep that has ended, but also can change the time between each trigger.</p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
multi:newTStep(1,10,1,1):OnStep(function(step,pos)
    print(step,pos)
end):OnEnd(fucntion(step)
    step:Destroy()
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
multi:newTStep(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>):OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(step,pos)</span></span>
    <span class="hljs-built_in">print</span>(step,pos)
<span class="hljs-keyword">end</span>):OnEnd(fucntion(step)
    step:Destroy()
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="actor:-time-stampers"><a name="actor:-time-stampers" href="#actor:-time-stampers"></a>Actor: Time Stampers</h2><p><code>stamper = multi:newTimeStamper()</code> — This allows for long time spans as well as short time spans.<br><code>stamper = stamper:OhSecond(NUMBER second, FUNCTION func)</code> — This takes a value between 0 and 59. This event is called once every second! Not once every second! If you want seconds then use alarms<strong>*</strong>! 0 is the start of every minute and 59 is the end of every minute.<br><code>stamper = stamper:OhMinute(NUMBER minute, FUNCTION func)</code> — This takes a value between 0 and 59. This event is called once every hour<strong>*</strong>! Same concept as OnSecond()<br><code>stamper = stamper:OhHour(NUMBER hour, FUNCTION func)</code> — This takes a value between 0 and 23. This event is called once every day<strong>*</strong>! 0 is midnight and 23 is 11pm if you use 12 hour based time.<br><code>stamper = stamper:OnDay(STRING/NUMBER day, FUNCTION func)</code> — So the days work like this ‘Sun’, ‘Mon’, ‘Tue’, ‘Wed’, ‘Thu’, ‘Fri’, ‘Sat’. When in string form this is called every week. When in number form this is called every month<strong>*</strong>!<br>There is a gotcha though with this. Months can have 28,29,30, and 31 days to it, which means that something needs to be done when dealing with the last few days of a month. I am aware of this issue and am looking into a solution that is simple and readable. I thought about allowing negitive numbers to allow one to eaisly use the last day of a month. -1 is the last day of the month where -2 is the second to last day of the month. You can go as low as -28 if you want, but this provides a nice way to do something near the end of the month that is lua like.<br><code>stamper = stamper:OnMonth(NUMBER month,FUNCTION func)</code> — This takes a value between 1 and 12. 1 being January and 12 being December. Called once per year<strong>*</strong>.<br><code>stamper = stamper:OnYear(NUMBER year,FUNCTION func)</code> — This takes a number yy. for example 18 do not use yyyy format! Odds are you will not see this method triggered more than once, unless science figures out the whole life extension thing. But every century this event is triggered<strong>*</strong>! I am going to be honest though, the odds of a system never reseting for 100 years is very unlikely, so if I used 18 (every 18th year in each century every time i load my program this event will be triggered). Does it actually work? I have no idea tbh it should, but can i prove that without actually testing it? Yes by using fake data thats how.<br><code>stamper = stamper:OnTime(NUMBER hour,NUMBER minute,NUMBER second,FUNCTION func)</code> — This takes in a time to trigger, hour, minute, second. This triggeres once a day at a certain time! Sort of like setting an alarm! You can combine events to get other effects like this!<br><code>stamper = stamper:OnTime(STRING time,FUNCTION func)</code> — This takes a string time that should be formatted like this: “hh:mm:ss” hours minutes and seconds must be given as parameters! Otherwise functions as above!</p><p><strong>*</strong>If your program crashes or is rebooted than the data in RAM letting the code know that the function was already called will be reset! This means that if an event set to be triggered on Monday then you reboot the code it will retrigger that event on the same day if the code restarts. In a future update I am planning of writing to the disk for OnHour/Day/Week/Year events. This will be an option that can be set on the object.</p><p>Examples:<br><strong>OnSecond</strong></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
ts = multi:newTimeStamper()
local a = 0
ts:OnSecond(0,function()
    a=a+1
    print(&quot;New Minute: &quot;..a..&quot; &amp;lt;&quot;..os.date(&quot;%M&quot;)..&quot;&amp;gt;&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
ts = multi:newTimeStamper()
<span class="hljs-keyword">local</span> a = <span class="hljs-number">0</span>
ts:OnSecond(<span class="hljs-number">0</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    a=a+<span class="hljs-number">1</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"New Minute: "</span>..a..<span class="hljs-string">" &lt;"</span>..<span class="hljs-built_in">os</span>.date(<span class="hljs-string">"%M"</span>)..<span class="hljs-string">"&gt;"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><p><strong>OnMinute</strong></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
ts = multi:newTimeStamper()
local a = 0
ts:OnSecond(0,function()
    a=a+1
    print(&quot;New Hour: &quot;..a..&quot; &amp;lt;&quot;..os.date(&quot;%I&quot;)..&quot;&amp;gt;&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
ts = multi:newTimeStamper()
<span class="hljs-keyword">local</span> a = <span class="hljs-number">0</span>
ts:OnSecond(<span class="hljs-number">0</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    a=a+<span class="hljs-number">1</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"New Hour: "</span>..a..<span class="hljs-string">" &lt;"</span>..<span class="hljs-built_in">os</span>.date(<span class="hljs-string">"%I"</span>)..<span class="hljs-string">"&gt;"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><p><strong>OnHour</strong></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
ts = multi:newTimeStamper()
ts:OnHour(0,function()
    print(&quot;New Day&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
ts = multi:newTimeStamper()
ts:OnHour(<span class="hljs-number">0</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"New Day"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><p><strong>OnDay</strong></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
ts = multi:newTimeStamper()
ts:OnDay(&quot;Thu&quot;,function()
    print(&quot;It's thursday!&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
ts = multi:newTimeStamper()
ts:OnDay(<span class="hljs-string">"Thu"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"It's thursday!"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
ts = multi:newTimeStamper()
ts:OnDay(2,function()
    print(&quot;Second day of the month!&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
ts = multi:newTimeStamper()
ts:OnDay(<span class="hljs-number">2</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Second day of the month!"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
ts = multi:newTimeStamper()
ts:OnDay(-1,function()
    print(&quot;Last day of the month!&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
ts = multi:newTimeStamper()
ts:OnDay(-<span class="hljs-number">1</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Last day of the month!"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><p><strong>OnYear</strong></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
ts = multi:newTimeStamper()
ts:OnYear(19,function() -- They gonna wonder if they run this in 2018 why it no work :P
    print(&quot;We did it!&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
ts = multi:newTimeStamper()
ts:OnYear(<span class="hljs-number">19</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- They gonna wonder if they run this in 2018 why it no work :P</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"We did it!"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><p><strong>OnTime</strong></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
ts = multi:newTimeStamper()
ts:OnTime(12,1,0,function()
    print(&quot;Whooooo&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
ts = multi:newTimeStamper()
ts:OnTime(<span class="hljs-number">12</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Whooooo"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
ts = multi:newTimeStamper()
ts:OnTime(&quot;12:04:00&quot;,function()
    print(&quot;Whooooo&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
ts = multi:newTimeStamper()
ts:OnTime(<span class="hljs-string">"12:04:00"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Whooooo"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="actor:-watchers"><a name="actor:-watchers" href="#actor:-watchers"></a>Actor: Watchers </h2><p><strong>Deprecated: </strong> This object was removed due to its uselessness. Metatables will work much better for what is being done. Perhaps in the future i will remake this method to use metamethods instead of basic watching every step. This will most likely be removed in the next version of the library or changed to use metatables and metamethods.<br><code>watcher = multi:newWatcher(STRING name)</code> — Watches a variable on the global namespace<br><code>watcher = multi:newWatcher(TABLE namespace, STRING name)</code> — Watches a variable inside of a table<br><code>watcher = watcher::OnValueChanged(Function func(self, old_value, current_value))</code></p><p>Example</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
test = {a=0}
watcher = multi:newWatcher(test,&quot;a&quot;)
watcher:OnValueChanged(function(self, old_value, current_value)
    print(old_value,current_value)
end)
multi:newTLoop(function()
    test.a=test.a + 1
end,.5)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
test = {a=<span class="hljs-number">0</span>}
watcher = multi:newWatcher(test,<span class="hljs-string">"a"</span>)
watcher:OnValueChanged(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self, old_value, current_value)</span></span>
    <span class="hljs-built_in">print</span>(old_value,current_value)
<span class="hljs-keyword">end</span>)
multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    test.a=test.a + <span class="hljs-number">1</span>
<span class="hljs-keyword">end</span>,.<span class="hljs-number">5</span>)
multi:mainloop()
</code></pre><h2 id="actor:-custom-object"><a name="actor:-custom-object" href="#actor:-custom-object"></a>Actor: Custom Object</h2><p><code>cobj = multi:newCustomObject(TABLE objRef, BOOLEAN isActor [false])</code> — Allows you to create your own multiobject that runs each allotted step. This allows you to create your own object that works with all the features that each built in multi object does. If isActor is set to true you must have an <code>Act</code> method in your table. See example below. If an object is not an actor than the <code>Act</code> method will not be automatically called for you.</p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
local work = false
ticktock = multi:newCustomObject({
    timer = multi:newTimer(),
    Act = function(self)
        if self.timer:Get()&amp;gt;=1 then
            work = not work
            if work then
                self.OnTick:Fire()
            else
                self.OnTock:Fire()
            end
            self.timer:Reset()
        end
    end,
    OnTick = multi:newConnection(),
    OnTock = multi:newConnection(),
},true)
ticktock.OnTick(function()
    print(&quot;Tick&quot;)
end)
ticktock.OnTock(function()
    print(&quot;Tock&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-keyword">local</span> work = <span class="hljs-keyword">false</span>
ticktock = multi:newCustomObject({
    timer = multi:newTimer(),
    Act = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
        <span class="hljs-keyword">if</span> self.timer:Get()&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">then</span>
            work = <span class="hljs-keyword">not</span> work
            <span class="hljs-keyword">if</span> work <span class="hljs-keyword">then</span>
                self.OnTick:Fire()
            <span class="hljs-keyword">else</span>
                self.OnTock:Fire()
            <span class="hljs-keyword">end</span>
            self.timer:Reset()
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>,
    OnTick = multi:newConnection(),
    OnTock = multi:newConnection(),
},<span class="hljs-keyword">true</span>)
ticktock.OnTick(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Tick"</span>)
<span class="hljs-keyword">end</span>)
ticktock.OnTock(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Tock"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="coroutine-based-threading-(cbt)"><a name="coroutine-based-threading-(cbt)" href="#coroutine-based-threading-(cbt)"></a>Coroutine based Threading (CBT)</h2><p>This was made due to the limitations of multiObj:hold(), which no longer exists. When this library was in its infancy and before I knew about coroutines, I actually tried to emulate what coroutines did in pure lua.<br>The threaded bariants of the non threaded objects do exist, but there isn’t too much of a need to use them.</p><p>The main benefits of using the coroutine based threads is the thread.* namespace which gives you the ability to easily run code side by side.</p><p>A quick note on how threads are managed in the library. The library contains a scheduler which keeps track of coroutines and manages them. Coroutines take some time then give off processing to another coroutine. Which means there are some methods that you need to use in order to hand off cpu time to other coroutines or the main thread. You must hand off cpu time when inside of a non ending loop or your code will hang. Threads also have a slight delay before starting, about 3 seconds.</p><h2 id="threads.*"><a name="threads.*" href="#threads.*"></a>threads.*</h2><p><code>thread.sleep(NUMBER n)</code> — Holds execution of the thread until a certain amount of time has passed<br><code>thread.hold(FUNCTION func)</code> — Hold execttion until the function returns true<br><code>thread.skip(NUMBER n)</code> — How many cycles should be skipped until I execute again<br><code>thread.kill()</code> — Kills the thread<br><code>thread.yeild()</code> — Is the same as using thread.skip(0) or thread.sleep(0), hands off control until the next cycle<br><code>thread.isThread()</code> — Returns true if the current running code is inside of a coroutine based thread<br><code>thread.getCores()</code> — Returns the number of cores that the current system has. (used for system threads)<br><code>thread.set(STRING name, VARIABLE val)</code> — A global interface where threads can talk with eachother. sets a variable with name and its value<br><code>thread.get(STRING name)</code> — Gets the data stored in name<br><code>thread.waitFor(STRING name)</code> — Holds executon of a thread until variable name exists<br><code>thread.testFor(STRING name,VARIABLE val,STRING sym)</code> — holds execution untile variable name exists and is compared to val<br>sym can be equal to: “=”, “==”, “&lt;”, “&gt;”, “&lt;=”, or “&gt;=” the way comparisan works is: “<code>return val sym valTested</code>“</p><h2 id="cbt:-thread"><a name="cbt:-thread" href="#cbt:-thread"></a>CBT: Thread</h2><p><code>multi:newThread(STRING name,FUNCTION func)</code> — Creates a new thread with name and function.<br>Note: newThread() returns nothing. Threads are opperated hands off everything that happens, does so inside of its functions.</p><p>Threads simplify many things that you would use non CBT objects for. I almost solely use CBT for my current programming. I will slso show the above custom object using threads instead. Yes its cool and can be done.</p><p>Examples:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)
multi:newThread(&quot;Example of basic usage&quot;,function()
    while true do
        thread.sleep(1)
        print(&quot;We just made an alarm!&quot;)
    end
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
multi:newThread(<span class="hljs-string">"Example of basic usage"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">do</span>
        thread.sleep(<span class="hljs-number">1</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"We just made an alarm!"</span>)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)

function multi:newTickTock()
    local work = false
    local _alive = true
    local OnTick = multi:newConnection()
    local OnTock = multi:newConnection()
    local c =multi:newCustomObject{
        OnTick = OnTick,
        OnTock = OnTock,
        Destroy = function()
            _alive = false -- Threads at least how they work here now need a bit of data management for cleaning up objects. When a thread either finishes its execution of thread.kill() is called everything is removed from the scheduler letting lua know that it can garbage collect
        end
    }
    multi:newThread(&quot;TickTocker&quot;,function()
        while _alive do
            thread.sleep(1)
            work = not work
            if work then
                OnTick:Fire()
            else
                OnTock:Fire()
            end
        end
        thread.kill() -- When a thread gets to the end of it's ececution it will automatically be ended, but having this method is good to show what is going on with your code.
    end)
    return c
end
ticktock = multi:newTickTock()
ticktock.OnTick(function()
    print(&quot;Tick&quot;)
    -- The thread.* namespace works in all events that
end)
ticktock.OnTock(function()
    print(&quot;Tock&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)

<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multi:newTickTock</span><span class="hljs-params">()</span></span>
    <span class="hljs-keyword">local</span> work = <span class="hljs-keyword">false</span>
    <span class="hljs-keyword">local</span> _alive = <span class="hljs-keyword">true</span>
    <span class="hljs-keyword">local</span> OnTick = multi:newConnection()
    <span class="hljs-keyword">local</span> OnTock = multi:newConnection()
    <span class="hljs-keyword">local</span> c =multi:newCustomObject{
        OnTick = OnTick,
        OnTock = OnTock,
        Destroy = <span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
            _alive = <span class="hljs-keyword">false</span> <span class="hljs-comment">-- Threads at least how they work here now need a bit of data management for cleaning up objects. When a thread either finishes its execution of thread.kill() is called everything is removed from the scheduler letting lua know that it can garbage collect</span>
        <span class="hljs-keyword">end</span>
    }
    multi:newThread(<span class="hljs-string">"TickTocker"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        <span class="hljs-keyword">while</span> _alive <span class="hljs-keyword">do</span>
            thread.sleep(<span class="hljs-number">1</span>)
            work = <span class="hljs-keyword">not</span> work
            <span class="hljs-keyword">if</span> work <span class="hljs-keyword">then</span>
                OnTick:Fire()
            <span class="hljs-keyword">else</span>
                OnTock:Fire()
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
        thread.kill() <span class="hljs-comment">-- When a thread gets to the end of it's ececution it will automatically be ended, but having this method is good to show what is going on with your code.</span>
    <span class="hljs-keyword">end</span>)
    <span class="hljs-keyword">return</span> c
<span class="hljs-keyword">end</span>
ticktock = multi:newTickTock()
ticktock.OnTick(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Tick"</span>)
    <span class="hljs-comment">-- The thread.* namespace works in all events that</span>
<span class="hljs-keyword">end</span>)
ticktock.OnTock(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Tock"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;?.lua;&quot;..package.path
local multi = require(&quot;multi&quot;)

multi:newThread(&quot;TickTocker&quot;,function()
    print(&quot;Waiting for variable a to exist...&quot;)
    ret,ret2 = thread.hold(function()
        return a~=nil, &quot;test!&quot;
    end)
    print(ret,ret2) -- The hold method returns the arguments when the first argument is true. This methods return feature is rather new and took more work then you think to get working. Since threads
end)
multi:newAlarm(3):OnRing(function() a = true end) -- allows a to exist

multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;?.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)

multi:newThread(<span class="hljs-string">"TickTocker"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Waiting for variable a to exist..."</span>)
    ret,ret2 = thread.hold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        <span class="hljs-keyword">return</span> a~=<span class="hljs-keyword">nil</span>, <span class="hljs-string">"test!"</span>
    <span class="hljs-keyword">end</span>)
    <span class="hljs-built_in">print</span>(ret,ret2) <span class="hljs-comment">-- The hold method returns the arguments when the first argument is true. This methods return feature is rather new and took more work then you think to get working. Since threads</span>
<span class="hljs-keyword">end</span>)
multi:newAlarm(<span class="hljs-number">3</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> a = <span class="hljs-keyword">true</span> <span class="hljs-keyword">end</span>) <span class="hljs-comment">-- allows a to exist</span>

multi:mainloop()
</code></pre><h2 id="cbt:-threaded-process"><a name="cbt:-threaded-process" href="#cbt:-threaded-process"></a>CBT: Threaded Process</h2><p><code>process = multi:newThreadedProcess(STRING name)</code> — Creates a process object that is able allows all processes created on it to use the thread.* namespace</p><p><code>nil = process:getController()</code> — Returns nothing there is no “controller” when using threaded processes<br><code>self = process:Start()</code> — Starts the processor<br><code>self = process:Pause()</code> — Pauses the processor<br><code>self = process:Resume()</code> — Resumes a paused processor<br><code>self = process:Kill()</code> — Kills/Destroys the process thread<br><code>self = process:Remove()</code> — Destroys/Kills the processor and all of the Actors running on it<br><code>self = process:Sleep(NUMBER n)</code> — Forces a process to sleep for n amount of time<br><code>self = process:Hold(FUNCTION/NUMBER n)</code> — Forces a process to either test a condition or sleep.</p><p>Everything eles works as if you were using the multi.<em> interface. You can create multi objects on the process and the objects are able to use the thread.</em> interface.</p><p>Note: When using Hold/Sleep/Skip on an object created inside of a threaded process, you actually hold the entire process! Which means all objects on that process will be stopping until the conditions are met!</p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>test = multi:newThreadedProcess(&quot;test&quot;)
test:newLoop(function()
    print(&quot;HI!&quot;)
end)
test:newLoop(function()
    print(&quot;HI2!&quot;)
    thread.sleep(.5)
end)
multi:newAlarm(3):OnRing(function()
    test:Sleep(10)
end)
test:Start()
multi:mainloop()
</code></pre>">test = multi:newThreadedProcess(<span class="hljs-string">"test"</span>)
test:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"HI!"</span>)
<span class="hljs-keyword">end</span>)
test:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"HI2!"</span>)
    thread.sleep(.<span class="hljs-number">5</span>)
<span class="hljs-keyword">end</span>)
multi:newAlarm(<span class="hljs-number">3</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    test:Sleep(<span class="hljs-number">10</span>)
<span class="hljs-keyword">end</span>)
test:Start()
multi:mainloop()
</code></pre><h2 id="cbt:-hyper-threaded-process"><a name="cbt:-hyper-threaded-process" href="#cbt:-hyper-threaded-process"></a>CBT: Hyper Threaded Process</h2><p><code>process = multi:newHyperThreadedProcess(STRING name)</code> — Creates a process object that is able allows all processes created on it to use the thread.* namespace. Hold/Sleep/Skip can be used in each multi obj created without stopping each other object that is running, but allows for one to pause/halt a process and stop all objects running in that process.</p><p><code>nil = process:getController()</code> — Returns nothing there is no “controller” when using threaded processes<br><code>self = process:Start()</code> — Starts the processor<br><code>self = process:Pause()</code> — Pauses the processor<br><code>self = process:Resume()</code> — Resumes a paused processor<br><code>self = process:Kill()</code> — Kills/Destroys the process thread<br><code>self = process:Remove()</code> — Destroys/Kills the processor and all of the Actors running on it<br><code>self = process:Sleep(NUMBER n)</code> — Forces a process to sleep for n amount of time<br><code>self = process:Hold(FUNCTION/NUMBER n)</code> — Forces a process to either test a condition or sleep.</p><p>Example:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>test = multi:newHyperThreadedProcess(&quot;test&quot;)
test:newLoop(function()
    print(&quot;HI!&quot;)
end)
test:newLoop(function()
    print(&quot;HI2!&quot;)
    thread.sleep(.5)
end)
multi:newAlarm(3):OnRing(function()
    test:Sleep(10)
end)
test:Start()
multi:mainloop()
</code></pre>">test = multi:newHyperThreadedProcess(<span class="hljs-string">"test"</span>)
test:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"HI!"</span>)
<span class="hljs-keyword">end</span>)
test:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"HI2!"</span>)
    thread.sleep(.<span class="hljs-number">5</span>)
<span class="hljs-keyword">end</span>)
multi:newAlarm(<span class="hljs-number">3</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    test:Sleep(<span class="hljs-number">10</span>)
<span class="hljs-keyword">end</span>)
test:Start()
multi:mainloop()
</code></pre><p>Same example as above, but notice how this works opposed to the non hyper version</p><h2 id="system-threads-(st)---multi-integration-getting-started"><a name="system-threads-(st)---multi-integration-getting-started" href="#system-threads-(st)---multi-integration-getting-started"></a>System Threads (ST) - Multi-Integration Getting Started</h2><p>The system threads need to be required seperatly.</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>local GLOBAL, THREAD = require(&quot;multi.integration.lanesManager&quot;).init()# -- We will talk about the global and thread interface that is returned
GLOBAL, THREAD = require(&quot;multi.integration.loveManager&quot;).init()
GLOBAL, THREAD = require(&quot;luvitManager&quot;)-- There is a catch to this*
</code></pre>"><span class="hljs-keyword">local</span> GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()# <span class="hljs-comment">-- We will talk about the global and thread interface that is returned</span>
GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.loveManager"</span>).init()
GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"luvitManager"</span>)<span class="hljs-comment">-- There is a catch to this*</span>
</code></pre><p>Using this integration modifies some methods that the multi library has.<br><code>multi:canSystemThread()</code> — Returns true is system threading is possible<br><code>multi:getPlatform()</code> — Returns (for now) either “lanes”, “love2d” and “luvit”<br>This variable is created on the main thread only inside of the multi namespace: multi.isMainThread = true<br>This is used to know which thread is the main thread. When network threads are being discussed there is a gotcha that needs to be addressed.</p><p><code>*</code> GLOBAL and THREAD do not work currently when using the luvit integration<br><code>#</code>So you may have noticed that when using the lanes manager you need to make the global and thread local, this is due to how lanes copies local variables between states. Also love2d does not require this, actually things will break if this is done! Keep these non local since the way threading is handled at the lower level is much different anyway so GLOBAL and THREAD is automatically set up for use within a spawned thread!</p><h2 id="st---thread-namespace"><a name="st---thread-namespace" href="#st---thread-namespace"></a>ST - THREAD namespace</h2><p><code>THREAD.set(STRING name, VALUE val)</code> — Sets a value in GLOBAL<br><code>THREAD.get(STRING name)</code> — Gets a value in GLOBAL<br><code>THREAD.waitFor(STRING name)</code> — Waits for a value in GLOBAL to exist<br><code>THREAD.testFor(STRING name, VALUE val, STRING sym)</code> — <strong>NOT YET IMPLEMENTED</strong> but planned<br><code>THREAD.getCores()</code> — Returns the number of actual system threads/cores<br><code>THREAD.kill()</code> — Kills the thread<br><code>THREAD.getName()</code> — Returns the name of the working thread<br><code>THREAD.sleep(NUMBER n)</code> — Sleeps for an amount of time stopping the current thread<br><code>THREAD.hold(FUNCTION func)</code> — Holds the current thread until a condition is met<br><code>THREAD.getID()</code> — returns a unique ID for the current thread. This varaiable is visible to the main thread as well by accessing it through the returned thread object. OBJ.Id</p><h2 id="st---global-namespace"><a name="st---global-namespace" href="#st---global-namespace"></a>ST - GLOBAL namespace</h2><p>Treat global like a table.</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>GLOBAL[&quot;name&quot;] = &quot;Ryan&quot;
print(GLOBAL[&quot;name&quot;])
</code></pre>">GLOBAL[<span class="hljs-string">"name"</span>] = <span class="hljs-string">"Ryan"</span>
<span class="hljs-built_in">print</span>(GLOBAL[<span class="hljs-string">"name"</span>])
</code></pre><p>Removes the need to use THREAD.set() and THREAD.get()</p><h2 id="st---system-threads"><a name="st---system-threads" href="#st---system-threads"></a>ST - System Threads</h2><p><code>systemThread = multi:newSystemThread(STRING thread_name,FUNCTION spawned_function,ARGUMENTS ...)</code> — Spawns a thread with a certain name.<br><code>systemThread:kill()</code> — kills a thread; can only be called in the main thread!<br><code>systemThread.OnError(FUNCTION(systemthread,errMsg,errorMsgWithThreadName))</code></p><p>System Threads are the feature that allows a user to interact with systen threads. It differs from regular coroutine based thread in how it can interact with variables. When using system threads the GLOBAL table is the “only way”* to send data. Spawning a System thread is really simple once all the required libraries are in place. See example below:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>local multi = require(&quot;multi&quot;) -- keep this global when using lanes or implicitly define multi within the spawned thread
local GLOBAL, THREAD = require(&quot;multi.integration.lanesManager&quot;).init()
multi:newSystemThread(&quot;Example thread&quot;,function()
    local multi = require(&quot;multi&quot;) -- we are in a thread so lets not refer to that upvalue!
    print(&quot;We have spawned a thread!&quot;)
    -- we could do work but theres no need to we can save that for other examples
    print(&quot;Lets have a non ending loop!&quot;)
    while true do
        -- If this was not in a thread execution would halt for the entire process
    end
end,&quot;A message that we are passing&quot;) -- There are restrictions on what can be passed!

tloop = multi:newTLoop(function()
    print(&quot;I'm still kicking!&quot;)
end,1)
multi:mainloop()
</code></pre>"><span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>) <span class="hljs-comment">-- keep this global when using lanes or implicitly define multi within the spawned thread</span>
<span class="hljs-keyword">local</span> GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
multi:newSystemThread(<span class="hljs-string">"Example thread"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-keyword">local</span> multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>) <span class="hljs-comment">-- we are in a thread so lets not refer to that upvalue!</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"We have spawned a thread!"</span>)
    <span class="hljs-comment">-- we could do work but theres no need to we can save that for other examples</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Lets have a non ending loop!"</span>)
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">do</span>
        <span class="hljs-comment">-- If this was not in a thread execution would halt for the entire process</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>,<span class="hljs-string">"A message that we are passing"</span>) <span class="hljs-comment">-- There are restrictions on what can be passed!</span>

tloop = multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"I'm still kicking!"</span>)
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
multi:mainloop()
</code></pre><p>*This isn’t entirely true, as of right now the compatiablity with the lanes library and love2d engine have their own methods to share data, but if you would like to have your code work in both enviroments then using the GLOBAL table and the data structures provided by the multi library will ensure this happens. If you do not plan on having support for both platforms then feel free to use linda’s in lanes and channels in love2d.</p><p>Note: luvit currently has very basic support, it only allows the spawning of system threads, but no way to send data back and forth as of yet. I do not know if this is doable or not, but I will keep looking into it. If I can somehow emulate System Threaded Queues and the GLOBAL tabke then all other datastructures will work!</p><h2 id="st---system-threaded-objects"><a name="st---system-threaded-objects" href="#st---system-threaded-objects"></a>ST - System Threaded Objects</h2><p>Great we are able to spawn threads, but unless your working with a process that works on passed data and then uses a socket or writes to the disk I can’t do to much with out being able to pass data between threads. This section we will look at how we can share objects between threads. In order to keep the compatibility between both love2d and lanes I had to format the system threaded objects in a strange way, but they are consistant and should work on both enviroments.</p><p>When creating objects with a name they are automatically exposed to the GLOBAL table. Which means you can retrieve them from a spawned thread. For example we have a queue object, which will be discussed in more detail next.</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Exposing a queue
multi = require(&quot;multi&quot;)
local GLOBAL, THREAD = require(&quot;multi.integration.lanesManager&quot;).init() -- The standard setup above
queue = multi:newSystemThreadedQueue(&quot;myQueue&quot;):init() -- We create and initiate the queue for the main thread
queue:push(&quot;This is a test!&quot;) -- We push some data onto the queue that other threads can consume and do stuff with
multi:newSystemThread(&quot;Example thread&quot;,function() -- Create a system thread
    queue = THREAD.waitFor(&quot;myQueue&quot;):init() -- Get the queue. It is good pratice to use the waitFor command when getting objects. If it doesn't exist yet we wait for it, preventing future errors. It is possible for the data to not ve present when a thread is looking for it! Especally when using the love2d module, my fault needs some rewriting data passing on the GLOBAL is quite slow, but the queue internally uses channels so after it is exposed you should have good speeds!
    local data = queue:pop() -- Get the data
    print(data) -- print the data
end)
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- Exposing a queue</span>
multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-keyword">local</span> GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init() <span class="hljs-comment">-- The standard setup above</span>
queue = multi:newSystemThreadedQueue(<span class="hljs-string">"myQueue"</span>):init() <span class="hljs-comment">-- We create and initiate the queue for the main thread</span>
queue:push(<span class="hljs-string">"This is a test!"</span>) <span class="hljs-comment">-- We push some data onto the queue that other threads can consume and do stuff with</span>
multi:newSystemThread(<span class="hljs-string">"Example thread"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- Create a system thread</span>
    queue = THREAD.waitFor(<span class="hljs-string">"myQueue"</span>):init() <span class="hljs-comment">-- Get the queue. It is good pratice to use the waitFor command when getting objects. If it doesn't exist yet we wait for it, preventing future errors. It is possible for the data to not ve present when a thread is looking for it! Especally when using the love2d module, my fault needs some rewriting data passing on the GLOBAL is quite slow, but the queue internally uses channels so after it is exposed you should have good speeds!</span>
    <span class="hljs-keyword">local</span> data = queue:pop() <span class="hljs-comment">-- Get the data</span>
    <span class="hljs-built_in">print</span>(data) <span class="hljs-comment">-- print the data</span>
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="st---systemthreadedqueue"><a name="st---systemthreadedqueue" href="#st---systemthreadedqueue"></a>ST - SystemThreadedQueue</h2><p><code>queue(nonInit) = multi:newSystemThreadedQueue(STRING name)</code> — You must enter a name!<br><code>queue = queue:init()</code> — initiates the queue, without doing this it will not work<br><code>void = queue:push(DATA data)</code> — Pushes data into a queue that all threads that have been shared have access to<br><code>data = queue:pop()</code> — pops data from the queue removing it from all threads<br><code>data = queue:peek()</code> — looks at data that is on the queue, but dont remove it from the queue</p><p>This object the System Threaded Queue is the basis for all other data structures that a user has access to within the “shared” objects.</p><p>General tips when using a queue. You can always pop from a queue without worrying if another thread poped that same data, BUT if you are peeking at a queue there is the possibility that another thread popped the data while you are peeking and this could cause an issue, depends on what you are doing though. It’s important to keep this in mind when using queues.</p><p>Let’s get into some examples:</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>multi = require(&quot;multi&quot;)
thread_names = {&quot;Thread_A&quot;,&quot;Thread_B&quot;,&quot;Thread_C&quot;,&quot;Thread_D&quot;}
local GLOBAL, THREAD = require(&quot;multi.integration.lanesManager&quot;).init()
queue = multi:newSystemThreadedQueue(&quot;myQueue&quot;):init()
for _,n in pairs(thread_names) do
    multi:newSystemThread(n,function()
        queue = THREAD.waitFor(&quot;myQueue&quot;):init()
        local name = THREAD.getName()
        local data = queue:pop()
        while data do
            print(name..&quot; &quot;..data)
            data = queue:pop()
        end
    end)
end
for i=1,100 do
    queue:push(math.random(1,1000))
end
multi:newEvent(function() -- Felt like using the event object, I hardly use them for anything non internal
    return not queue:peek()
end):OnEvent(function()
    print(&quot;No more data within the queue!&quot;)
    os.exit()
end)
multi:mainloop()
</code></pre>">multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
thread_names = {<span class="hljs-string">"Thread_A"</span>,<span class="hljs-string">"Thread_B"</span>,<span class="hljs-string">"Thread_C"</span>,<span class="hljs-string">"Thread_D"</span>}
<span class="hljs-keyword">local</span> GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
queue = multi:newSystemThreadedQueue(<span class="hljs-string">"myQueue"</span>):init()
<span class="hljs-keyword">for</span> _,n <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(thread_names) <span class="hljs-keyword">do</span>
    multi:newSystemThread(n,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        queue = THREAD.waitFor(<span class="hljs-string">"myQueue"</span>):init()
        <span class="hljs-keyword">local</span> name = THREAD.getName()
        <span class="hljs-keyword">local</span> data = queue:pop()
        <span class="hljs-keyword">while</span> data <span class="hljs-keyword">do</span>
            <span class="hljs-built_in">print</span>(name..<span class="hljs-string">" "</span>..data)
            data = queue:pop()
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>
<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">100</span> <span class="hljs-keyword">do</span>
    queue:push(<span class="hljs-built_in">math</span>.random(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>))
<span class="hljs-keyword">end</span>
multi:newEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- Felt like using the event object, I hardly use them for anything non internal</span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> queue:peek()
<span class="hljs-keyword">end</span>):OnEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"No more data within the queue!"</span>)
    <span class="hljs-built_in">os</span>.exit()
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><p>You have probable noticed that the output from this is a total mess! Well I though so too, and created the system threaded console!</p><h2 id="st---systemthreadedconsole"><a name="st---systemthreadedconsole" href="#st---systemthreadedconsole"></a>ST - SystemThreadedConsole</h2><p><code>console(nonInit) = multi:newSystemThreadedConsole(STRING name)</code> — Creates a console object called name. The name is mandatory!<br><code>concole = console:inti()</code> — initiates the console object<br><code>console:print(...)</code> — prints to the console<br><code>console:write(msg)</code> — writes to the console, to be fair you wouldn’t want to use this one.</p><p>The console makes printing from threads much cleaner. We will use the same example from above with the console implemented and compare the outputs and how readable they now are!</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>multi = require(&quot;multi&quot;)
thread_names = {&quot;Thread_A&quot;,&quot;Thread_B&quot;,&quot;Thread_C&quot;,&quot;Thread_D&quot;}
local GLOBAL, THREAD = require(&quot;multi.integration.lanesManager&quot;).init()
multi:newSystemThreadedConsole(&quot;console&quot;):init()
queue = multi:newSystemThreadedQueue(&quot;myQueue&quot;):init()
for _,n in pairs(thread_names) do
    multi:newSystemThread(n,function()
        local queue = THREAD.waitFor(&quot;myQueue&quot;):init()
        local console = THREAD.waitFor(&quot;console&quot;):init()
        local name = THREAD.getName()
        local data = queue:pop()
        while data do
            --THREAD.sleep(.1) -- uncomment this to see them all work
            console:print(name..&quot; &quot;..data)
            data = queue:pop()
        end
    end)
end
for i=1,100 do
    queue:push(math.random(1,1000))
end
multi:newEvent(function()
    return not queue:peek()
end):OnEvent(function()
    multi:newAlarm(.1):OnRing(function() -- Well the mainthread has to read from an internal queue so we have to wait a sec
        print(&quot;No more data within the queue!&quot;)
        os.exit()
    end)
end)
multi:mainloop()
</code></pre>">multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
thread_names = {<span class="hljs-string">"Thread_A"</span>,<span class="hljs-string">"Thread_B"</span>,<span class="hljs-string">"Thread_C"</span>,<span class="hljs-string">"Thread_D"</span>}
<span class="hljs-keyword">local</span> GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
multi:newSystemThreadedConsole(<span class="hljs-string">"console"</span>):init()
queue = multi:newSystemThreadedQueue(<span class="hljs-string">"myQueue"</span>):init()
<span class="hljs-keyword">for</span> _,n <span class="hljs-keyword">in</span> <span class="hljs-built_in">pairs</span>(thread_names) <span class="hljs-keyword">do</span>
    multi:newSystemThread(n,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        <span class="hljs-keyword">local</span> queue = THREAD.waitFor(<span class="hljs-string">"myQueue"</span>):init()
        <span class="hljs-keyword">local</span> console = THREAD.waitFor(<span class="hljs-string">"console"</span>):init()
        <span class="hljs-keyword">local</span> name = THREAD.getName()
        <span class="hljs-keyword">local</span> data = queue:pop()
        <span class="hljs-keyword">while</span> data <span class="hljs-keyword">do</span>
            <span class="hljs-comment">--THREAD.sleep(.1) -- uncomment this to see them all work</span>
            console:<span class="hljs-built_in">print</span>(name..<span class="hljs-string">" "</span>..data)
            data = queue:pop()
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>
<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">100</span> <span class="hljs-keyword">do</span>
    queue:push(<span class="hljs-built_in">math</span>.random(<span class="hljs-number">1</span>,<span class="hljs-number">1000</span>))
<span class="hljs-keyword">end</span>
multi:newEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">not</span> queue:peek()
<span class="hljs-keyword">end</span>):OnEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    multi:newAlarm(.<span class="hljs-number">1</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- Well the mainthread has to read from an internal queue so we have to wait a sec</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"No more data within the queue!"</span>)
        <span class="hljs-built_in">os</span>.exit()
    <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><p>As you see the output here is so much cleaner, but we have a small gotcha, you probably noticed that I used an alarm to delay the exiting of the program for a bit. This is due to how the console object works, I send all the print data into a queue that the main thread then reads and prints out when it looks at the queue. This should not be an issue since you gain so much by having clean outputs!</p><p>Another thing to note, because system threads are put to work one thread at a time, really quick though, the first thread that is loaded is able to complete the tasks really fast, its just printing after all. If you want to see all the threads working uncomment the code with THREAD.sleep(.1)</p><h2 id="st---systemthreadedjobqueue"><a name="st---systemthreadedjobqueue" href="#st---systemthreadedjobqueue"></a>ST - SystemThreadedJobQueue</h2><h2 id="st---systemthreadedconnection---wip*"><a name="st---systemthreadedconnection---wip*" href="#st---systemthreadedconnection---wip*"></a>ST - SystemThreadedConnection - WIP*</h2><p><code>connection(nonInit) = multi:newSystemThreadedConnection(name,protect)</code> — creates a connecion object<br><code>connection = connection:init()</code> — initaties the connection object<br><code>connectionID = connection:connect(FUNCTION func)</code> — works like the regular connect function<br><code>void = connection:holdUT(NUMBER/FUNCTION n)</code> — works just like the regular holdut function<br><code>void = connection:Remove()</code> — works the same as the default<br><code>voic = connection:Fire(ARGS ...)</code> — works the same as the default</p><p>In the current form a connection object requires that the multi:mainloop() is running on the threads that are sharing this object! By extention since SystemThreadedTables rely on SystemThreadedConnections they have the same requirements. Both objects should not be used for now. </p><p>Since the current object is not in a stable condition, I will not be providing examples of how to use it just yet!</p><p>*The main issue we have with the connection objects in this form is proper comunication and memory managament between threads. For example if a thread crashes or no longer exists the current apporach to how I manage the connection objects will cause all connections to halt. This feature is still being worked on and has many bugs to be patched out. for now only use for testing purposes.</p><h2 id="st---systemthreadedtable---wip*"><a name="st---systemthreadedtable---wip*" href="#st---systemthreadedtable---wip*"></a>ST - SystemThreadedTable - WIP*</h2><h2 id="st---systemthreadedbenchmark"><a name="st---systemthreadedbenchmark" href="#st---systemthreadedbenchmark"></a>ST - SystemThreadedBenchmark</h2><p><code>bench = multi:SystemThreadedBenchmark(NUMBER seconds)</code> — runs a benchmark for a certain amount of time<br><code>bench:OnBench(FUNCTION callback(NUMBER steps/second))</code></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>multi = require(&quot;multi&quot;)
local GLOBAL, THREAD = require(&quot;multi.integration.lanesManager&quot;).init()
multi:SystemThreadedBenchmark(1).OnBench(function(...)
    print(...)
end)
multi:mainloop()
</code></pre>">multi = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-keyword">local</span> GLOBAL, THREAD = <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
multi:SystemThreadedBenchmark(<span class="hljs-number">1</span>).OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(...)</span></span>
    <span class="hljs-built_in">print</span>(...)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="st---systemthreadedexecute-wip*-might-remove"><a name="st---systemthreadedexecute-wip*-might-remove" href="#st---systemthreadedexecute-wip*-might-remove"></a>ST - SystemThreadedExecute WIP* Might remove</h2><h2 id="network-threads---multi-integration"><a name="network-threads---multi-integration" href="#network-threads---multi-integration"></a>Network Threads - Multi-Integration</h2>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
