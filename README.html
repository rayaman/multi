<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>README.html</title>
  <meta name="generator" content="Haroopad 0.13.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}@import url(http://fonts.googleapis.com/css?family=Roboto+Condensed:300italic,400italic,700italic,400,300,700);.haroopad{padding:20px;color:#222;font-size:15px;font-family:"Roboto Condensed",Tauri,"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;background:#fff;line-height:1.6;-webkit-font-smoothing:antialiased}.haroopad a{color:#3269a0}.haroopad a:hover{color:#4183c4}.haroopad h2{border-bottom:1px solid #e6e6e6}.haroopad h6{color:#777}.haroopad hr{border:1px solid #e6e6e6}.haroopad blockquote>code,.haroopad h1>code,.haroopad h2>code,.haroopad h3>code,.haroopad h4>code,.haroopad h5>code,.haroopad h6>code,.haroopad li>code,.haroopad p>code,.haroopad td>code{font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;font-size:85%;background-color:rgba(0,0,0,.02);padding:.2em .5em;border:1px solid #efefef}.haroopad pre>code{font-size:1em;letter-spacing:-1px;font-weight:700}.haroopad blockquote{border-left:4px solid #e6e6e6;padding:0 15px;color:#777}.haroopad table{background-color:#fafafa}.haroopad table tr td,.haroopad table tr th{border:1px solid #e6e6e6}.haroopad table tr:nth-child(2n){background-color:#f2f2f2}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-pi,.lisp .hljs-string{color:#93a1a1}.css .hljs-tag,.hljs-addition,.hljs-keyword,.hljs-request,.hljs-status,.hljs-winutils,.method,.nginx .hljs-title{color:#859900}.hljs-command,.hljs-dartdoc,.hljs-hexcolor,.hljs-link_url,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-rules .hljs-value,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#2aa198}.css .hljs-function,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.vhdl .hljs-literal{color:#268bd2}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-link_reference,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.css .hljs-pseudo,.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-header,.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#eee8d5}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:2px;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:2px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:1em}.MathJax_MenuRadioCheck.RTL{right:1em;left:auto}.MathJax_MenuLabel{padding:2px 2em 4px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #CCC;margin:4px 1px 0}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:Highlight;color:HighlightText}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown haroopad">
<h1 id="multi-version:-1.8.4-(system-threaded-job-queues)"><a name="multi-version:-1.8.4-(system-threaded-job-queues)" href="#multi-version:-1.8.4-(system-threaded-job-queues)"></a>multi Version: 1.8.4 (System Threaded Job Queues)</h1><p><strong>Note: The changes section has information on how to use the new features as they come out. Why put the infomation twice on the readme?</strong> Also I added a Testing Branch. That Branch will have the latest updates, but those updates may be unstable. I like to keep the master as bug free as possible<br></p><p>In Changes you’ll find documentation for(In Order):</p><ul>
<li>System Threaded Job Queues</li><li>New mainloop functions</li><li>System Threaded Tables</li><li>System Threaded Benchmark</li><li>System Threaded Queues</li><li>Threading related features</li><li>And backwards compat stuff</li></ul><p>My multitasking library for lua<br><br>To install copy the multi folder into your enviroment and you are good to go<br></p><p>It is a pure lua binding if you ingore the integrations and the love2d compat<br></p><p>If you find any bugs or have any issues please let me know :)</p><p>If you don’t see a table of contents try using the ReadMe.html file. It is eaiser to navigate the readme<br></p><p class="toc" style="undefined"></p><ul>
<li><ul>
<li><span class="title">
<a href="#installing" title="INSTALLING">INSTALLING</a>
</span>
<!--span class="number">
0
</span-->
</li>
<li><span class="title">
<a href="#discord" title="Discord">Discord</a>
</span>
<!--span class="number">
1
</span-->
</li>
<li><span class="title">
<a href="#planned-features/todo" title="Planned features/TODO">Planned features/TODO</a>
</span>
<!--span class="number">
2
</span-->
</li>
<li><span class="title">
<a href="#known-bugs/issues" title="Known Bugs/Issues">Known Bugs/Issues</a>
</span>
<!--span class="number">
3
</span-->
</li>
<li><span class="title">
<a href="#usage:" title="Usage:">Usage:</a>
</span>
<!--span class="number">
4
</span-->
</li>
<li><span class="title">
<a href="#loops" title="LOOPS">LOOPS</a>
</span>
<!--span class="number">
5
</span-->
</li>
<li><span class="title">
<a href="#events" title="EVENTS">EVENTS</a>
</span>
<!--span class="number">
6
</span-->
</li>
<li><span class="title">
<a href="#steps" title="STEPS">STEPS</a>
</span>
<!--span class="number">
7
</span-->
</li>
<li><span class="title">
<a href="#tloops" title="TLOOPS">TLOOPS</a>
</span>
<!--span class="number">
8
</span-->
</li>
<li><span class="title">
<a href="#connections" title="Connections">Connections</a>
</span>
<!--span class="number">
9
</span-->
</li>
<li><span class="title">
<a href="#timers" title="TIMERS">TIMERS</a>
</span>
<!--span class="number">
10
</span-->
</li>
<li><span class="title">
<a href="#updater" title="UPDATER">UPDATER</a>
</span>
<!--span class="number">
11
</span-->
</li>
<li><span class="title">
<a href="#processes" title="Processes">Processes</a>
</span>
<!--span class="number">
12
</span-->
</li>
<li><span class="title">
<a href="#queuer-(wip)" title="Queuer (WIP)">Queuer (WIP)</a>
</span>
<!--span class="number">
13
</span-->
</li>
<li><span class="title">
<a href="#threads" title="Threads">Threads</a>
</span>
<!--span class="number">
14
</span-->
</li>
<li><span class="title">
<a href="#threadable-actors" title="Threadable Actors">Threadable Actors</a>
</span>
<!--span class="number">
15
</span-->
</li>
<li><span class="title">
<a href="#functions" title="Functions">Functions</a>
</span>
<!--span class="number">
16
</span-->
</li>
<li><span class="title">
<a href="#threadedupdater" title="ThreadedUpdater">ThreadedUpdater</a>
</span>
<!--span class="number">
17
</span-->
</li>
<li><span class="title">
<a href="#triggers" title="Triggers">Triggers</a>
</span>
<!--span class="number">
18
</span-->
</li>
<li><span class="title">
<a href="#tasks" title="Tasks">Tasks</a>
</span>
<!--span class="number">
19
</span-->
</li>
<li><span class="title">
<a href="#jobs" title="Jobs">Jobs</a>
</span>
<!--span class="number">
20
</span-->
</li>
<li><span class="title">
<a href="#watchers" title="Watchers">Watchers</a>
</span>
<!--span class="number">
21
</span-->
</li>
<li><span class="title">
<a href="#timeout-management" title="Timeout management">Timeout management</a>
</span>
<!--span class="number">
22
</span-->
</li>
<li><span class="title">
<a href="#changes" title="Changes">Changes</a>
</span>
<!--span class="number">
23
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.8.3-to-1.8.4" title="Updated from 1.8.3 to 1.8.4">Updated from 1.8.3 to 1.8.4</a>
</span>
<!--span class="number">
24
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.8.2-to-1.8.3" title="Updated from 1.8.2 to 1.8.3">Updated from 1.8.2 to 1.8.3</a>
</span>
<!--span class="number">
25
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.8.1-to-1.8.2" title="Updated from 1.8.1 to 1.8.2">Updated from 1.8.1 to 1.8.2</a>
</span>
<!--span class="number">
26
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.8.0-to-1.8.1" title="Updated from 1.8.0 to 1.8.1">Updated from 1.8.0 to 1.8.1</a>
</span>
<!--span class="number">
27
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.7.5-to-1.7.6" title="Updated from 1.7.5 to 1.7.6">Updated from 1.7.5 to 1.7.6</a>
</span>
<!--span class="number">
28
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.7.4-to-1.7.5" title="Updated from 1.7.4 to 1.7.5">Updated from 1.7.4 to 1.7.5</a>
</span>
<!--span class="number">
29
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.7.3-to-1.7.4" title="Updated from 1.7.3 to 1.7.4">Updated from 1.7.3 to 1.7.4</a>
</span>
<!--span class="number">
30
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.7.2-to-1.7.3" title="Updated from 1.7.2 to 1.7.3">Updated from 1.7.2 to 1.7.3</a>
</span>
<!--span class="number">
31
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.7.1-to-1.7.2" title="Updated from 1.7.1 to 1.7.2">Updated from 1.7.1 to 1.7.2</a>
</span>
<!--span class="number">
32
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.7.0-to-1.7.1-bug-fixes-only" title="Updated from 1.7.0 to 1.7.1 Bug fixes only">Updated from 1.7.0 to 1.7.1 Bug fixes only</a>
</span>
<!--span class="number">
33
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.6.0-to-1.7.0" title="Updated from 1.6.0 to 1.7.0">Updated from 1.6.0 to 1.7.0</a>
</span>
<!--span class="number">
34
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.5.0-to-1.6.0" title="Updated from 1.5.0 to 1.6.0">Updated from 1.5.0 to 1.6.0</a>
</span>
<!--span class="number">
35
</span-->
</li>
<li><span class="title">
<a href="#updated-from-1.4.1-to-1.5.0" title="Updated from 1.4.1 to 1.5.0">Updated from 1.4.1 to 1.5.0</a>
</span>
<!--span class="number">
36
</span-->
</li>
<li><span class="title">
<a href="#1.4.1---first-public-release-of-the-library" title="1.4.1 - First Public release of the library">1.4.1 - First Public release of the library</a>
</span>
<!--span class="number">
37
</span-->
</li>
<li><span class="title">
<a href="#rambling" title="Rambling">Rambling</a>
</span>
<!--span class="number">
38
</span-->
</li>
</ul>
</li>

</ul>
<p></p><h2 id="installing"><a name="installing" href="#installing"></a>INSTALLING</h2><pre><code data-origin="<pre><code>luarocks install multi
</code></pre>">luarocks install multi
</code></pre><h2 id="discord"><a name="discord" href="#discord"></a>Discord</h2><p>For real-time assistance with my libraries! A place where you can ask questions and get help with any of my libraries. Also you can request features and stuff there as well.<br><br><a href="https://discord.gg/U8UspuA">https://discord.gg/U8UspuA</a><br></p><h2 id="planned-features/todo"><a name="planned-features/todo" href="#planned-features/todo"></a>Planned features/TODO</h2><ul>
<li style="list-style: none"><input type="checkbox" class="task-list-item" checked="" data-task-index="0"> <del>Add system threads for love2d that works like the lanesManager (loveManager, slight differences).</del></li><li style="list-style: none"><input type="checkbox" class="task-list-item" checked="" data-task-index="1"> <del>Improve performance of the library</del></li><li style="list-style: none"><input type="checkbox" class="task-list-item" checked="" data-task-index="2"> <del>Improve coroutine based threading scheduling</del></li><li style="list-style: none"><input type="checkbox" class="task-list-item" data-task-index="3"> Improve love2d Idle thread cpu usage… Tricky Look at the rambling section for insight.</li><li style="list-style: none"><input type="checkbox" class="task-list-item" checked="" data-task-index="4"> <del>Add more features to support module creators</del></li><li style="list-style: none"><input type="checkbox" class="task-list-item" checked="" data-task-index="5"> <del>Make a framework for eaiser thread task distributing</del></li><li style="list-style: none"><input type="checkbox" class="task-list-item" checked="" data-task-index="6"> <del>Fix Error handling on threaded multi objects</del> Non threaded multiobjs will crash your program if they error though! Use multi:newThread() of multi:newSystemThread() if your code can error! Unless you use multi:protect() this however lowers performance!</li><li style="list-style: none"><input type="checkbox" class="task-list-item" checked="" data-task-index="7"> <del>Add multi:OnError(function(obj,err))</del></li><li style="list-style: none"><input type="checkbox" class="task-list-item" data-task-index="8"> sThread.wrap(obj) <strong>May or may not be completed</strong> Theory: Allows interaction in one thread to affect it in another. The addition to threaded tables may make this possible!</li><li style="list-style: none"><input type="checkbox" class="task-list-item" data-task-index="9"> SystemThreaded Actors — After some tests i figured out a way to make this work… It will work slightly different though. This is due to the actor needing to be splittable…</li><li style="list-style: none"><input type="checkbox" class="task-list-item" data-task-index="10"> LoadBalancing for system threads (Once SystemThreaded Actors are done)</li><li style="list-style: none"><input type="checkbox" class="task-list-item" data-task-index="11"> Add more integrations</li><li style="list-style: none"><input type="checkbox" class="task-list-item" data-task-index="12"> Finish the wiki stuff. (11% done)</li><li style="list-style: none"><input type="checkbox" class="task-list-item" data-task-index="13"> Test for unknown bugs</li></ul><h2 id="known-bugs/issues"><a name="known-bugs/issues" href="#known-bugs/issues"></a>Known Bugs/Issues</h2><p>In regards to integrations, thread cancellation works slightly different for love2d and lanes. Within love2d I was unable to (To lazy to…) not use the multi library within the thread. A fix for this is to call <code>multi:Stop()</code> when you are done with your threaded code! This may change however if I find a way to work around this. In love2d in order to mimic the GLOBAL table I needed the library to constantly sync tha data… You can use the sThread.waitFor(varname), or sThread.hold(func) methods to sync the globals, to get the value instead of using GLOBAL and this could work. If you want to go this route I suggest setting multi.isRunning=true to prevent the auto runner from doing its thing! This will make the multi manager no longer function, but thats the point :P</p><p>Another bug concerns the SystemThreadedJobQueue, Only 1 can be used for now… Vreating more may not be a good idea.</p><h2 id="usage:"><a name="usage:" href="#usage:"></a>Usage:<br></h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Basic usage Alarms: Have been moved to the core of the library require(&quot;multi&quot;) would work as well
require(&quot;multi&quot;) -- gets the entire library
alarm=multi:newAlarm(3) -- in seconds can go to .001 uses the built in os.clock()
alarm:OnRing(function(a)
  print(&quot;3 Seconds have passed!&quot;)
  a:Reset(n) -- if n were nil it will reset back to 3, or it would reset to n seconds
end)
multi:mainloop() -- the main loop of the program, multi:umanager() exists as well to allow integration in other loops Ex: love2d love.update function. More on this binding in the wiki!
</code></pre>"><span class="hljs-comment">-- Basic usage Alarms: Have been moved to the core of the library require("multi") would work as well</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>) <span class="hljs-comment">-- gets the entire library</span>
alarm=multi:newAlarm(<span class="hljs-number">3</span>) <span class="hljs-comment">-- in seconds can go to .001 uses the built in os.clock()</span>
alarm:OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"3 Seconds have passed!"</span>)
  a:Reset(n) <span class="hljs-comment">-- if n were nil it will reset back to 3, or it would reset to n seconds</span>
<span class="hljs-keyword">end</span>)
multi:mainloop() <span class="hljs-comment">-- the main loop of the program, multi:umanager() exists as well to allow integration in other loops Ex: love2d love.update function. More on this binding in the wiki!</span>
</code></pre><p>The library is modular so you only need to require what you need to. Because of this, the global enviroment is altered<br></p><p>There are many useful objects that you can use<br><br>Check out the wiki for detailed usage, but here are the objects:<br></p><ul>
<li>Process#<br></li><li>QueueQueuer#<br></li><li>Alarm<br></li><li>Loop<br></li><li>Event<br></li><li>Step<br></li><li>Range<br></li><li>TStep<br></li><li>TLoop<br></li><li>Condition<br></li><li>Connection<br></li><li>Timer<br></li><li>Updater<br></li><li>Thread*<br></li><li>Trigger<br></li><li>Task<br></li><li>Job<br></li><li>Function<br></li><li>Watcher<br><br>Note: <em>Both a process and queue act like the multi namespace, but allows for some cool things. Because they use the other objects an example on them will be done last</em><br><br>*Uses the built in coroutine features of lua, these have an interesting interaction with the other means of multi-tasking<br><br>Triggers are kind of useless after the creation of the Connection<br><br>Watchers have no real purpose as well I made it just because.<br></li></ul><h1 id="examples-of-each-object-being-used"><a name="examples-of-each-object-being-used" href="#examples-of-each-object-being-used"></a>Examples of each object being used<br></h1><p>We already showed alarms in action so lets move on to a Loop object</p><p>Throughout these examples I am going to do some strange things in order to show other features of the library!</p><h2 id="loops"><a name="loops" href="#loops"></a>LOOPS</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Loops: Have been moved to the core of the library require(&quot;multi&quot;) would work as well
require(&quot;multi&quot;) -- gets the entire library
count=0
loop=multi:newLoop(function(self,dt) -- dt is delta time and self is a reference to itself
  count=count+1
  if count &amp;gt; 10 then
    self:Break() -- All methods on the multi objects are upper camel case, where as methods on the multi or process/queuer namespace are lower camel case
    -- self:Break() will stop the loop and trigger the OnBreak(func) method
    -- Stopping is the act of Pausing and deactivating the object! All objects can have the multiobj:Break() command on it!
  else
    print(&quot;Loop #&quot;..count..&quot;!&quot;)
  end
end)
loop:OnBreak(function(self)
  print(&quot;You broke me :(&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- Loops: Have been moved to the core of the library require("multi") would work as well</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>) <span class="hljs-comment">-- gets the entire library</span>
count=<span class="hljs-number">0</span>
loop=multi:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span> <span class="hljs-comment">-- dt is delta time and self is a reference to itself</span>
  count=count+<span class="hljs-number">1</span>
  <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">10</span> <span class="hljs-keyword">then</span>
    self:Break() <span class="hljs-comment">-- All methods on the multi objects are upper camel case, where as methods on the multi or process/queuer namespace are lower camel case</span>
    <span class="hljs-comment">-- self:Break() will stop the loop and trigger the OnBreak(func) method</span>
    <span class="hljs-comment">-- Stopping is the act of Pausing and deactivating the object! All objects can have the multiobj:Break() command on it!</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Loop #"</span>..count..<span class="hljs-string">"!"</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
loop:OnBreak(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"You broke me :("</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Loop #1!<br><br>Loop #2!<br><br>Loop #3!<br><br>Loop #4!<br><br>Loop #5!<br><br>Loop #6!<br><br>Loop #7!<br><br>Loop #8!<br><br>Loop #9!<br><br>Loop #10!<br><br>You broke me :(<br></p><p>With loops out of the way lets go down the line</p><p>This library aims to be Async like. In reality everything is still on one thread <em>unless you are using the lanes integration module WIP</em> (More on that later)</p><h2 id="events"><a name="events" href="#events"></a>EVENTS</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Events, these were the first objects introduced into the library. I seldomly use them in their pure form though, but later on you'll see their advance uses!
-- Events on there own don't really do much... We are going to need 2 objects at least to get something going
require(&quot;multi&quot;) -- gets the entire library
count=0
-- lets use the loop again to add to count!
loop=multi:newLoop(function(self,dt)
  count=count+1
end)
event=multi:newEvent(function() return count==100 end) -- set the event
event:OnEvent(function(self) -- connect to the event object
  loop:Pause() -- pauses the loop from running!
  print(&quot;Stopped that loop!&quot;)
end) -- events like alarms need to be reset the Reset() command works here as well
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- Events, these were the first objects introduced into the library. I seldomly use them in their pure form though, but later on you'll see their advance uses!</span>
<span class="hljs-comment">-- Events on there own don't really do much... We are going to need 2 objects at least to get something going</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>) <span class="hljs-comment">-- gets the entire library</span>
count=<span class="hljs-number">0</span>
<span class="hljs-comment">-- lets use the loop again to add to count!</span>
loop=multi:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
  count=count+<span class="hljs-number">1</span>
<span class="hljs-keyword">end</span>)
event=multi:newEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> count==<span class="hljs-number">100</span> <span class="hljs-keyword">end</span>) <span class="hljs-comment">-- set the event</span>
event:OnEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span> <span class="hljs-comment">-- connect to the event object</span>
  loop:Pause() <span class="hljs-comment">-- pauses the loop from running!</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Stopped that loop!"</span>)
<span class="hljs-keyword">end</span>) <span class="hljs-comment">-- events like alarms need to be reset the Reset() command works here as well</span>
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Stopped that loop!</p><h2 id="steps"><a name="steps" href="#steps"></a>STEPS</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
-- Steps, are like for loops but non blocking... You can run a loop to infintity and everything will still run I will combine Steps with Ranges in this example.
step1=multi:newStep(1,10,1,0) -- Some explaining is due. Argument 1 is the Start # Argument 2 is the ResetAt # (inclusive) Argument 3 is the count # (in our case we are counting by +1, this can be -1 but you need to adjust your start and resetAt numbers)
-- The 4th Argument is for skipping. This is useful for timing and for basic priority management. A priority management system is included!
step2=multi:newStep(10,1,-1,1) -- a second step, notice the slight changes!
step1:OnStart(function(self)
  print(&quot;Step Started!&quot;)
end)
step1:OnStep(function(self,pos)
  if pos&amp;lt;=10 then -- what what is this? the step only goes to 10!!!
    print(&quot;Stepping... &quot;..pos)
   else
    print(&quot;How did I get here?&quot;)
   end
end)
step1:OnEnd(function(self)
  print(&quot;Done!&quot;)
  -- We finished here, but I feel like we could have reused this step in some way... Yeah I soule Reset() it, but what if i wanted to change it...
  if self.endAt==10 then -- lets only loop once
    self:Update(1,11,1,0) -- oh now we can reach that else condition!
  end
  -- Note Update() will restart the step!
end)

-- step2 is bored lets give it some love :P
step2.range=step2:newRange() -- Set up a range object to have a nested step in a sense! Each nest requires a new range
-- it is in your interest not to share ranges between objects! You can however do it if it suits your needs though
step2:OnStep(function(self,pos)
  -- for 1=1,math.huge do
    --  print(&quot;Haha I am holding the code up because I can!!!&quot;)
  --end
  -- We dont want to hold things up, but we want to nest.
  -- Note a range is not nessary if the nested for loop has a small range, if however the range is rather large you may want to allow other objects to do some work
  for i in self.range(1,100) do
    print(pos,i) -- Now our nested for loop is using a range object which allows for other objects to get some cpu time while this one is running
  end
end)
-- TSteps are just like alarms and steps mixed together, the only difference in construction is the 4th Argument. On a TStep that argument controls time. The defualt is 1
-- The Reset(n) works just like you would figure!
step3=multi:newTStep(1,10,.5,2) -- lets go from 1 to 10 counting by .5 every 2 seconds
step3:OnStep(function(self,pos)
  print(&quot;Ok &quot;..pos..&quot;!&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-comment">-- Steps, are like for loops but non blocking... You can run a loop to infintity and everything will still run I will combine Steps with Ranges in this example.</span>
step1=multi:newStep(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">-- Some explaining is due. Argument 1 is the Start # Argument 2 is the ResetAt # (inclusive) Argument 3 is the count # (in our case we are counting by +1, this can be -1 but you need to adjust your start and resetAt numbers)</span>
<span class="hljs-comment">-- The 4th Argument is for skipping. This is useful for timing and for basic priority management. A priority management system is included!</span>
step2=multi:newStep(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">-- a second step, notice the slight changes!</span>
step1:OnStart(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Step Started!"</span>)
<span class="hljs-keyword">end</span>)
step1:OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,pos)</span></span>
  <span class="hljs-keyword">if</span> pos&lt;=<span class="hljs-number">10</span> <span class="hljs-keyword">then</span> <span class="hljs-comment">-- what what is this? the step only goes to 10!!!</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Stepping... "</span>..pos)
   <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"How did I get here?"</span>)
   <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
step1:OnEnd(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Done!"</span>)
  <span class="hljs-comment">-- We finished here, but I feel like we could have reused this step in some way... Yeah I soule Reset() it, but what if i wanted to change it...</span>
  <span class="hljs-keyword">if</span> self.endAt==<span class="hljs-number">10</span> <span class="hljs-keyword">then</span> <span class="hljs-comment">-- lets only loop once</span>
    self:Update(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">-- oh now we can reach that else condition!</span>
  <span class="hljs-keyword">end</span>
  <span class="hljs-comment">-- Note Update() will restart the step!</span>
<span class="hljs-keyword">end</span>)

<span class="hljs-comment">-- step2 is bored lets give it some love :P</span>
step2.range=step2:newRange() <span class="hljs-comment">-- Set up a range object to have a nested step in a sense! Each nest requires a new range</span>
<span class="hljs-comment">-- it is in your interest not to share ranges between objects! You can however do it if it suits your needs though</span>
step2:OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,pos)</span></span>
  <span class="hljs-comment">-- for 1=1,math.huge do</span>
    <span class="hljs-comment">--  print("Haha I am holding the code up because I can!!!")</span>
  <span class="hljs-comment">--end</span>
  <span class="hljs-comment">-- We dont want to hold things up, but we want to nest.</span>
  <span class="hljs-comment">-- Note a range is not nessary if the nested for loop has a small range, if however the range is rather large you may want to allow other objects to do some work</span>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.range(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>) <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(pos,i) <span class="hljs-comment">-- Now our nested for loop is using a range object which allows for other objects to get some cpu time while this one is running</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- TSteps are just like alarms and steps mixed together, the only difference in construction is the 4th Argument. On a TStep that argument controls time. The defualt is 1</span>
<span class="hljs-comment">-- The Reset(n) works just like you would figure!</span>
step3=multi:newTStep(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,.<span class="hljs-number">5</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">-- lets go from 1 to 10 counting by .5 every 2 seconds</span>
step3:OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,pos)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Ok "</span>..pos..<span class="hljs-string">"!"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Note: the output on this one is huge!!! So I had to … some parts! You need to run this for your self to see what is going on!<br><br>Step Started!<br><br>Stepping… 1<br><br>10    1<br><br>Stepping… 2<br><br>10    2<br><br>Stepping… 3<br><br>10    3<br><br>…<br><br>Ok 9.5!<br><br>Ok 10!<br></p><h2 id="tloops"><a name="tloops" href="#tloops"></a>TLOOPS</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
-- TLoops are loops that run ever n second. We will also look at condition objects as well
-- Here we are going to modify the old loop to be a little different
count=0
loop=multi:newTLoop(function(self) -- We are only going to coult with this loop, but doing so using a condition!
  while self:condition(self.cond) do
    count=count+1
  end
  print(&quot;Count is &quot;..count..&quot;!&quot;)
  self:Destroy() -- Lets destroy this object, casting it to the dark abyss MUHAHAHA!!!
  -- the reference to this object will be a phantom object that does nothing!
end,1) -- Notice the ',1' after the function! This is where you put your time value!
loop.cond=multi:newCondition(function() return count&amp;lt;=100 end) -- conditions need a bit of work before i am happy with them
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-comment">-- TLoops are loops that run ever n second. We will also look at condition objects as well</span>
<span class="hljs-comment">-- Here we are going to modify the old loop to be a little different</span>
count=<span class="hljs-number">0</span>
loop=multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span> <span class="hljs-comment">-- We are only going to coult with this loop, but doing so using a condition!</span>
  <span class="hljs-keyword">while</span> self:condition(self.cond) <span class="hljs-keyword">do</span>
    count=count+<span class="hljs-number">1</span>
  <span class="hljs-keyword">end</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Count is "</span>..count..<span class="hljs-string">"!"</span>)
  self:Destroy() <span class="hljs-comment">-- Lets destroy this object, casting it to the dark abyss MUHAHAHA!!!</span>
  <span class="hljs-comment">-- the reference to this object will be a phantom object that does nothing!</span>
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">-- Notice the ',1' after the function! This is where you put your time value!</span>
loop.cond=multi:newCondition(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> count&lt;=<span class="hljs-number">100</span> <span class="hljs-keyword">end</span>) <span class="hljs-comment">-- conditions need a bit of work before i am happy with them</span>
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Count is 101!</p><h2 id="connections"><a name="connections" href="#connections"></a>Connections</h2><p>These are my favorite objects and you’ll see why. They are very useful objects for ASync connections!</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
-- Lets create the events
yawn={} -- ill just leave that there
OnCustomSafeEvent=multi:newConnection(true) -- lets pcall the calls incase something goes wrong defualt
OnCustomEvent=multi:newConnection(false) -- lets not pcall the calls and let errors happen... We are good at coding though so lets get a speed advantage by not pcalling. Pcalling is useful for plugins and stuff that may have been coded badly and you can ingore those connections if need be.
OnCustomEvent:Bind(yawn) -- create the connection lookup data in yawn

-- Lets connect to them, a recent update adds a nice syntax to connect to these
cd1=OnCustomSafeEvent:Connect(function(arg1,arg2,...)
  print(&quot;CSE1&quot;,arg1,arg2,...)
end,&quot;bob&quot;) -- lets give this connection a name
cd2=OnCustomSafeEvent:Connect(function(arg1,arg2,...)
  print(&quot;CSE2&quot;,arg1,arg2,...)
end,&quot;joe&quot;) -- lets give this connection a name
cd3=OnCustomSafeEvent:Connect(function(arg1,arg2,...)
  print(&quot;CSE3&quot;,arg1,arg2,...)
end) -- lets not give this connection a name

-- no need for connect, but I kept that function because of backwards compatibility.
OnCustomEvent(function(arg1,arg2,...)
  print(arg1,arg2,...)
end)

-- Now within some loop/other object you trigger the connection like
OnCustomEvent:Fire(1,2,&quot;Hello!!!&quot;) -- fire all conections

-- You may have noticed that some events have names! See the following example!
OnCustomSafeEvent:getConnection(&quot;bob&quot;):Fire(1,100,&quot;Bye!&quot;) -- fire only bob!
OnCustomSafeEvent:getConnection(&quot;joe&quot;):Fire(1,100,&quot;Hello!&quot;) -- fire only joe!!
OnCustomSafeEvent:Fire(1,100,&quot;Hi Ya Folks!!!&quot;) -- fire them all!!!

-- Connections have more to them than that though!
-- As seen above cd1-cd3 these are hooks to the connection object. This allows you to remove a connection
-- For Example:
cd1:Remove() -- remove this connection from the master connection object
print(&quot;------&quot;)
OnCustomSafeEvent:Fire(1,100,&quot;Hi Ya Folks!!!&quot;) -- fire them all again!!!
-- To remove all connections use:
OnCustomSafeEvent:Remove()
print(&quot;------&quot;)
OnCustomSafeEvent:Fire(1,100,&quot;Hi Ya Folks!!!&quot;) -- fire them all again!!!
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-comment">-- Lets create the events</span>
yawn={} <span class="hljs-comment">-- ill just leave that there</span>
OnCustomSafeEvent=multi:newConnection(<span class="hljs-keyword">true</span>) <span class="hljs-comment">-- lets pcall the calls incase something goes wrong defualt</span>
OnCustomEvent=multi:newConnection(<span class="hljs-keyword">false</span>) <span class="hljs-comment">-- lets not pcall the calls and let errors happen... We are good at coding though so lets get a speed advantage by not pcalling. Pcalling is useful for plugins and stuff that may have been coded badly and you can ingore those connections if need be.</span>
OnCustomEvent:Bind(yawn) <span class="hljs-comment">-- create the connection lookup data in yawn</span>

<span class="hljs-comment">-- Lets connect to them, a recent update adds a nice syntax to connect to these</span>
cd1=OnCustomSafeEvent:Connect(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1,arg2,...)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"CSE1"</span>,arg1,arg2,...)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"bob"</span>) <span class="hljs-comment">-- lets give this connection a name</span>
cd2=OnCustomSafeEvent:Connect(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1,arg2,...)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"CSE2"</span>,arg1,arg2,...)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"joe"</span>) <span class="hljs-comment">-- lets give this connection a name</span>
cd3=OnCustomSafeEvent:Connect(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1,arg2,...)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"CSE3"</span>,arg1,arg2,...)
<span class="hljs-keyword">end</span>) <span class="hljs-comment">-- lets not give this connection a name</span>

<span class="hljs-comment">-- no need for connect, but I kept that function because of backwards compatibility.</span>
OnCustomEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1,arg2,...)</span></span>
  <span class="hljs-built_in">print</span>(arg1,arg2,...)
<span class="hljs-keyword">end</span>)

<span class="hljs-comment">-- Now within some loop/other object you trigger the connection like</span>
OnCustomEvent:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"Hello!!!"</span>) <span class="hljs-comment">-- fire all conections</span>

<span class="hljs-comment">-- You may have noticed that some events have names! See the following example!</span>
OnCustomSafeEvent:getConnection(<span class="hljs-string">"bob"</span>):Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Bye!"</span>) <span class="hljs-comment">-- fire only bob!</span>
OnCustomSafeEvent:getConnection(<span class="hljs-string">"joe"</span>):Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Hello!"</span>) <span class="hljs-comment">-- fire only joe!!</span>
OnCustomSafeEvent:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Hi Ya Folks!!!"</span>) <span class="hljs-comment">-- fire them all!!!</span>

<span class="hljs-comment">-- Connections have more to them than that though!</span>
<span class="hljs-comment">-- As seen above cd1-cd3 these are hooks to the connection object. This allows you to remove a connection</span>
<span class="hljs-comment">-- For Example:</span>
cd1:Remove() <span class="hljs-comment">-- remove this connection from the master connection object</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"------"</span>)
OnCustomSafeEvent:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Hi Ya Folks!!!"</span>) <span class="hljs-comment">-- fire them all again!!!</span>
<span class="hljs-comment">-- To remove all connections use:</span>
OnCustomSafeEvent:Remove()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"------"</span>)
OnCustomSafeEvent:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Hi Ya Folks!!!"</span>) <span class="hljs-comment">-- fire them all again!!!</span>
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>1    2    Hello!!!<br><br>CSE1    1    100    Bye!<br><br>CSE2    1    100    Hello!<br><br>CSE1    1    100    Hi Ya Folks!!!<br><br>CSE2    1    100    Hi Ya Folks!!!<br><br>CSE3    1    100    Hi Ya Folks!!!<br><br>CSE2    1    100    Hi Ya Folks!!!<br><br>CSE3    1    100    Hi Ya Folks!!!<br><br><br></p><p>You may think timers should be bundled with alarms, but they are a bit different and have cool features<br></p><h2 id="timers"><a name="timers" href="#timers"></a>TIMERS</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- You see the thing is that all time based objects use timers eg. Alarms, TSteps, and Loops. Timers are more low level!
require(&quot;multi&quot;)
local clock = os.clock
function sleep(n)  -- seconds
  local t0 = clock()
  while clock() - t0 &amp;lt;= n do end
end -- we will use this later!

timer=multi:newTimer()
timer:Start()
-- lets do a mock alarm
set=3 -- 3 seconds
a=0
while timer:Get()&amp;lt;=set do
  -- waiting...
  a=a+1
end
print(set..&quot; second(s) have passed!&quot;)
-- Timers can do one more thing that is interesting and that is pausing them!
timer:Pause()
print(timer:Get()) -- should be really close to 'set'
sleep(3)
print(timer:Get()) -- should be really close to 'set'
timer:Resume()
sleep(1)
print(timer:Get()) -- should be really close to the value of set + 1
timer:Pause()
print(timer:Get()) -- should be really close to 'set'
sleep(3)
print(timer:Get()) -- should be really close to 'set'
timer:Resume()
sleep(1)
print(timer:Get()) -- should be really close to the value of set + 2
</code></pre>"><span class="hljs-comment">-- You see the thing is that all time based objects use timers eg. Alarms, TSteps, and Loops. Timers are more low level!</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-keyword">local</span> clock = <span class="hljs-built_in">os</span>.clock
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span><span class="hljs-params">(n)</span></span>  <span class="hljs-comment">-- seconds</span>
  <span class="hljs-keyword">local</span> t0 = clock()
  <span class="hljs-keyword">while</span> clock() - t0 &lt;= n <span class="hljs-keyword">do</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span> <span class="hljs-comment">-- we will use this later!</span>

timer=multi:newTimer()
timer:Start()
<span class="hljs-comment">-- lets do a mock alarm</span>
set=<span class="hljs-number">3</span> <span class="hljs-comment">-- 3 seconds</span>
a=<span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> timer:Get()&lt;=set <span class="hljs-keyword">do</span>
  <span class="hljs-comment">-- waiting...</span>
  a=a+<span class="hljs-number">1</span>
<span class="hljs-keyword">end</span>
<span class="hljs-built_in">print</span>(set..<span class="hljs-string">" second(s) have passed!"</span>)
<span class="hljs-comment">-- Timers can do one more thing that is interesting and that is pausing them!</span>
timer:Pause()
<span class="hljs-built_in">print</span>(timer:Get()) <span class="hljs-comment">-- should be really close to 'set'</span>
sleep(<span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(timer:Get()) <span class="hljs-comment">-- should be really close to 'set'</span>
timer:Resume()
sleep(<span class="hljs-number">1</span>)
<span class="hljs-built_in">print</span>(timer:Get()) <span class="hljs-comment">-- should be really close to the value of set + 1</span>
timer:Pause()
<span class="hljs-built_in">print</span>(timer:Get()) <span class="hljs-comment">-- should be really close to 'set'</span>
sleep(<span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(timer:Get()) <span class="hljs-comment">-- should be really close to 'set'</span>
timer:Resume()
sleep(<span class="hljs-number">1</span>)
<span class="hljs-built_in">print</span>(timer:Get()) <span class="hljs-comment">-- should be really close to the value of set + 2</span>
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Note: This will make more sense when you run it for your self<br><br>3 second(s) have passed!<br><br>3.001<br><br>3.001<br><br>4.002<br><br>4.002<br><br>4.002<br><br>5.003<br></p><h2 id="updater"><a name="updater" href="#updater"></a>UPDATER</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Updaters: Have been moved to the core of the library require(&quot;multi&quot;) would work as well
require(&quot;multi&quot;)
updater=multi:newUpdater(5) -- really simple, think of a look with the skip feature of a step
updater:OnUpdate(function(self)
  --print(&quot;updating...&quot;)
end)
-- Here every 5 steps the updater will do stuff!
-- But I feel it is now time to touch into priority management, so lets get into basic priority stuff and get into a more advance version of it
--[[
multi.Priority_Core -- Highest form of priority
multi.Priority_High
multi.Priority_Above_Normal
multi.Priority_Normal -- The defualt form of priority
multi.Priority_Below_Normal
multi.Priority_Low
multi.Priority_Idle -- Lowest form of priority

Note: These only take effect when you enable priority, otherwise everything is at a core like level!
We aren't going to use regular objects to test priority, but rather benchmarks!
to set priority on an object though you would do
multiobj:setPriority(one of the above)
]]
-- lets bench for 3 seconds using the 3 forms of priority! First no Priority
multi:benchMark(3,nil,&quot;Regular Bench: &quot;):OnBench(function() -- the onbench() allows us to do each bench after each other!
  print(&quot;P1\n---------------&quot;)
  multi:enablePriority()
  multi:benchMark(3,multi.Priority_Core,&quot;Core:&quot;)
  multi:benchMark(3,multi.Priority_High,&quot;High:&quot;)
  multi:benchMark(3,multi.Priority_Above_Normal,&quot;Above_Normal:&quot;)
  multi:benchMark(3,multi.Priority_Normal,&quot;Normal:&quot;)
  multi:benchMark(3,multi.Priority_Below_Normal,&quot;Below_Normal:&quot;)
  multi:benchMark(3,multi.Priority_Low,&quot;Low:&quot;)
  multi:benchMark(3,multi.Priority_Idle,&quot;Idle:&quot;):OnBench(function()
    print(&quot;P2\n---------------&quot;)
    -- Finally the 3rd form
    multi:enablePriority2()
    multi:benchMark(3,multi.Priority_Core,&quot;Core:&quot;)
    multi:benchMark(3,multi.Priority_High,&quot;High:&quot;)
    multi:benchMark(3,multi.Priority_Above_Normal,&quot;Above_Normal:&quot;)
    multi:benchMark(3,multi.Priority_Normal,&quot;Normal:&quot;)
    multi:benchMark(3,multi.Priority_Below_Normal,&quot;Below_Normal:&quot;)
    multi:benchMark(3,multi.Priority_Low,&quot;Low:&quot;)
    multi:benchMark(3,multi.Priority_Idle,&quot;Idle:&quot;)
  end)
end)
multi:mainloop() -- Notice how the past few examples did not need this, well only actors need to be in a loop! More on this in the wiki.
</code></pre>"><span class="hljs-comment">-- Updaters: Have been moved to the core of the library require("multi") would work as well</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
updater=multi:newUpdater(<span class="hljs-number">5</span>) <span class="hljs-comment">-- really simple, think of a look with the skip feature of a step</span>
updater:OnUpdate(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
  <span class="hljs-comment">--print("updating...")</span>
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- Here every 5 steps the updater will do stuff!</span>
<span class="hljs-comment">-- But I feel it is now time to touch into priority management, so lets get into basic priority stuff and get into a more advance version of it</span>
<span class="hljs-comment">--[[
multi.Priority_Core -- Highest form of priority
multi.Priority_High
multi.Priority_Above_Normal
multi.Priority_Normal -- The defualt form of priority
multi.Priority_Below_Normal
multi.Priority_Low
multi.Priority_Idle -- Lowest form of priority

Note: These only take effect when you enable priority, otherwise everything is at a core like level!
We aren't going to use regular objects to test priority, but rather benchmarks!
to set priority on an object though you would do
multiobj:setPriority(one of the above)
]]</span>
<span class="hljs-comment">-- lets bench for 3 seconds using the 3 forms of priority! First no Priority</span>
multi:benchMark(<span class="hljs-number">3</span>,<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Regular Bench: "</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- the onbench() allows us to do each bench after each other!</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"P1\n---------------"</span>)
  multi:enablePriority()
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Core,<span class="hljs-string">"Core:"</span>)
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_High,<span class="hljs-string">"High:"</span>)
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Above_Normal,<span class="hljs-string">"Above_Normal:"</span>)
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Normal,<span class="hljs-string">"Normal:"</span>)
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Below_Normal,<span class="hljs-string">"Below_Normal:"</span>)
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Low,<span class="hljs-string">"Low:"</span>)
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Idle,<span class="hljs-string">"Idle:"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"P2\n---------------"</span>)
    <span class="hljs-comment">-- Finally the 3rd form</span>
    multi:enablePriority2()
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Core,<span class="hljs-string">"Core:"</span>)
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_High,<span class="hljs-string">"High:"</span>)
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Above_Normal,<span class="hljs-string">"Above_Normal:"</span>)
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Normal,<span class="hljs-string">"Normal:"</span>)
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Below_Normal,<span class="hljs-string">"Below_Normal:"</span>)
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Low,<span class="hljs-string">"Low:"</span>)
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Idle,<span class="hljs-string">"Idle:"</span>)
  <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop() <span class="hljs-comment">-- Notice how the past few examples did not need this, well only actors need to be in a loop! More on this in the wiki.</span>
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Note: These numbers will vary drastically depending on your compiler and cpu power<br><br>Regular Bench:  2094137 Steps in 3 second(s)!<br><br>P1<br><br>Below_Normal: 236022 Steps in 3 second(s)!<br><br>Normal: 314697 Steps in 3 second(s)!<br><br>Above_Normal: 393372 Steps in 3 second(s)!<br><br>High: 472047 Steps in 3 second(s)!<br><br>Core: 550722 Steps in 3 second(s)!<br><br>Low: 157348 Steps in 3 second(s)!<br><br>Idle: 78674 Steps in 3 second(s)!<br><br>P2<br><br>Core: 994664 Steps in 3 second(s)!<br><br>High: 248666 Steps in 3 second(s)!<br><br>Above_Normal: 62166 Steps in 3 second(s)!<br><br>Normal: 15541 Steps in 3 second(s)!<br><br>Below_Normal: 3885 Steps in 3 second(s)!<br><br>Idle: 242 Steps in 3 second(s)!<br><br>Low: 971 Steps in 3 second(s)!<br></p><p>Notice: Even though I started each bench at the same time the order that they finished differed the order is likely to vary on your machine as well!<br></p><h2 id="processes"><a name="processes" href="#processes"></a>Processes</h2><p>A process allows you to group the Actor objects within a controlable interface</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
proc=multi:newProcess() -- takes an optional file as an argument, but for this example we aren't going to use that
-- a process works just like the multi object!
b=0
loop=proc:newTLoop(function(self)
    a=a+1
    proc:Pause() -- pauses the cpu cycler for this processor! Individual objects are not paused, however because they aren't getting cpu time they act as if they were paused
end,.1)
updater=proc:newUpdater(multi.Priority_Idle) -- priority can be used in skip arguments as well to manage priority without enabling it!
updater:OnUpdate(function(self)
    b=b+1
end)
a=0 -- a counter
loop2=proc:newLoop(function(self,dt)
    print(&quot;Lets Go!&quot;)
    self:hold(3) -- this will keep this object from doing anything! Note: You can only have one hold active at a time! Multiple are possible, but results may not be as they seem see * for how hold works
    -- Within a process using hold will keep it alive until the hold is satisified!
    print(&quot;Done being held for 1 second&quot;)
    self:hold(function() return a&amp;gt;10 end)
    print(&quot;A is now: &quot;..a..&quot; b is also: &quot;..b)
    self:Destroy()
    self.Parent:Pause() -- lets say you don't have the reference to the process!
    os.exit()
end)
-- Notice this is now being created on the multi namespace
event=multi:newEvent(function() return os.clock()&amp;gt;=1 end)
event:OnEvent(function(self)
    proc:Resume()
    self:Destroy()
end)
proc:Start()
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
proc=multi:newProcess() <span class="hljs-comment">-- takes an optional file as an argument, but for this example we aren't going to use that</span>
<span class="hljs-comment">-- a process works just like the multi object!</span>
b=<span class="hljs-number">0</span>
loop=proc:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    a=a+<span class="hljs-number">1</span>
    proc:Pause() <span class="hljs-comment">-- pauses the cpu cycler for this processor! Individual objects are not paused, however because they aren't getting cpu time they act as if they were paused</span>
<span class="hljs-keyword">end</span>,.<span class="hljs-number">1</span>)
updater=proc:newUpdater(multi.Priority_Idle) <span class="hljs-comment">-- priority can be used in skip arguments as well to manage priority without enabling it!</span>
updater:OnUpdate(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    b=b+<span class="hljs-number">1</span>
<span class="hljs-keyword">end</span>)
a=<span class="hljs-number">0</span> <span class="hljs-comment">-- a counter</span>
loop2=proc:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Lets Go!"</span>)
    self:hold(<span class="hljs-number">3</span>) <span class="hljs-comment">-- this will keep this object from doing anything! Note: You can only have one hold active at a time! Multiple are possible, but results may not be as they seem see * for how hold works</span>
    <span class="hljs-comment">-- Within a process using hold will keep it alive until the hold is satisified!</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Done being held for 1 second"</span>)
    self:hold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> a&gt;<span class="hljs-number">10</span> <span class="hljs-keyword">end</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"A is now: "</span>..a..<span class="hljs-string">" b is also: "</span>..b)
    self:Destroy()
    self.Parent:Pause() <span class="hljs-comment">-- lets say you don't have the reference to the process!</span>
    <span class="hljs-built_in">os</span>.exit()
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- Notice this is now being created on the multi namespace</span>
event=multi:newEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">os</span>.clock()&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">end</span>)
event:OnEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    proc:Resume()
    self:Destroy()
<span class="hljs-keyword">end</span>)
proc:Start()
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Lets Go!<br><br>Done being held for 1 second<br><br>A is now: 29 b is also: 479<br></p><p><strong>Hold: This method works as follows</strong></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>function multi:hold(task)
    self:Pause() -- pause the current object
    self.held=true -- set held
    if type(task)=='number' then -- a sleep cmd
        local timer=multi:newTimer()
        timer:Start()
        while timer:Get()&amp;lt;task do -- This while loop is what makes using multiple holds tricky... If the outer while is good before the nested one then the outter one will have to wait! There is a way around this though!
            if love then
                self.Parent:lManager()
            else
                self.Parent:Do_Order()
            end
        end
        self:Resume()
        self.held=false
    elseif type(task)=='function' then
        local env=self.Parent:newEvent(task)
        env:OnEvent(function(envt) envt:Pause() envt.Active=false end)
        while env.Active do
            if love then
                self.Parent:lManager()
            else
                self.Parent:Do_Order()
            end
        end
        env:Destroy()
        self:Resume()
        self.held=false
    else
        print('Error Data Type!!!')
    end
end
</code></pre>"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multi:hold</span><span class="hljs-params">(task)</span></span>
    self:Pause() <span class="hljs-comment">-- pause the current object</span>
    self.held=<span class="hljs-keyword">true</span> <span class="hljs-comment">-- set held</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(task)==<span class="hljs-string">'number'</span> <span class="hljs-keyword">then</span> <span class="hljs-comment">-- a sleep cmd</span>
        <span class="hljs-keyword">local</span> timer=multi:newTimer()
        timer:Start()
        <span class="hljs-keyword">while</span> timer:Get()&lt;task <span class="hljs-keyword">do</span> <span class="hljs-comment">-- This while loop is what makes using multiple holds tricky... If the outer while is good before the nested one then the outter one will have to wait! There is a way around this though!</span>
            <span class="hljs-keyword">if</span> love <span class="hljs-keyword">then</span>
                self.Parent:lManager()
            <span class="hljs-keyword">else</span>
                self.Parent:Do_Order()
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
        self:Resume()
        self.held=<span class="hljs-keyword">false</span>
    <span class="hljs-keyword">elseif</span> <span class="hljs-built_in">type</span>(task)==<span class="hljs-string">'function'</span> <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">local</span> env=self.Parent:newEvent(task)
        env:OnEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(envt)</span></span> envt:Pause() envt.Active=<span class="hljs-keyword">false</span> <span class="hljs-keyword">end</span>)
        <span class="hljs-keyword">while</span> env.Active <span class="hljs-keyword">do</span>
            <span class="hljs-keyword">if</span> love <span class="hljs-keyword">then</span>
                self.Parent:lManager()
            <span class="hljs-keyword">else</span>
                self.Parent:Do_Order()
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
        env:Destroy()
        self:Resume()
        self.held=<span class="hljs-keyword">false</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Error Data Type!!!'</span>)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><h2 id="queuer-(wip)"><a name="queuer-(wip)" href="#queuer-(wip)"></a>Queuer (WIP)</h2><p>A queuer works just like a process however objects are processed in order that they were created…</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
queue = multi:newQueuer()
queue:newAlarm(3):OnRing(function()
    print(&quot;Ring ring!!!&quot;)
end)
queue:newStep(1,10):OnStep(function(self,pos)
    print(pos)
end)
queue:newLoop(function(self,dt)
    if dt==3 then
        self:Break()
        print(&quot;Done&quot;)
    end
end)
queue:Start()
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
queue = multi:newQueuer()
queue:newAlarm(<span class="hljs-number">3</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Ring ring!!!"</span>)
<span class="hljs-keyword">end</span>)
queue:newStep(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,pos)</span></span>
    <span class="hljs-built_in">print</span>(pos)
<span class="hljs-keyword">end</span>)
queue:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-keyword">if</span> dt==<span class="hljs-number">3</span> <span class="hljs-keyword">then</span>
        self:Break()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Done"</span>)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
queue:Start()
multi:mainloop()
</code></pre><h1 id="expected-output"><a name="expected-output" href="#expected-output"></a>Expected Output</h1><p>Note: the queuer still does not work as expected!<br><br>Ring ring!!!<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>Done<br></p><h1 id="actual-output"><a name="actual-output" href="#actual-output"></a>Actual Output</h1><p>Done<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>Ring ring!!!<br></p><h2 id="threads"><a name="threads" href="#threads"></a>Threads</h2><p>These fix the hold problem that you get with regular objects, and they work exactly the same! They even have some extra features that make them really useful.<br></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
test=multi:newThreadedProcess(&quot;main&quot;) -- you can thread processors and all Actors see note for a list of actors you can thread!
test2=multi:newThreadedProcess(&quot;main2&quot;)
count=0
test:newLoop(function(self,dt)
    count=count+1
    thread.sleep(.01)
end)
test2:newLoop(function(self,dt)
    print(&quot;Hello!&quot;)
    thread.sleep(1) -- sleep for some time
end)
-- threads take a name object then the rest as normal
step=multi:newThreadedTStep(&quot;step&quot;,1,10)
step:OnStep(function(self,p)
    print(&quot;step&quot;,p)
    thread.skip(21) -- skip n cycles
end)
step:OnEnd(function()
    print(&quot;Killing thread!&quot;)
    thread.kill() -- kill the thread
end)
loop=multi:newThreadedLoop(&quot;loop&quot;,function(self,dt)
    print(dt)
    thread.sleep(1.1)
end)
loop2=multi:newThreadedLoop(&quot;loop&quot;,function(self,dt)
    print(dt)
    thread.hold(function() return count&amp;gt;=100 end)
    print(&quot;Count is &quot;..count)
    os.exit()
end)
alarm=multi:newThreadedAlarm(&quot;alarm&quot;,1)
alarm:OnRing(function(self)
    print(&quot;Ring&quot;)
    self:Reset()
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
test=multi:newThreadedProcess(<span class="hljs-string">"main"</span>) <span class="hljs-comment">-- you can thread processors and all Actors see note for a list of actors you can thread!</span>
test2=multi:newThreadedProcess(<span class="hljs-string">"main2"</span>)
count=<span class="hljs-number">0</span>
test:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    count=count+<span class="hljs-number">1</span>
    thread.sleep(.<span class="hljs-number">01</span>)
<span class="hljs-keyword">end</span>)
test2:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello!"</span>)
    thread.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment">-- sleep for some time</span>
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- threads take a name object then the rest as normal</span>
step=multi:newThreadedTStep(<span class="hljs-string">"step"</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)
step:OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,p)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"step"</span>,p)
    thread.skip(<span class="hljs-number">21</span>) <span class="hljs-comment">-- skip n cycles</span>
<span class="hljs-keyword">end</span>)
step:OnEnd(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Killing thread!"</span>)
    thread.kill() <span class="hljs-comment">-- kill the thread</span>
<span class="hljs-keyword">end</span>)
loop=multi:newThreadedLoop(<span class="hljs-string">"loop"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-built_in">print</span>(dt)
    thread.sleep(<span class="hljs-number">1.1</span>)
<span class="hljs-keyword">end</span>)
loop2=multi:newThreadedLoop(<span class="hljs-string">"loop"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-built_in">print</span>(dt)
    thread.hold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> count&gt;=<span class="hljs-number">100</span> <span class="hljs-keyword">end</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Count is "</span>..count)
    <span class="hljs-built_in">os</span>.exit()
<span class="hljs-keyword">end</span>)
alarm=multi:newThreadedAlarm(<span class="hljs-string">"alarm"</span>,<span class="hljs-number">1</span>)
alarm:OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Ring"</span>)
    self:Reset()
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Ring<br><br>0.992<br><br>0.992<br><br>Hello!<br><br>step    1<br><br>step    2<br><br>Hello!<br><br>Ring<br><br>2.092<br><br>step    3<br><br>Hello!<br><br>Ring<br><br>Count is 100<br></p><h2 id="threadable-actors"><a name="threadable-actors" href="#threadable-actors"></a>Threadable Actors</h2><ul>
<li>Alarms</li><li>Events</li><li>Loop/TLoop</li><li>Process</li><li>Step/TStep</li></ul><h2 id="functions"><a name="functions" href="#functions"></a>Functions</h2><p>If you ever wanted to pause a function then great now you can<br>The uses of the Function object allows one to have a method that can run free in a sense</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
func=multi:newFunction(function(self,arg1,arg2,...)
    self:Pause()
    return arg1
end)
print(func(&quot;Hello&quot;))
print(func(&quot;Hello2&quot;)) -- returns PAUSED allows for the calling of functions that should only be called once. returns PAUSED instantly if paused
func:Resume()
print(func(&quot;Hello3&quot;))
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
func=multi:newFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,arg1,arg2,...)</span></span>
    self:Pause()
    <span class="hljs-keyword">return</span> arg1
<span class="hljs-keyword">end</span>)
<span class="hljs-built_in">print</span>(func(<span class="hljs-string">"Hello"</span>))
<span class="hljs-built_in">print</span>(func(<span class="hljs-string">"Hello2"</span>)) <span class="hljs-comment">-- returns PAUSED allows for the calling of functions that should only be called once. returns PAUSED instantly if paused</span>
func:Resume()
<span class="hljs-built_in">print</span>(func(<span class="hljs-string">"Hello3"</span>))
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Hello<br><br>PAUSED<br><br>Hello3<br></p><h2 id="threadedupdater"><a name="threadedupdater" href="#threadedupdater"></a>ThreadedUpdater</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Works the same as a regular updater!
require(&quot;multi&quot;)
multi:newThreadedUpdater(&quot;Test&quot;,10000):OnUpdate(function(self)
    print(self.pos)
end)
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- Works the same as a regular updater!</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
multi:newThreadedUpdater(<span class="hljs-string">"Test"</span>,<span class="hljs-number">10000</span>):OnUpdate(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    <span class="hljs-built_in">print</span>(self.pos)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>1<br><br>2<br><br>…<br><br>.inf<br></p><h2 id="triggers"><a name="triggers" href="#triggers"></a>Triggers</h2><p>Triggers were what I used before connections became a thing, also Function objects are a lot like triggers and can be paused as well, while triggers cannot…<br><br>They are simple to use, but in most cases you are better off using a connection<br></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
-- They work like connections but can only have one event binded to them
trig=multi:newTrigger(function(self,a,b,c,...)
    print(a,b,c,...)
end)
trig:Fire(1,2,3)
trig:Fire(1,2,3,&quot;Hello&quot;,true)
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-comment">-- They work like connections but can only have one event binded to them</span>
trig=multi:newTrigger(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,a,b,c,...)</span></span>
    <span class="hljs-built_in">print</span>(a,b,c,...)
<span class="hljs-keyword">end</span>)
trig:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
trig:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">"Hello"</span>,<span class="hljs-keyword">true</span>)
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>1    2    3<br><br>1    2    3    Hello    true<br></p><h2 id="tasks"><a name="tasks" href="#tasks"></a>Tasks</h2><p>Tasks allow you to run a block of code before the multi mainloops does it thing. Tasks still have a use, but depending on how you program they aren’t needed.<br></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
multi:newTask(function()
    print(&quot;Hi!&quot;)
end)
multi:newLoop(function(self,dt)
    print(&quot;Which came first the task or the loop?&quot;)
    self:Break()
end)
multi:newTask(function()
    print(&quot;Hello there!&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
multi:newTask(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hi!"</span>)
<span class="hljs-keyword">end</span>)
multi:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Which came first the task or the loop?"</span>)
    self:Break()
<span class="hljs-keyword">end</span>)
multi:newTask(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello there!"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Hi!<br><br>Hello there!<br><br>Which came first the task or the loop?<br></p><p>As seen in the example above the tasks were done before anything else in the mainloop! This is useful when making libraries around the multitasking features and you need things to happen in a certain order!<br></p><h2 id="jobs"><a name="jobs" href="#jobs"></a>Jobs</h2><p>Jobs were a strange feature that was created for throttling connections! When I was building a irc bot around this library I couldn’t have messages posting too fast due to restrictions. Jobs allowed functions to be added to a queue that were executed after a certain amount of time has passed</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;) -- jobs use alarms I am pondering if alarms should be added to the core or if jobs should use timers instead...
-- jobs are built into the core of the library so no need to require them
print(multi:hasJobs())
multi:setJobSpeed(1) -- set job speed to 1 second
multi:newJob(function()
    print(&quot;A job!&quot;)
end,&quot;test&quot;)

multi:newJob(function()
    print(&quot;Another job!&quot;)
    multi:removeJob(&quot;test&quot;) -- removes all jobs with name &quot;test&quot;
end,&quot;test&quot;)

multi:newJob(function()
    print(&quot;Almost done!&quot;)
end,&quot;test&quot;)

multi:newJob(function()
    print(&quot;Final job!&quot;)
end,&quot;test&quot;)
print(multi:hasJobs())
print(&quot;There are &quot;..multi:getJobs()..&quot; jobs in the queue!&quot;)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>) <span class="hljs-comment">-- jobs use alarms I am pondering if alarms should be added to the core or if jobs should use timers instead...</span>
<span class="hljs-comment">-- jobs are built into the core of the library so no need to require them</span>
<span class="hljs-built_in">print</span>(multi:hasJobs())
multi:setJobSpeed(<span class="hljs-number">1</span>) <span class="hljs-comment">-- set job speed to 1 second</span>
multi:newJob(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"A job!"</span>)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"test"</span>)

multi:newJob(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Another job!"</span>)
    multi:removeJob(<span class="hljs-string">"test"</span>) <span class="hljs-comment">-- removes all jobs with name "test"</span>
<span class="hljs-keyword">end</span>,<span class="hljs-string">"test"</span>)

multi:newJob(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Almost done!"</span>)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"test"</span>)

multi:newJob(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Final job!"</span>)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"test"</span>)
<span class="hljs-built_in">print</span>(multi:hasJobs())
<span class="hljs-built_in">print</span>(<span class="hljs-string">"There are "</span>..multi:getJobs()..<span class="hljs-string">" jobs in the queue!"</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>false    0<br><br>true    4<br><br>There are 4 jobs in the queue!<br><br>A job!<br><br><br>Another job!<br></p><h2 id="watchers"><a name="watchers" href="#watchers"></a>Watchers</h2><p>Watchers allow you to monitor a variable and trigger an event when the variable has changed!</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
a=0
watcher=multi:newWatcher(_G,&quot;a&quot;) -- watch a in the global enviroment
watcher:OnValueChanged(function(self,old,new)
    print(old,new)
end)
tloop=multi:newTLoop(function(self)
    a=a+1
end,1)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
a=<span class="hljs-number">0</span>
watcher=multi:newWatcher(<span class="hljs-built_in">_G</span>,<span class="hljs-string">"a"</span>) <span class="hljs-comment">-- watch a in the global enviroment</span>
watcher:OnValueChanged(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,old,new)</span></span>
    <span class="hljs-built_in">print</span>(old,new)
<span class="hljs-keyword">end</span>)
tloop=multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    a=a+<span class="hljs-number">1</span>
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>0    1<br><br>1    2<br><br>2    3<br><br>…<br><br>.inf-1    inf<br></p><h2 id="timeout-management"><a name="timeout-management" href="#timeout-management"></a>Timeout management</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Note: I used a tloop so I could control the output of the program a bit.
require(&quot;multi&quot;)
a=0
inc=1 -- change to 0 to see it not met at all, 1 if you want to see the first condition not met but the second and 2 if you want to see it meet the condition on the first go.
loop=multi:newTLoop(function(self)
    print(&quot;Looping...&quot;)
    a=a+inc
    if a==14 then
        self:ResolveTimer(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;) -- ... any number of arguments can be passed to the resolve handler
        -- this will also automatically pause the object that it is binded to
    end
end,.1)
loop:SetTime(1)
loop:OnTimerResolved(function(self,a,b,c) -- the handler will return the self and the passed arguments
    print(&quot;We did it!&quot;,a,b,c)
end)
loop:OnTimedOut(function(self)
    if not TheSecondTry then
        print(&quot;Loop timed out!&quot;,self.Type,&quot;Trying again...&quot;)
        self:ResetTime(2)
        self:Resume()
        TheSecondTry=true
    else
        print(&quot;We just couldn't do it!&quot;) -- print if we don't get anything working
    end
end)
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- Note: I used a tloop so I could control the output of the program a bit.</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
a=<span class="hljs-number">0</span>
inc=<span class="hljs-number">1</span> <span class="hljs-comment">-- change to 0 to see it not met at all, 1 if you want to see the first condition not met but the second and 2 if you want to see it meet the condition on the first go.</span>
loop=multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Looping..."</span>)
    a=a+inc
    <span class="hljs-keyword">if</span> a==<span class="hljs-number">14</span> <span class="hljs-keyword">then</span>
        self:ResolveTimer(<span class="hljs-string">"1"</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"3"</span>) <span class="hljs-comment">-- ... any number of arguments can be passed to the resolve handler</span>
        <span class="hljs-comment">-- this will also automatically pause the object that it is binded to</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>,.<span class="hljs-number">1</span>)
loop:SetTime(<span class="hljs-number">1</span>)
loop:OnTimerResolved(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,a,b,c)</span></span> <span class="hljs-comment">-- the handler will return the self and the passed arguments</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"We did it!"</span>,a,b,c)
<span class="hljs-keyword">end</span>)
loop:OnTimedOut(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> TheSecondTry <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Loop timed out!"</span>,self.Type,<span class="hljs-string">"Trying again..."</span>)
        self:ResetTime(<span class="hljs-number">2</span>)
        self:Resume()
        TheSecondTry=<span class="hljs-keyword">true</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"We just couldn't do it!"</span>) <span class="hljs-comment">-- print if we don't get anything working</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="output-(change-the-value-inc-as-indicated-in-the-comment-to-see-the-outcomes!)"><a name="output-(change-the-value-inc-as-indicated-in-the-comment-to-see-the-outcomes!)" href="#output-(change-the-value-inc-as-indicated-in-the-comment-to-see-the-outcomes!)"></a>Output (Change the value inc as indicated in the comment to see the outcomes!)</h1><p>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Loop timed out!    tloop    Trying again…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>We did it!    1    2    3<br></p><h2 id="changes"><a name="changes" href="#changes"></a>Changes</h2><h2 id="updated-from-1.8.3-to-1.8.4"><a name="updated-from-1.8.3-to-1.8.4" href="#updated-from-1.8.3-to-1.8.4"></a>Updated from 1.8.3 to 1.8.4</h2><p>Added:</p><ul>
<li>multi:newSystemThreadedJobQueue()</li><li>Improved stability of the library</li><li>Fixed a bug that made the benchmark and getload commands non-thread(coroutine) safe</li><li>Tweaked the loveManager to help improve idle cpu usage</li><li>Minor tweaks to the coroutine scheduling</li></ul><h1 id="using-multi:newsystemthreadedjobqueue()"><a name="using-multi:newsystemthreadedjobqueue()" href="#using-multi:newsystemthreadedjobqueue()"></a>Using multi:newSystemThreadedJobQueue()</h1><p>First you need to create the object<br>This works the same way as love2d as it does with lanes… It is getting increasing harder to make both work the same way with speed in mind… Anyway…</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Creating the object using lanes manager to show case this. Examples has the file for love2d
local GLOBAL,sThread=require(&quot;multi.integration.lanesManager&quot;).init()
jQueue=multi:newSystemThreadedJobQueue(n) -- this internally creates System threads. By defualt it will use the # of processors on your system You can set this number though.
-- Only create 1 jobqueue! For now making more than 1 is buggy. You only really need one though. Just register new functions if you want 1 queue to do more. The one reason though is keeping track of jobIDs. I have an idea that I will roll out in the next update.
jQueue:registerJob(&quot;TEST_JOB&quot;,function(a,s)
    math.randomseed(s)
    -- We will push a random #
    TEST_JOB2() -- You can call other registered functions as well!
    return math.random(0,255) -- send the result to the main thread
end)
jQueue:registerJob(&quot;TEST_JOB2&quot;,function()
    print(&quot;Test Works!&quot;) -- this is called from the job since it is registered on the same queue
end)
tableOfOrder={} -- This is how we will keep order of our completed jobs. There is no guarantee that the order will be correct
jQueue.OnJobCompleted(function(JOBID,n) -- whenever a job is completed you hook to the event that is called. This passes the JOBID folled by the returns of the job
    -- JOBID is the completed job, starts at 1 and counts up by 1.
    -- Threads finish at different times so jobids may be passed out of order! Be sure to have a way to order them
    tableOfOrder[JOBID]=n -- we order ours by putting them into a table
    if #tableOfOrder==10 then
        print(&quot;We got all of the pieces!&quot;)
    end
end)
-- Lets push the jobs now
for i=1,10 do -- Job Name of registered function, ... varargs
    jQueue:pushJob(&quot;TEST_JOB&quot;,&quot;This is a test!&quot;,math.random(1,1000000))
end
print(&quot;I pushed all of the jobs :)&quot;)
multi:mainloop() -- Start the main loop :D
</code></pre>"><span class="hljs-comment">-- Creating the object using lanes manager to show case this. Examples has the file for love2d</span>
<span class="hljs-keyword">local</span> GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
jQueue=multi:newSystemThreadedJobQueue(n) <span class="hljs-comment">-- this internally creates System threads. By defualt it will use the # of processors on your system You can set this number though.</span>
<span class="hljs-comment">-- Only create 1 jobqueue! For now making more than 1 is buggy. You only really need one though. Just register new functions if you want 1 queue to do more. The one reason though is keeping track of jobIDs. I have an idea that I will roll out in the next update.</span>
jQueue:registerJob(<span class="hljs-string">"TEST_JOB"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a,s)</span></span>
    <span class="hljs-built_in">math</span>.randomseed(s)
    <span class="hljs-comment">-- We will push a random #</span>
    TEST_JOB2() <span class="hljs-comment">-- You can call other registered functions as well!</span>
    <span class="hljs-keyword">return</span> <span class="hljs-built_in">math</span>.random(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>) <span class="hljs-comment">-- send the result to the main thread</span>
<span class="hljs-keyword">end</span>)
jQueue:registerJob(<span class="hljs-string">"TEST_JOB2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Test Works!"</span>) <span class="hljs-comment">-- this is called from the job since it is registered on the same queue</span>
<span class="hljs-keyword">end</span>)
tableOfOrder={} <span class="hljs-comment">-- This is how we will keep order of our completed jobs. There is no guarantee that the order will be correct</span>
jQueue.OnJobCompleted(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(JOBID,n)</span></span> <span class="hljs-comment">-- whenever a job is completed you hook to the event that is called. This passes the JOBID folled by the returns of the job</span>
    <span class="hljs-comment">-- JOBID is the completed job, starts at 1 and counts up by 1.</span>
    <span class="hljs-comment">-- Threads finish at different times so jobids may be passed out of order! Be sure to have a way to order them</span>
    tableOfOrder[JOBID]=n <span class="hljs-comment">-- we order ours by putting them into a table</span>
    <span class="hljs-keyword">if</span> #tableOfOrder==<span class="hljs-number">10</span> <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"We got all of the pieces!"</span>)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- Lets push the jobs now</span>
<span class="hljs-keyword">for</span> i=<span class="hljs-number">1</span>,<span class="hljs-number">10</span> <span class="hljs-keyword">do</span> <span class="hljs-comment">-- Job Name of registered function, ... varargs</span>
    jQueue:pushJob(<span class="hljs-string">"TEST_JOB"</span>,<span class="hljs-string">"This is a test!"</span>,<span class="hljs-built_in">math</span>.random(<span class="hljs-number">1</span>,<span class="hljs-number">1000000</span>))
<span class="hljs-keyword">end</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"I pushed all of the jobs :)"</span>)
multi:mainloop() <span class="hljs-comment">-- Start the main loop :D</span>
</code></pre><p>Thats it from this version!</p><h2 id="updated-from-1.8.2-to-1.8.3"><a name="updated-from-1.8.2-to-1.8.3" href="#updated-from-1.8.2-to-1.8.3"></a>Updated from 1.8.2 to 1.8.3</h2><p>Added:<br><br><strong>New Mainloop functions</strong> Below you can see the slight differences… Function overhead is not too bad in lua, but has a real difference. multi:mainloop() and multi:unprotectedMainloop() use the same algorithm yet the dedicated unprotected one is slightly faster due to having less function overhead.</p><ul>
<li>multi:mainloop()* — Bench:  16830003 Steps in 3 second(s)!</li><li>multi:protectedMainloop() — Bench:  16699308 Steps in 3 second(s)!</li><li>multi:unprotectedMainloop() — Bench:  16976627 Steps in 3 second(s)!</li><li>multi:prioritizedMainloop1() — Bench:  15007133 Steps in 3 second(s)!</li><li>multi:prioritizedMainloop2() — Bench:  15526248 Steps in 3 second(s)!</li></ul><p>* The OG mainloop function remains the same and old methods to achieve what we have with the new ones still exist</p><p>These new methods help by removing function overhead that is caused through the original mainloop function. The one downside is that you no longer have the flexiblity to change the processing during runtime.</p><p>However there is a work around! You can use processes to run multiobjs as well and use the other methods on them.</p><p>I may make a full comparison between each method and which is faster, but for now trust that the dedicated ones with less function overhead are infact faster. Not by much but still faster. :D</p><h2 id="updated-from-1.8.1-to-1.8.2"><a name="updated-from-1.8.1-to-1.8.2" href="#updated-from-1.8.1-to-1.8.2"></a>Updated from 1.8.1 to 1.8.2</h2><p>Added:<br></p><ul>
<li>multi:newsystemThreadedTable(name) NOTE: Metatables are not supported in transfers. However there is a work around obj:init() that you see does this. Take a look in the multi/integration/shared/shared.lua files to see how I did it!</li><li>Modified the GLOBAL metatable to sync before doing its tests</li><li>multi._VERSION was multi.Version, felt it would be more consistant this way… I left the old way of getting the version just incase someone has used that way. It will eventually be gone. Also multi:getVersion() will do the job just as well and keep your code nice and update related bug free!</li><li>Also everything that is included in the: multi/integration/shared/shared.lua (Which is loaded automatically) works in both lanes and love2d enviroments!</li></ul><p>The threaded table is setup just like the threaded queue.<br><br>It provids GLOBAL like features without having to write to GLOBAL!<br><br>This is useful for module creators who want to keep their data private, but also use GLOBAL like coding.<br><br>It has a few features that makes it a bit better than plain ol GLOBAL (For now…)<br>(ThreadedTable - TT for short)</p><ul>
<li>TT:waitFor(name)</li><li>TT:sync()</li><li>TT[“var”]=value</li><li>print(TT[“var”])</li></ul><p>we also have the “sync” method, this one was made for love2d because we do a syncing trick to get data in a table format. The lanes side has a sync method as well so no worries. Using indexing calls sync once and may grab your variable. This allows you to have the lanes indexing ‘like’ syntax when doing regular indexing in love2d side of the module. As of right now both sides work flawlessly! And this effect is now the GLOBAL as well<br></p><p>On GLOBALS sync is a internal method for keeping the GLOBAL table in order. You can still use sThread.waitFor(name) to wait for variables that may of may not yet exist!</p><p>Time for some examples:</p><h1 id="using-multi:newsystemthreadedtable(name)"><a name="using-multi:newsystemthreadedtable(name)" href="#using-multi:newsystemthreadedtable(name)"></a>Using multi:newSystemThreadedTable(name)</h1><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- lanes Desktop lua! NOTE: this is in lanesintergratetest6.lua in the examples folder
local GLOBAL,sThread=require(&quot;multi.integration.lanesManager&quot;).init()
test=multi:newSystemThreadedTable(&quot;YO&quot;):init()
test[&quot;test1&quot;]=&quot;lol&quot;
multi:newSystemThread(&quot;test&quot;,function()
    tab=sThread.waitFor(&quot;YO&quot;):init()
    print(tab:has(&quot;test1&quot;))
    sThread.sleep(3)
    tab[&quot;test2&quot;]=&quot;Whats so funny?&quot;
end)
multi:newThread(&quot;test2&quot;,function()
    print(test:waitFor(&quot;test2&quot;))
end)
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- lanes Desktop lua! NOTE: this is in lanesintergratetest6.lua in the examples folder</span>
<span class="hljs-keyword">local</span> GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
test=multi:newSystemThreadedTable(<span class="hljs-string">"YO"</span>):init()
test[<span class="hljs-string">"test1"</span>]=<span class="hljs-string">"lol"</span>
multi:newSystemThread(<span class="hljs-string">"test"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    tab=sThread.waitFor(<span class="hljs-string">"YO"</span>):init()
    <span class="hljs-built_in">print</span>(tab:has(<span class="hljs-string">"test1"</span>))
    sThread.sleep(<span class="hljs-number">3</span>)
    tab[<span class="hljs-string">"test2"</span>]=<span class="hljs-string">"Whats so funny?"</span>
<span class="hljs-keyword">end</span>)
multi:newThread(<span class="hljs-string">"test2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(test:waitFor(<span class="hljs-string">"test2"</span>))
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- love2d gaming lua! NOTE: this is in main4.lua in the love2d examples
require(&quot;core.Library&quot;)
GLOBAL,sThread=require(&quot;multi.integration.loveManager&quot;).init() -- load the love2d version of the lanesManager and requires the entire multi library
require(&quot;core.GuiManager&quot;)
gui.ff.Color=Color.Black
test=multi:newSystemThreadedTable(&quot;YO&quot;):init()
test[&quot;test1&quot;]=&quot;lol&quot;
multi:newSystemThread(&quot;test&quot;,function()
    tab=sThread.waitFor(&quot;YO&quot;):init()
    print(tab[&quot;test1&quot;])
    sThread.sleep(3)
    tab[&quot;test2&quot;]=&quot;Whats so funny?&quot;
end)
multi:newThread(&quot;test2&quot;,function()
    print(test:waitFor(&quot;test2&quot;))
    t.text=&quot;DONE!&quot;
end)
t=gui:newTextLabel(&quot;no done yet!&quot;,0,0,300,100)
t:centerX()
t:centerY()
</code></pre>"><span class="hljs-comment">-- love2d gaming lua! NOTE: this is in main4.lua in the love2d examples</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core.Library"</span>)
GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.loveManager"</span>).init() <span class="hljs-comment">-- load the love2d version of the lanesManager and requires the entire multi library</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core.GuiManager"</span>)
gui.ff.Color=Color.Black
test=multi:newSystemThreadedTable(<span class="hljs-string">"YO"</span>):init()
test[<span class="hljs-string">"test1"</span>]=<span class="hljs-string">"lol"</span>
multi:newSystemThread(<span class="hljs-string">"test"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    tab=sThread.waitFor(<span class="hljs-string">"YO"</span>):init()
    <span class="hljs-built_in">print</span>(tab[<span class="hljs-string">"test1"</span>])
    sThread.sleep(<span class="hljs-number">3</span>)
    tab[<span class="hljs-string">"test2"</span>]=<span class="hljs-string">"Whats so funny?"</span>
<span class="hljs-keyword">end</span>)
multi:newThread(<span class="hljs-string">"test2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(test:waitFor(<span class="hljs-string">"test2"</span>))
    t.text=<span class="hljs-string">"DONE!"</span>
<span class="hljs-keyword">end</span>)
t=gui:newTextLabel(<span class="hljs-string">"no done yet!"</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">300</span>,<span class="hljs-number">100</span>)
t:centerX()
t:centerY()
</code></pre><h2 id="updated-from-1.8.0-to-1.8.1"><a name="updated-from-1.8.0-to-1.8.1" href="#updated-from-1.8.0-to-1.8.1"></a>Updated from 1.8.0 to 1.8.1</h2><p>No real change!<br><br>Changed the structure of the library. Combined the coroutine based threads into the core!<br><br>Only compat and integrations are not part of the core and never will be by nature.<br><br>This should make the library more convient to use.<br><br>I left multi/all.lua file so if anyone had libraries/projects that used that it will still work!<br><br>Updated from 1.7.6 to 1.8.0<br> (How much thread could a thread thread if a thread could thread thread?)<br>Added:<br></p><ul>
<li>multi:newSystemThreadedQueue()</li><li>multi:systemThreadedBenchmark()</li><li>More example files</li><li>multi:canSystemThread() — true if an integration was added false otherwise (For module creation)</li><li>Fixed a few bugs in the loveManager</li></ul><h1 id="using-multi:systemthreadedbenchmark()"><a name="using-multi:systemthreadedbenchmark()" href="#using-multi:systemthreadedbenchmark()"></a>Using multi:systemThreadedBenchmark()</h1><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>package.path=&quot;?/init.lua;&quot;..package.path
local GLOBAL,sThread=require(&quot;multi.integration.lanesManager&quot;).init()
multi:systemThreadedBenchmark(3):OnBench(function(self,count)
    print(&quot;First Bench: &quot;..count)
    multi:systemThreadedBenchmark(3,&quot;All Threads: &quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">package</span>.path=<span class="hljs-string">"?/init.lua;"</span>..<span class="hljs-built_in">package</span>.path
<span class="hljs-keyword">local</span> GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
multi:systemThreadedBenchmark(<span class="hljs-number">3</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,count)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"First Bench: "</span>..count)
    multi:systemThreadedBenchmark(<span class="hljs-number">3</span>,<span class="hljs-string">"All Threads: "</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="using-multi:newsystemthreadedqueue()"><a name="using-multi:newsystemthreadedqueue()" href="#using-multi:newsystemthreadedqueue()"></a>Using multi:newSystemThreadedQueue()</h1><p>Quick Note: queues shared across multiple objects will be pulling from the same “queue” keep this in mind when coding! <del>Also the queue respects direction a push on the thread side cannot be popped on the thread side… Same goes for the mainthread!<br></del> Turns out i was wrong about this…</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- in love2d, this file will be in the same example folder as before, but is named main2.lua
require(&quot;core.Library&quot;)
GLOBAL,sThread=require(&quot;multi.integration.loveManager&quot;).init() -- load the love2d version of the lanesManager and requires the entire multi library
--IMPORTANT
-- Do not make the above local, this is the one difference that the lanesManager does not have
-- If these are local the functions will have the upvalues put into them that do not exist on the threaded side
-- You will need to ensure that the function does not refer to any upvalues in its code. It will print an error if it does though
-- Also each thread has a .1 second delay! This is used to generate a random values for each thread!
require(&quot;core.GuiManager&quot;)
gui.ff.Color=Color.Black
function multi:newSystemThreadedQueue(name) -- in love2d this will spawn a channel on both ends
    local c={}
    c.name=name
    if love then
        if love.thread then
            function c:init()
                self.chan=love.thread.getChannel(self.name)
                function self:push(v)
                    self.chan:push(v)
                end
                function self:pop()
                    return self.chan:pop()
                end
                GLOBAL[self.name]=self
                return self
            end
            return c
        else
            error(&quot;Make sure you required the love.thread module!&quot;)
        end
    else
        c.linda=lanes.linda()
        function c:push(v)
            self.linda:send(&quot;Q&quot;,v)
        end
        function c:pop()
            return ({self.linda:receive(0,&quot;Q&quot;)})[2]
        end
        function c:init()
            return self
        end
        GLOBAL[name]=c
    end
    return c
end
queue=multi:newSystemThreadedQueue(&quot;QUEUE&quot;):init()
queue:push(&quot;This is a test&quot;)
queue:push(&quot;This is a test2&quot;)
queue:push(&quot;This is a test3&quot;)
queue:push(&quot;This is a test4&quot;)
multi:newSystemThread(&quot;test2&quot;,function()
    queue=sThread.waitFor(&quot;QUEUE&quot;):init()
    data=queue:pop()
    while data do
        print(data)
        data=queue:pop()
    end
    queue:push(&quot;DONE!&quot;)
end)
multi:newThread(&quot;test!&quot;,function()
    thread.hold(function() return queue:pop() end)
    t.text=&quot;Done!&quot;
end)
t=gui:newTextLabel(&quot;no done yet!&quot;,0,0,300,100)
t:centerX()
t:centerY()
</code></pre>"><span class="hljs-comment">-- in love2d, this file will be in the same example folder as before, but is named main2.lua</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core.Library"</span>)
GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.loveManager"</span>).init() <span class="hljs-comment">-- load the love2d version of the lanesManager and requires the entire multi library</span>
<span class="hljs-comment">--IMPORTANT</span>
<span class="hljs-comment">-- Do not make the above local, this is the one difference that the lanesManager does not have</span>
<span class="hljs-comment">-- If these are local the functions will have the upvalues put into them that do not exist on the threaded side</span>
<span class="hljs-comment">-- You will need to ensure that the function does not refer to any upvalues in its code. It will print an error if it does though</span>
<span class="hljs-comment">-- Also each thread has a .1 second delay! This is used to generate a random values for each thread!</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core.GuiManager"</span>)
gui.ff.Color=Color.Black
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multi:newSystemThreadedQueue</span><span class="hljs-params">(name)</span></span> <span class="hljs-comment">-- in love2d this will spawn a channel on both ends</span>
    <span class="hljs-keyword">local</span> c={}
    c.name=name
    <span class="hljs-keyword">if</span> love <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">if</span> love.thread <span class="hljs-keyword">then</span>
            <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c:init</span><span class="hljs-params">()</span></span>
                self.chan=love.thread.getChannel(self.name)
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">self:push</span><span class="hljs-params">(v)</span></span>
                    self.chan:push(v)
                <span class="hljs-keyword">end</span>
                <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">self:pop</span><span class="hljs-params">()</span></span>
                    <span class="hljs-keyword">return</span> self.chan:pop()
                <span class="hljs-keyword">end</span>
                GLOBAL[self.name]=self
                <span class="hljs-keyword">return</span> self
            <span class="hljs-keyword">end</span>
            <span class="hljs-keyword">return</span> c
        <span class="hljs-keyword">else</span>
            <span class="hljs-built_in">error</span>(<span class="hljs-string">"Make sure you required the love.thread module!"</span>)
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">else</span>
        c.linda=lanes.linda()
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c:push</span><span class="hljs-params">(v)</span></span>
            self.linda:send(<span class="hljs-string">"Q"</span>,v)
        <span class="hljs-keyword">end</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c:pop</span><span class="hljs-params">()</span></span>
            <span class="hljs-keyword">return</span> ({self.linda:receive(<span class="hljs-number">0</span>,<span class="hljs-string">"Q"</span>)})[<span class="hljs-number">2</span>]
        <span class="hljs-keyword">end</span>
        <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">c:init</span><span class="hljs-params">()</span></span>
            <span class="hljs-keyword">return</span> self
        <span class="hljs-keyword">end</span>
        GLOBAL[name]=c
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> c
<span class="hljs-keyword">end</span>
queue=multi:newSystemThreadedQueue(<span class="hljs-string">"QUEUE"</span>):init()
queue:push(<span class="hljs-string">"This is a test"</span>)
queue:push(<span class="hljs-string">"This is a test2"</span>)
queue:push(<span class="hljs-string">"This is a test3"</span>)
queue:push(<span class="hljs-string">"This is a test4"</span>)
multi:newSystemThread(<span class="hljs-string">"test2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    queue=sThread.waitFor(<span class="hljs-string">"QUEUE"</span>):init()
    data=queue:pop()
    <span class="hljs-keyword">while</span> data <span class="hljs-keyword">do</span>
        <span class="hljs-built_in">print</span>(data)
        data=queue:pop()
    <span class="hljs-keyword">end</span>
    queue:push(<span class="hljs-string">"DONE!"</span>)
<span class="hljs-keyword">end</span>)
multi:newThread(<span class="hljs-string">"test!"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    thread.hold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> queue:pop() <span class="hljs-keyword">end</span>)
    t.text=<span class="hljs-string">"Done!"</span>
<span class="hljs-keyword">end</span>)
t=gui:newTextLabel(<span class="hljs-string">"no done yet!"</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">300</span>,<span class="hljs-number">100</span>)
t:centerX()
t:centerY()
</code></pre><h1 id="in-lanes"><a name="in-lanes" href="#in-lanes"></a>In Lanes</h1><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- The code is compatible with each other, I just wanted to show different things you can do in both examples
-- This file can be found in the examples folder as lanesintegrationtest4.lua
local GLOBAL,sThread=require(&quot;multi.integration.lanesManager&quot;).init()
queue=multi:newSystemThreadedQueue(&quot;QUEUE&quot;):init()
queue:push(&quot;This is a test&quot;)
queue:push(&quot;This is a test2&quot;)
queue:push(&quot;This is a test3&quot;)
queue:push(&quot;This is a test4&quot;)
multi:newSystemThread(&quot;test2&quot;,function()
    queue=sThread.waitFor(&quot;QUEUE&quot;):init()
    data=queue:pop()
    while data do
        print(data)
        data=queue:pop()
    end
    queue:push(&quot;This is a test5&quot;)
    queue:push(&quot;This is a test6&quot;)
    queue:push(&quot;This is a test7&quot;)
    queue:push(&quot;This is a test8&quot;)
end)
multi:newThread(&quot;test!&quot;,function() -- this is a lua thread
    thread.sleep(.1)
    data=queue:pop()
    while data do
        print(data)
        data=queue:pop()
    end
end)
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- The code is compatible with each other, I just wanted to show different things you can do in both examples</span>
<span class="hljs-comment">-- This file can be found in the examples folder as lanesintegrationtest4.lua</span>
<span class="hljs-keyword">local</span> GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
queue=multi:newSystemThreadedQueue(<span class="hljs-string">"QUEUE"</span>):init()
queue:push(<span class="hljs-string">"This is a test"</span>)
queue:push(<span class="hljs-string">"This is a test2"</span>)
queue:push(<span class="hljs-string">"This is a test3"</span>)
queue:push(<span class="hljs-string">"This is a test4"</span>)
multi:newSystemThread(<span class="hljs-string">"test2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    queue=sThread.waitFor(<span class="hljs-string">"QUEUE"</span>):init()
    data=queue:pop()
    <span class="hljs-keyword">while</span> data <span class="hljs-keyword">do</span>
        <span class="hljs-built_in">print</span>(data)
        data=queue:pop()
    <span class="hljs-keyword">end</span>
    queue:push(<span class="hljs-string">"This is a test5"</span>)
    queue:push(<span class="hljs-string">"This is a test6"</span>)
    queue:push(<span class="hljs-string">"This is a test7"</span>)
    queue:push(<span class="hljs-string">"This is a test8"</span>)
<span class="hljs-keyword">end</span>)
multi:newThread(<span class="hljs-string">"test!"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- this is a lua thread</span>
    thread.sleep(.<span class="hljs-number">1</span>)
    data=queue:pop()
    <span class="hljs-keyword">while</span> data <span class="hljs-keyword">do</span>
        <span class="hljs-built_in">print</span>(data)
        data=queue:pop()
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="updated-from-1.7.5-to-1.7.6"><a name="updated-from-1.7.5-to-1.7.6" href="#updated-from-1.7.5-to-1.7.6"></a>Updated from 1.7.5 to 1.7.6</h2><p>Fixed:<br>Typos like always<br>Added:<br><br>multi:getPlatform() — returns “love2d” if using the love2d platform or returns “lanes” if using lanes for threading<br><br>examples files<br><br>In Events added method setTask(func)<br><br>The old way still works and is more convient to be honest, but I felt a method to do this was ok.<br></p><p>Updated:<br>some example files to reflect changes to the core. Changes allow for less typing<br><br>loveManager to require the compat if used so you don’t need 2 require line to retrieve the library<br></p><h2 id="updated-from-1.7.4-to-1.7.5"><a name="updated-from-1.7.4-to-1.7.5" href="#updated-from-1.7.4-to-1.7.5"></a>Updated from 1.7.4 to 1.7.5</h2><p>Fixed some typos in the readme… (I am sure there are more there are always more)<br><br>Added more features for module support<br><br>TODO:<br><br>Work on performance of the library… I see 3 places where I can make this thing run quicker<br></p><p>I’ll show case some old versions of the multitasking library eventually so you can see its changes in days past!<br></p><h2 id="updated-from-1.7.3-to-1.7.4"><a name="updated-from-1.7.3-to-1.7.4" href="#updated-from-1.7.3-to-1.7.4"></a>Updated from 1.7.3 to 1.7.4</h2><p>Added: the example folder which will be populated with more examples in the near future!<br><br>The loveManager integration that mimics the lanesManager integration almost exactly to keep coding in both enviroments as close to possible. This is done mostly for library creation support!<br><br>An example of the loveManager in action using almost the same code as the lanesintergreationtest2.lua<br><br>NOTE: This code has only been tested to work on love2d version 1.10.2 thoough it should work version 0.9.0</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;core.Library&quot;) -- Didn't add this to a repo yet! Will do eventually... Allows for injections and other cool things
require(&quot;multi.compat.love2d&quot;) -- allows for multitasking and binds my libraies to the love2d engine that i am using
GLOBAL,sThread=require(&quot;multi.integration.loveManager&quot;).init() -- load the love2d version of the lanesManager
--IMPORTANT
-- Do not make the above local, this is the one difference that the lanesManager does not have
-- If these are local the functions will have the upvalues put into them that do not exist on the threaded side
-- You will need to ensure that the function does not refer to any upvalues in its code. It will print an error if it does though
-- Also each thread has a .1 second delay! This is used to generate a random values for each thread!
require(&quot;core.GuiManager&quot;) -- allows the use of graphics in the program.
gui.ff.Color=Color.Black
function comma_value(amount)
    local formatted = amount
    while true do
        formatted, k = string.gsub(formatted, &quot;^(-?%d+)(%d%d%d)&quot;, '%1,%2')
        if (k==0) then
            break
        end
    end
    return formatted
end
multi:newSystemThread(&quot;test1&quot;,function() -- Another difference is that the multi library is already loaded in the threaded enviroment as well as a call to multi:mainloop()
    multi:benchMark(sThread.waitFor(&quot;Bench&quot;),nil,&quot;Thread 1&quot;):OnBench(function(self,c) GLOBAL[&quot;T1&quot;]=c multi:Stop() end)
end)
multi:newSystemThread(&quot;test2&quot;,function() -- spawns a thread in another lua process
    multi:benchMark(sThread.waitFor(&quot;Bench&quot;),nil,&quot;Thread 2&quot;):OnBench(function(self,c) GLOBAL[&quot;T2&quot;]=c multi:Stop() end)
end)
multi:newSystemThread(&quot;test3&quot;,function() -- spawns a thread in another lua process
    multi:benchMark(sThread.waitFor(&quot;Bench&quot;),nil,&quot;Thread 3&quot;):OnBench(function(self,c) GLOBAL[&quot;T3&quot;]=c multi:Stop() end)
end)
multi:newSystemThread(&quot;test4&quot;,function() -- spawns a thread in another lua process
    multi:benchMark(sThread.waitFor(&quot;Bench&quot;),nil,&quot;Thread 4&quot;):OnBench(function(self,c) GLOBAL[&quot;T4&quot;]=c multi:Stop() end)
end)
multi:newSystemThread(&quot;test5&quot;,function() -- spawns a thread in another lua process
    multi:benchMark(sThread.waitFor(&quot;Bench&quot;),nil,&quot;Thread 5&quot;):OnBench(function(self,c) GLOBAL[&quot;T5&quot;]=c multi:Stop() end)
end)
multi:newSystemThread(&quot;test6&quot;,function() -- spawns a thread in another lua process
    multi:benchMark(sThread.waitFor(&quot;Bench&quot;),nil,&quot;Thread 6&quot;):OnBench(function(self,c) GLOBAL[&quot;T6&quot;]=c multi:Stop() end)
end)
multi:newSystemThread(&quot;Combiner&quot;,function() -- spawns a thread in another lua process
    function comma_value(amount)
        local formatted = amount
        while true do
            formatted, k = string.gsub(formatted, &quot;^(-?%d+)(%d%d%d)&quot;, '%1,%2')
            if (k==0) then
                break
            end
        end
        return formatted
    end
    local b=comma_value(tostring(sThread.waitFor(&quot;T1&quot;)+sThread.waitFor(&quot;T2&quot;)+sThread.waitFor(&quot;T3&quot;)+sThread.waitFor(&quot;T4&quot;)+sThread.waitFor(&quot;T5&quot;)+sThread.waitFor(&quot;T6&quot;)))
    GLOBAL[&quot;DONE&quot;]=b
end)
multi:newThread(&quot;test0&quot;,function()
    -- sThread.waitFor(&quot;DONE&quot;) -- lets hold the main thread completely so we don't eat up cpu
    -- os.exit()
    -- when the main thread is holding there is a chance that error handling on the system threads may not work!
    -- instead we can do this
    while true do
        thread.skip(1) -- allow error handling to take place... Otherwise lets keep the main thread running on the low
        -- Before we held just because we could... But this is a game and we need to have logic continue
        --sThreadM.sleep(.001) -- Sleeping for .001 is a greeat way to keep cpu usage down. Make sure if you aren't doing work to rest. Abuse the hell out of GLOBAL if you need to :P
        if GLOBAL[&quot;DONE&quot;] then
            t.text=&quot;Bench: &quot;..GLOBAL[&quot;DONE&quot;]
        end
    end
end)
GLOBAL[&quot;Bench&quot;]=3
t=gui:newTextLabel(&quot;no done yet!&quot;,0,0,300,100)
t:centerX()
t:centerY()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"core.Library"</span>) <span class="hljs-comment">-- Didn't add this to a repo yet! Will do eventually... Allows for injections and other cool things</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.compat.love2d"</span>) <span class="hljs-comment">-- allows for multitasking and binds my libraies to the love2d engine that i am using</span>
GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.loveManager"</span>).init() <span class="hljs-comment">-- load the love2d version of the lanesManager</span>
<span class="hljs-comment">--IMPORTANT</span>
<span class="hljs-comment">-- Do not make the above local, this is the one difference that the lanesManager does not have</span>
<span class="hljs-comment">-- If these are local the functions will have the upvalues put into them that do not exist on the threaded side</span>
<span class="hljs-comment">-- You will need to ensure that the function does not refer to any upvalues in its code. It will print an error if it does though</span>
<span class="hljs-comment">-- Also each thread has a .1 second delay! This is used to generate a random values for each thread!</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"core.GuiManager"</span>) <span class="hljs-comment">-- allows the use of graphics in the program.</span>
gui.ff.Color=Color.Black
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">comma_value</span><span class="hljs-params">(amount)</span></span>
    <span class="hljs-keyword">local</span> formatted = amount
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">do</span>
        formatted, k = <span class="hljs-built_in">string</span>.gsub(formatted, <span class="hljs-string">"^(-?%d+)(%d%d%d)"</span>, <span class="hljs-string">'%1,%2'</span>)
        <span class="hljs-keyword">if</span> (k==<span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>
            <span class="hljs-keyword">break</span>
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">return</span> formatted
<span class="hljs-keyword">end</span>
multi:newSystemThread(<span class="hljs-string">"test1"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- Another difference is that the multi library is already loaded in the threaded enviroment as well as a call to multi:mainloop()</span>
    multi:benchMark(sThread.waitFor(<span class="hljs-string">"Bench"</span>),<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Thread 1"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,c)</span></span> GLOBAL[<span class="hljs-string">"T1"</span>]=c multi:Stop() <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"test2"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    multi:benchMark(sThread.waitFor(<span class="hljs-string">"Bench"</span>),<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Thread 2"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,c)</span></span> GLOBAL[<span class="hljs-string">"T2"</span>]=c multi:Stop() <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"test3"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    multi:benchMark(sThread.waitFor(<span class="hljs-string">"Bench"</span>),<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Thread 3"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,c)</span></span> GLOBAL[<span class="hljs-string">"T3"</span>]=c multi:Stop() <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"test4"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    multi:benchMark(sThread.waitFor(<span class="hljs-string">"Bench"</span>),<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Thread 4"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,c)</span></span> GLOBAL[<span class="hljs-string">"T4"</span>]=c multi:Stop() <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"test5"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    multi:benchMark(sThread.waitFor(<span class="hljs-string">"Bench"</span>),<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Thread 5"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,c)</span></span> GLOBAL[<span class="hljs-string">"T5"</span>]=c multi:Stop() <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"test6"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    multi:benchMark(sThread.waitFor(<span class="hljs-string">"Bench"</span>),<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Thread 6"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,c)</span></span> GLOBAL[<span class="hljs-string">"T6"</span>]=c multi:Stop() <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"Combiner"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">comma_value</span><span class="hljs-params">(amount)</span></span>
        <span class="hljs-keyword">local</span> formatted = amount
        <span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">do</span>
            formatted, k = <span class="hljs-built_in">string</span>.gsub(formatted, <span class="hljs-string">"^(-?%d+)(%d%d%d)"</span>, <span class="hljs-string">'%1,%2'</span>)
            <span class="hljs-keyword">if</span> (k==<span class="hljs-number">0</span>) <span class="hljs-keyword">then</span>
                <span class="hljs-keyword">break</span>
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">return</span> formatted
    <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">local</span> b=comma_value(<span class="hljs-built_in">tostring</span>(sThread.waitFor(<span class="hljs-string">"T1"</span>)+sThread.waitFor(<span class="hljs-string">"T2"</span>)+sThread.waitFor(<span class="hljs-string">"T3"</span>)+sThread.waitFor(<span class="hljs-string">"T4"</span>)+sThread.waitFor(<span class="hljs-string">"T5"</span>)+sThread.waitFor(<span class="hljs-string">"T6"</span>)))
    GLOBAL[<span class="hljs-string">"DONE"</span>]=b
<span class="hljs-keyword">end</span>)
multi:newThread(<span class="hljs-string">"test0"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-comment">-- sThread.waitFor("DONE") -- lets hold the main thread completely so we don't eat up cpu</span>
    <span class="hljs-comment">-- os.exit()</span>
    <span class="hljs-comment">-- when the main thread is holding there is a chance that error handling on the system threads may not work!</span>
    <span class="hljs-comment">-- instead we can do this</span>
    <span class="hljs-keyword">while</span> <span class="hljs-keyword">true</span> <span class="hljs-keyword">do</span>
        thread.skip(<span class="hljs-number">1</span>) <span class="hljs-comment">-- allow error handling to take place... Otherwise lets keep the main thread running on the low</span>
        <span class="hljs-comment">-- Before we held just because we could... But this is a game and we need to have logic continue</span>
        <span class="hljs-comment">--sThreadM.sleep(.001) -- Sleeping for .001 is a greeat way to keep cpu usage down. Make sure if you aren't doing work to rest. Abuse the hell out of GLOBAL if you need to :P</span>
        <span class="hljs-keyword">if</span> GLOBAL[<span class="hljs-string">"DONE"</span>] <span class="hljs-keyword">then</span>
            t.text=<span class="hljs-string">"Bench: "</span>..GLOBAL[<span class="hljs-string">"DONE"</span>]
        <span class="hljs-keyword">end</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
GLOBAL[<span class="hljs-string">"Bench"</span>]=<span class="hljs-number">3</span>
t=gui:newTextLabel(<span class="hljs-string">"no done yet!"</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">300</span>,<span class="hljs-number">100</span>)
t:centerX()
t:centerY()
</code></pre><h2 id="updated-from-1.7.2-to-1.7.3"><a name="updated-from-1.7.2-to-1.7.3" href="#updated-from-1.7.2-to-1.7.3"></a>Updated from 1.7.2 to 1.7.3</h2><p>Changed how requiring the library works!<br><code>require("multi.all")</code> Will still work as expected; however, with the exception of threading, compat, and integrations everything else has been moved into the core of the library.</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- This means that these are no longer required and will cause an error if done so
require(&quot;multi.loop&quot;)
require(&quot;multi.alarm&quot;)
require(&quot;multi.updater&quot;)
require(&quot;multi.tloop&quot;)
require(&quot;multi.watcher&quot;)
require(&quot;multi.tstep&quot;)
require(&quot;multi.step&quot;)
require(&quot;multi.task&quot;)
-- ^ they are all part of the core now
</code></pre>"><span class="hljs-comment">-- This means that these are no longer required and will cause an error if done so</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.loop"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.alarm"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.updater"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.tloop"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.watcher"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.tstep"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.step"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.task"</span>)
<span class="hljs-comment">-- ^ they are all part of the core now</span>
</code></pre><h2 id="updated-from-1.7.1-to-1.7.2"><a name="updated-from-1.7.1-to-1.7.2" href="#updated-from-1.7.1-to-1.7.2"></a>Updated from 1.7.1 to 1.7.2</h2><p>Moved updaters, loops, and alarms into the init.lua file. I consider them core features and they are referenced in the init.lua file so they need to exist there. Threaded versions are still separate though. Added another example file</p><h2 id="updated-from-1.7.0-to-1.7.1-bug-fixes-only"><a name="updated-from-1.7.0-to-1.7.1-bug-fixes-only" href="#updated-from-1.7.0-to-1.7.1-bug-fixes-only"></a>Updated from 1.7.0 to 1.7.1 Bug fixes only</h2><h2 id="updated-from-1.6.0-to-1.7.0"><a name="updated-from-1.6.0-to-1.7.0" href="#updated-from-1.6.0-to-1.7.0"></a>Updated from 1.6.0 to 1.7.0</h2><p>Modified: multi.integration.lanesManager.lua<br>It is now in a stable and simple state Works with the latest lanes version! Tested with version 3.11 I cannot promise that everything will work with eariler versions. Future versions are good though.<br><br>Example Usage:<br><br>sThread is a handle to a global interface for system threads to interact with themself<br><br>thread is the interface for multithreads as seen in the threading section<br></p><p>GLOBAL a table that can be used throughout each and every thread</p><p>sThreads have a few methods<br><br>sThread.set(name,val) — you can use the GLOBAL table instead modifies the same table anyway<br><br>sThread.get(name) — you can use the GLOBAL table instead modifies the same table anyway<br><br>sThread.waitFor(name) — waits until a value exists, if it does it returns it<br><br>sThread.getCores() — returns the number of cores on your cpu<br><br>sThread.sleep(n) — sleeps for a bit stopping the entire thread from running<br><br>sThread.hold(n) — sleeps until a condition is met<br></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>local GLOBAL,sThread=require(&quot;multi.integration.lanesManager&quot;).init()
require(&quot;multi.all&quot;)
multi:newAlarm(2):OnRing(function(self)
    GLOBAL[&quot;NumOfCores&quot;]=sThread.getCores()
end)
multi:newAlarm(7):OnRing(function(self)
    GLOBAL[&quot;AnotherTest&quot;]=true
end)
multi:newAlarm(13):OnRing(function(self)
    GLOBAL[&quot;FinalTest&quot;]=true
end)
multi:newSystemThread(&quot;test&quot;,function() -- spawns a thread in another lua process
    require(&quot;multi.all&quot;) -- now you can do all of your coding with the multi library! You could even spawn more threads from here with the integration. You would need to require the interaction again though
    print(&quot;Waiting for variable: NumOfCores&quot;)
    print(&quot;Got it: &quot;,sThread.waitFor(&quot;NumOfCores&quot;))
    sThread.hold(function()
        return GLOBAL[&quot;AnotherTest&quot;] -- note this would hold the entire systemthread. Spawn a coroutine thread using multi:newThread() or multi:newThreaded...
    end)
    print(&quot;Holding works!&quot;)
    multi:newThread(&quot;tests&quot;,function()
        thread.hold(function()
            return GLOBAL[&quot;FinalTest&quot;] -- note this will not hold the entire systemthread. As seen with the TLoop constantly going!
        end)
        print(&quot;Final test works!&quot;)
        os.exit()
    end)
    local a=0
    multi:newTLoop(function()
        a=a+1
        print(a)
    end,.5)
    multi:mainloop()
end)
multi:mainloop()
</code></pre>"><span class="hljs-keyword">local</span> GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.lanesManager"</span>).init()
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.all"</span>)
multi:newAlarm(<span class="hljs-number">2</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    GLOBAL[<span class="hljs-string">"NumOfCores"</span>]=sThread.getCores()
<span class="hljs-keyword">end</span>)
multi:newAlarm(<span class="hljs-number">7</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    GLOBAL[<span class="hljs-string">"AnotherTest"</span>]=<span class="hljs-keyword">true</span>
<span class="hljs-keyword">end</span>)
multi:newAlarm(<span class="hljs-number">13</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    GLOBAL[<span class="hljs-string">"FinalTest"</span>]=<span class="hljs-keyword">true</span>
<span class="hljs-keyword">end</span>)
multi:newSystemThread(<span class="hljs-string">"test"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- spawns a thread in another lua process</span>
    <span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.all"</span>) <span class="hljs-comment">-- now you can do all of your coding with the multi library! You could even spawn more threads from here with the integration. You would need to require the interaction again though</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Waiting for variable: NumOfCores"</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Got it: "</span>,sThread.waitFor(<span class="hljs-string">"NumOfCores"</span>))
    sThread.hold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        <span class="hljs-keyword">return</span> GLOBAL[<span class="hljs-string">"AnotherTest"</span>] <span class="hljs-comment">-- note this would hold the entire systemthread. Spawn a coroutine thread using multi:newThread() or multi:newThreaded...</span>
    <span class="hljs-keyword">end</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Holding works!"</span>)
    multi:newThread(<span class="hljs-string">"tests"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        thread.hold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
            <span class="hljs-keyword">return</span> GLOBAL[<span class="hljs-string">"FinalTest"</span>] <span class="hljs-comment">-- note this will not hold the entire systemthread. As seen with the TLoop constantly going!</span>
        <span class="hljs-keyword">end</span>)
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Final test works!"</span>)
        <span class="hljs-built_in">os</span>.exit()
    <span class="hljs-keyword">end</span>)
    <span class="hljs-keyword">local</span> a=<span class="hljs-number">0</span>
    multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
        a=a+<span class="hljs-number">1</span>
        <span class="hljs-built_in">print</span>(a)
    <span class="hljs-keyword">end</span>,.<span class="hljs-number">5</span>)
    multi:mainloop()
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h2 id="updated-from-1.5.0-to-1.6.0"><a name="updated-from-1.5.0-to-1.6.0" href="#updated-from-1.5.0-to-1.6.0"></a>Updated from 1.5.0 to 1.6.0</h2><p>Changed: steps and loops</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Was
step:OnStep(function(pos,self) -- same goes for tsteps as well
    print(pos)
end)
multi:newLoop(function(dt,self)
    print(dt)
end)
-- Is now
step:OnStep(function(self,pos) -- same goes for tsteps as well
    print(pos)
end)
multi:newLoop(function(self,dt)
    print(dt)
end)
</code></pre>"><span class="hljs-comment">-- Was</span>
step:OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(pos,self)</span></span> <span class="hljs-comment">-- same goes for tsteps as well</span>
    <span class="hljs-built_in">print</span>(pos)
<span class="hljs-keyword">end</span>)
multi:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(dt,self)</span></span>
    <span class="hljs-built_in">print</span>(dt)
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- Is now</span>
step:OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,pos)</span></span> <span class="hljs-comment">-- same goes for tsteps as well</span>
    <span class="hljs-built_in">print</span>(pos)
<span class="hljs-keyword">end</span>)
multi:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-built_in">print</span>(dt)
<span class="hljs-keyword">end</span>)
</code></pre><p>Reasoning I wanted to keep objects consistant, but a lot of my older libraries use the old way of doing things. Therefore I added a backwards module</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi.all&quot;)
require(&quot;multi.compat.backwards[1,5,0]&quot;) -- allows for the use of features that were scrapped/changed in 1.6.0+
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.all"</span>)
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.compat.backwards[1,5,0]"</span>) <span class="hljs-comment">-- allows for the use of features that were scrapped/changed in 1.6.0+</span>
</code></pre><h2 id="updated-from-1.4.1-to-1.5.0"><a name="updated-from-1.4.1-to-1.5.0" href="#updated-from-1.4.1-to-1.5.0"></a>Updated from 1.4.1 to 1.5.0</h2><p>Added:</p><ul>
<li>An easy way to manage timeouts</li><li>Small bug fixes</li></ul><h2 id="1.4.1---first-public-release-of-the-library"><a name="1.4.1---first-public-release-of-the-library" href="#1.4.1---first-public-release-of-the-library"></a>1.4.1 - First Public release of the library</h2><p>IMPORTANT:<br><br>Every update I make aims to make things simpler more efficent and just better, but a lot of old code, which can be really big, uses a lot of older features. I know the pain of having to rewrite everything. My promise to my library users is that I will always have backwards support for older features! New ways may exist that are quicker and eaiser, but the old features/methods will be supported.<br></p><h2 id="rambling"><a name="rambling" href="#rambling"></a>Rambling</h2><p>Love2d: Sleeping reduces the cpu time making my load detection think the system is under more load, thus preventing it from sleeping… I will look into other means. As of right now it will not eat all of your cpu if threads are active. For now I suggest killing threads that aren’t needed anymore. On lanes threads at idle use 0% cpu and it is amazing. A state machine may solve what I need though. One state being idle state that sleeps and only goes into the active state if a job request or data is sent to it… after some time of not being under load it wil switch back into the idle state… We’ll see what happens.</p><p>Love2d doesn’t like to send functions through channels. By defualt it does not support this. I achieve this by dumping the function and loadstring it on the thread. This however is slow. For the System Threaded Job Queue I had to change my original idea of sending functions as jobs. The current way you do it now is register a job functions once and then call that job across the thread through a queue. Each worker thread pops from the queue and returns the job. The Job ID is automatically updated and allows you to keep track of the order that the data comes in. A table with # indexes can be used to originze the data…</p><p>In regards to benchmarking. If you see my bench marks and are wondering they are 10x better its because I am using luajit for my tests. I highly recommend using luajit for my library, but lua 5.1 will work just as well, but not as fast.</p>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
