<!DOCTYPE html>
<html>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
  <title>README.html</title>
  <meta name="generator" content="Haroopad 0.13.1" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0">

  <style>div.oembedall-githubrepos{border:1px solid #DDD;border-radius:4px;list-style-type:none;margin:0 0 10px;padding:8px 10px 0;font:13.34px/1.4 helvetica,arial,freesans,clean,sans-serif;width:452px;background-color:#fff}div.oembedall-githubrepos .oembedall-body{background:-moz-linear-gradient(center top,#FAFAFA,#EFEFEF);background:-webkit-gradient(linear,left top,left bottom,from(#FAFAFA),to(#EFEFEF));border-bottom-left-radius:4px;border-bottom-right-radius:4px;border-top:1px solid #EEE;margin-left:-10px;margin-top:8px;padding:5px 10px;width:100%}div.oembedall-githubrepos h3{font-size:14px;margin:0;padding-left:18px;white-space:nowrap}div.oembedall-githubrepos p.oembedall-description{color:#444;font-size:12px;margin:0 0 3px}div.oembedall-githubrepos p.oembedall-updated-at{color:#888;font-size:11px;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats{border:none;float:right;font-size:11px;font-weight:700;padding-left:15px;position:relative;z-index:5;margin:0}div.oembedall-githubrepos ul.oembedall-repo-stats li{border:none;color:#666;display:inline-block;list-style-type:none;margin:0!important}div.oembedall-githubrepos ul.oembedall-repo-stats li a{background-color:transparent;border:none;color:#666!important;background-position:5px -2px;background-repeat:no-repeat;border-left:1px solid #DDD;display:inline-block;height:21px;line-height:21px;padding:0 5px 0 23px}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a{border-left:medium none;margin-right:-3px}div.oembedall-githubrepos ul.oembedall-repo-stats li a:hover{background:5px -27px no-repeat #4183C4;color:#FFF!important;text-decoration:none}div.oembedall-githubrepos ul.oembedall-repo-stats li:first-child a:hover{border-bottom-left-radius:3px;border-top-left-radius:3px}ul.oembedall-repo-stats li:last-child a:hover{border-bottom-right-radius:3px;border-top-right-radius:3px}span.oembedall-closehide{background-color:#aaa;border-radius:2px;cursor:pointer;margin-right:3px}div.oembedall-container{margin-top:5px;text-align:left}.oembedall-ljuser{font-weight:700}.oembedall-ljuser img{vertical-align:bottom;border:0;padding-right:1px}.oembedall-stoqembed{border-bottom:1px dotted #999;float:left;overflow:hidden;width:730px;line-height:1;background:#FFF;color:#000;font-family:Arial,Liberation Sans,DejaVu Sans,sans-serif;font-size:80%;text-align:left;margin:0;padding:0}.oembedall-stoqembed a{color:#07C;text-decoration:none;margin:0;padding:0}.oembedall-stoqembed a:hover{text-decoration:underline}.oembedall-stoqembed a:visited{color:#4A6B82}.oembedall-stoqembed h3{font-family:Trebuchet MS,Liberation Sans,DejaVu Sans,sans-serif;font-size:130%;font-weight:700;margin:0;padding:0}.oembedall-stoqembed .oembedall-reputation-score{color:#444;font-size:120%;font-weight:700;margin-right:2px}.oembedall-stoqembed .oembedall-user-info{height:35px;width:185px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-gravatar32{float:left;height:32px;width:32px}.oembedall-stoqembed .oembedall-user-info .oembedall-user-details{float:left;margin-left:5px;overflow:hidden;white-space:nowrap;width:145px}.oembedall-stoqembed .oembedall-question-hyperlink{font-weight:700}.oembedall-stoqembed .oembedall-stats{background:#EEE;margin:0 0 0 7px;padding:4px 7px 6px;width:58px}.oembedall-stoqembed .oembedall-statscontainer{float:left;margin-right:8px;width:86px}.oembedall-stoqembed .oembedall-votes{color:#555;padding:0 0 7px;text-align:center}.oembedall-stoqembed .oembedall-vote-count-post{font-size:240%;color:#808185;display:block;font-weight:700}.oembedall-stoqembed .oembedall-views{color:#999;padding-top:4px;text-align:center}.oembedall-stoqembed .oembedall-status{margin-top:-3px;padding:4px 0;text-align:center;background:#75845C;color:#FFF}.oembedall-stoqembed .oembedall-status strong{color:#FFF;display:block;font-size:140%}.oembedall-stoqembed .oembedall-summary{float:left;width:635px}.oembedall-stoqembed .oembedall-excerpt{line-height:1.2;margin:0;padding:0 0 5px}.oembedall-stoqembed .oembedall-tags{float:left;line-height:18px}.oembedall-stoqembed .oembedall-tags a:hover{text-decoration:none}.oembedall-stoqembed .oembedall-post-tag{background-color:#E0EAF1;border-bottom:1px solid #3E6D8E;border-right:1px solid #7F9FB6;color:#3E6D8E;font-size:90%;line-height:2.4;margin:2px 2px 2px 0;padding:3px 4px;text-decoration:none;white-space:nowrap}.oembedall-stoqembed .oembedall-post-tag:hover{background-color:#3E6D8E;border-bottom:1px solid #37607D;border-right:1px solid #37607D;color:#E0EAF1}.oembedall-stoqembed .oembedall-fr{float:right}.oembedall-stoqembed .oembedall-statsarrow{background-image:url(http://cdn.sstatic.net/stackoverflow/img/sprites.png?v=3);background-repeat:no-repeat;overflow:hidden;background-position:0 -435px;float:right;height:13px;margin-top:12px;width:7px}.oembedall-facebook1{border:1px solid #1A3C6C;padding:0;font:13.34px/1.4 verdana;width:500px}.oembedall-facebook2{background-color:#627add}.oembedall-facebook2 a{color:#e8e8e8;text-decoration:none}.oembedall-facebookBody{background-color:#fff;vertical-align:top;padding:5px}.oembedall-facebookBody .contents{display:inline-block;width:100%}.oembedall-facebookBody div img{float:left;margin-right:5px}div.oembedall-lanyard{-webkit-box-shadow:none;-webkit-transition-delay:0s;-webkit-transition-duration:.4000000059604645s;-webkit-transition-property:width;-webkit-transition-timing-function:cubic-bezier(0.42,0,.58,1);background-attachment:scroll;background-clip:border-box;background-color:transparent;background-image:none;background-origin:padding-box;border-width:0;box-shadow:none;color:#112644;display:block;float:left;font-family:'Trebuchet MS',Trebuchet,sans-serif;font-size:16px;height:253px;line-height:19px;margin:0;max-width:none;min-height:0;outline:#112644 0;overflow-x:visible;overflow-y:visible;padding:0;position:relative;text-align:left;vertical-align:baseline;width:804px}div.oembedall-lanyard .tagline{font-size:1.5em}div.oembedall-lanyard .wrapper{overflow:hidden;clear:both}div.oembedall-lanyard .split{float:left;display:inline}div.oembedall-lanyard .prominent-place .flag:active,div.oembedall-lanyard .prominent-place .flag:focus,div.oembedall-lanyard .prominent-place .flag:hover,div.oembedall-lanyard .prominent-place .flag:link,div.oembedall-lanyard .prominent-place .flag:visited{float:left;display:block;width:48px;height:48px;position:relative;top:-5px;margin-right:10px}div.oembedall-lanyard .place-context{font-size:.889em}div.oembedall-lanyard .prominent-place .sub-place{display:block}div.oembedall-lanyard .prominent-place{font-size:1.125em;line-height:1.1em;font-weight:400}div.oembedall-lanyard .main-date{color:#8CB4E0;font-weight:700;line-height:1.1}div.oembedall-lanyard .first{width:48.57%;margin:0 0 0 2.857%}.mermaid .label{color:#333}.node circle,.node polygon,.node rect{fill:#cde498;stroke:#13540c;stroke-width:1px}.edgePath .path{stroke:green;stroke-width:1.5px}.cluster rect{fill:#cdffb2;rx:40;stroke:#6eaa49;stroke-width:1px}.cluster text{fill:#333}.actor{stroke:#13540c;fill:#cde498}text.actor{fill:#000;stroke:none}.actor-line{stroke:grey}.messageLine0{stroke-width:1.5;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#333}.messageLine1{stroke-width:1.5;stroke-dasharray:"2 2";stroke:#333}#arrowhead{fill:#333}#crosshead path{fill:#333!important;stroke:#333!important}.messageText{fill:#333;stroke:none}.labelBox{stroke:#326932;fill:#cde498}.labelText,.loopText{fill:#000;stroke:none}.loopLine{stroke-width:2;stroke-dasharray:"2 2";marker-end:"url(#arrowhead)";stroke:#326932}.note{stroke:#6eaa49;fill:#fff5ad}.noteText{fill:#000;stroke:none;font-family:'trebuchet ms',verdana,arial;font-size:14px}.section{stroke:none;opacity:.2}.section0,.section2{fill:#6eaa49}.section1,.section3{fill:#fff;opacity:.2}.sectionTitle0,.sectionTitle1,.sectionTitle2,.sectionTitle3{fill:#333}.sectionTitle{text-anchor:start;font-size:11px;text-height:14px}.grid .tick{stroke:lightgrey;opacity:.3;shape-rendering:crispEdges}.grid path{stroke-width:0}.today{fill:none;stroke:red;stroke-width:2px}.task{stroke-width:2}.taskText{text-anchor:middle;font-size:11px}.taskTextOutsideRight{fill:#000;text-anchor:start;font-size:11px}.taskTextOutsideLeft{fill:#000;text-anchor:end;font-size:11px}.taskText0,.taskText1,.taskText2,.taskText3{fill:#fff}.task0,.task1,.task2,.task3{fill:#487e3a;stroke:#13540c}.taskTextOutside0,.taskTextOutside1,.taskTextOutside2,.taskTextOutside3{fill:#000}.active0,.active1,.active2,.active3{fill:#cde498;stroke:#13540c}.activeText0,.activeText1,.activeText2,.activeText3{fill:#000!important}.done0,.done1,.done2,.done3{stroke:grey;fill:lightgrey;stroke-width:2}.doneText0,.doneText1,.doneText2,.doneText3{fill:#000!important}.crit0,.crit1,.crit2,.crit3{stroke:#f88;fill:red;stroke-width:2}.activeCrit0,.activeCrit1,.activeCrit2,.activeCrit3{stroke:#f88;fill:#cde498;stroke-width:2}.doneCrit0,.doneCrit1,.doneCrit2,.doneCrit3{stroke:#f88;fill:lightgrey;stroke-width:2;cursor:pointer;shape-rendering:crispEdges}.activeCritText0,.activeCritText1,.activeCritText2,.activeCritText3,.doneCritText0,.doneCritText1,.doneCritText2,.doneCritText3{fill:#000!important}.titleText{text-anchor:middle;font-size:18px;fill:#000}text{font-family:'trebuchet ms',verdana,arial;font-size:14px}html{height:100%}body{margin:0!important;padding:5px 20px 26px!important;background-color:#fff;font-family:"Lucida Grande","Segoe UI","Apple SD Gothic Neo","Malgun Gothic","Lucida Sans Unicode",Helvetica,Arial,sans-serif;font-size:.9em;overflow-x:hidden;overflow-y:auto}br,h1,h2,h3,h4,h5,h6{clear:both}hr.page{background:url(data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAAYAAAAECAYAAACtBE5DAAAAGXRFWHRTb2Z0d2FyZQBBZG9iZSBJbWFnZVJlYWR5ccllPAAAAyJpVFh0WE1MOmNvbS5hZG9iZS54bXAAAAAAADw/eHBhY2tldCBiZWdpbj0i77u/IiBpZD0iVzVNME1wQ2VoaUh6cmVTek5UY3prYzlkIj8+IDx4OnhtcG1ldGEgeG1sbnM6eD0iYWRvYmU6bnM6bWV0YS8iIHg6eG1wdGs9IkFkb2JlIFhNUCBDb3JlIDUuMC1jMDYwIDYxLjEzNDc3NywgMjAxMC8wMi8xMi0xNzozMjowMCAgICAgICAgIj4gPHJkZjpSREYgeG1sbnM6cmRmPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5LzAyLzIyLXJkZi1zeW50YXgtbnMjIj4gPHJkZjpEZXNjcmlwdGlvbiByZGY6YWJvdXQ9IiIgeG1sbnM6eG1wPSJodHRwOi8vbnMuYWRvYmUuY29tL3hhcC8xLjAvIiB4bWxuczp4bXBNTT0iaHR0cDovL25zLmFkb2JlLmNvbS94YXAvMS4wL21tLyIgeG1sbnM6c3RSZWY9Imh0dHA6Ly9ucy5hZG9iZS5jb20veGFwLzEuMC9zVHlwZS9SZXNvdXJjZVJlZiMiIHhtcDpDcmVhdG9yVG9vbD0iQWRvYmUgUGhvdG9zaG9wIENTNSBNYWNpbnRvc2giIHhtcE1NOkluc3RhbmNlSUQ9InhtcC5paWQ6OENDRjNBN0E2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiIHhtcE1NOkRvY3VtZW50SUQ9InhtcC5kaWQ6OENDRjNBN0I2NTZBMTFFMEI3QjRBODM4NzJDMjlGNDgiPiA8eG1wTU06RGVyaXZlZEZyb20gc3RSZWY6aW5zdGFuY2VJRD0ieG1wLmlpZDo4Q0NGM0E3ODY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIgc3RSZWY6ZG9jdW1lbnRJRD0ieG1wLmRpZDo4Q0NGM0E3OTY1NkExMUUwQjdCNEE4Mzg3MkMyOUY0OCIvPiA8L3JkZjpEZXNjcmlwdGlvbj4gPC9yZGY6UkRGPiA8L3g6eG1wbWV0YT4gPD94cGFja2V0IGVuZD0iciI/PqqezsUAAAAfSURBVHjaYmRABcYwBiM2QSA4y4hNEKYDQxAEAAIMAHNGAzhkPOlYAAAAAElFTkSuQmCC) repeat-x;border:0;height:3px;padding:0}hr.underscore{border-top-style:dashed!important}body >:first-child{margin-top:0!important}img.plugin{box-shadow:0 1px 3px rgba(0,0,0,.1);border-radius:3px}iframe{border:0}figure{-webkit-margin-before:0;-webkit-margin-after:0;-webkit-margin-start:0;-webkit-margin-end:0}kbd{border:1px solid #aaa;-moz-border-radius:2px;-webkit-border-radius:2px;border-radius:2px;-moz-box-shadow:1px 2px 2px #ddd;-webkit-box-shadow:1px 2px 2px #ddd;box-shadow:1px 2px 2px #ddd;background-color:#f9f9f9;background-image:-moz-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-o-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:-webkit-linear-gradient(top,#eee,#f9f9f9,#eee);background-image:linear-gradient(top,#eee,#f9f9f9,#eee);padding:1px 3px;font-family:inherit;font-size:.85em}.oembeded .oembed_photo{display:inline-block}img[data-echo]{margin:25px 0;width:100px;height:100px;background:url(../img/ajax.gif) center center no-repeat #fff}.spinner{display:inline-block;width:10px;height:10px;margin-bottom:-.1em;border:2px solid rgba(0,0,0,.5);border-top-color:transparent;border-radius:100%;-webkit-animation:spin 1s infinite linear;animation:spin 1s infinite linear}.spinner:after{content:'';display:block;width:0;height:0;position:absolute;top:-6px;left:0;border:4px solid transparent;border-bottom-color:rgba(0,0,0,.5);-webkit-transform:rotate(45deg);transform:rotate(45deg)}@-webkit-keyframes spin{to{-webkit-transform:rotate(360deg)}}@keyframes spin{to{transform:rotate(360deg)}}p.toc{margin:0!important}p.toc ul{padding-left:10px}p.toc>ul{padding:10px;margin:0 10px;display:inline-block;border:1px solid #ededed;border-radius:5px}p.toc li,p.toc ul{list-style-type:none}p.toc li{width:100%;padding:0;overflow:hidden}p.toc li a::after{content:"."}p.toc li a:before{content:"• "}p.toc h5{text-transform:uppercase}p.toc .title{float:left;padding-right:3px}p.toc .number{margin:0;float:right;padding-left:3px;background:#fff;display:none}input.task-list-item{margin-left:-1.62em}.markdown{font-family:"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;padding:20px}.markdown a{text-decoration:none;vertical-align:baseline}.markdown a:hover{text-decoration:underline}.markdown h1{font-size:2.2em;font-weight:700;margin:1.5em 0 1em}.markdown h2{font-size:1.8em;font-weight:700;margin:1.275em 0 .85em}.markdown h3{font-size:1.6em;font-weight:700;margin:1.125em 0 .75em}.markdown h4{font-size:1.4em;font-weight:700;margin:.99em 0 .66em}.markdown h5{font-size:1.2em;font-weight:700;margin:.855em 0 .57em}.markdown h6{font-size:1em;font-weight:700;margin:.75em 0 .5em}.markdown h1+p,.markdown h1:first-child,.markdown h2+p,.markdown h2:first-child,.markdown h3+p,.markdown h3:first-child,.markdown h4+p,.markdown h4:first-child,.markdown h5+p,.markdown h5:first-child,.markdown h6+p,.markdown h6:first-child{margin-top:0}.markdown hr{border:1px solid #ccc}.markdown p{margin:1em 0;word-wrap:break-word}.markdown ol{list-style-type:decimal}.markdown li{display:list-item;line-height:1.4em}.markdown blockquote{margin:1em 20px}.markdown blockquote>:first-child{margin-top:0}.markdown blockquote>:last-child{margin-bottom:0}.markdown blockquote cite:before{content:'\2014 \00A0'}.markdown .code{border-radius:3px;word-wrap:break-word}.markdown pre{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;overflow:auto;padding:.5em}.markdown pre code{border:0;display:block}.markdown pre>code{font-family:Consolas,Inconsolata,Courier,monospace;font-weight:700;white-space:pre;margin:0}.markdown code{border-radius:3px;word-wrap:break-word;border:1px solid #ccc;padding:0 5px;margin:0 2px}.markdown img{max-width:100%}.markdown mark{color:#000;background-color:#fcf8e3}.markdown table{padding:0;border-collapse:collapse;border-spacing:0;margin-bottom:16px}.markdown table tr td,.markdown table tr th{border:1px solid #ccc;margin:0;padding:6px 13px}.markdown table tr th{font-weight:700}.markdown table tr th>:first-child{margin-top:0}.markdown table tr th>:last-child{margin-bottom:0}.markdown table tr td>:first-child{margin-top:0}.markdown table tr td>:last-child{margin-bottom:0}@import url(http://fonts.googleapis.com/css?family=Roboto+Condensed:300italic,400italic,700italic,400,300,700);.haroopad{padding:20px;color:#222;font-size:15px;font-family:"Roboto Condensed",Tauri,"Hiragino Sans GB","Microsoft YaHei",STHeiti,SimSun,"Lucida Grande","Lucida Sans Unicode","Lucida Sans",'Segoe UI',AppleSDGothicNeo-Medium,'Malgun Gothic',Verdana,Tahoma,sans-serif;background:#fff;line-height:1.6;-webkit-font-smoothing:antialiased}.haroopad a{color:#3269a0}.haroopad a:hover{color:#4183c4}.haroopad h2{border-bottom:1px solid #e6e6e6}.haroopad h6{color:#777}.haroopad hr{border:1px solid #e6e6e6}.haroopad blockquote>code,.haroopad h1>code,.haroopad h2>code,.haroopad h3>code,.haroopad h4>code,.haroopad h5>code,.haroopad h6>code,.haroopad li>code,.haroopad p>code,.haroopad td>code{font-family:Consolas,"Liberation Mono",Menlo,Courier,monospace;font-size:85%;background-color:rgba(0,0,0,.02);padding:.2em .5em;border:1px solid #efefef}.haroopad pre>code{font-size:1em;letter-spacing:-1px;font-weight:700}.haroopad blockquote{border-left:4px solid #e6e6e6;padding:0 15px;color:#777}.haroopad table{background-color:#fafafa}.haroopad table tr td,.haroopad table tr th{border:1px solid #e6e6e6}.haroopad table tr:nth-child(2n){background-color:#f2f2f2}.hljs{display:block;overflow-x:auto;padding:.5em;background:#fdf6e3;color:#657b83;-webkit-text-size-adjust:none}.diff .hljs-header,.hljs-comment,.hljs-doctype,.hljs-javadoc,.hljs-pi,.lisp .hljs-string{color:#93a1a1}.css .hljs-tag,.hljs-addition,.hljs-keyword,.hljs-request,.hljs-status,.hljs-winutils,.method,.nginx .hljs-title{color:#859900}.hljs-command,.hljs-dartdoc,.hljs-hexcolor,.hljs-link_url,.hljs-number,.hljs-phpdoc,.hljs-regexp,.hljs-rules .hljs-value,.hljs-string,.hljs-tag .hljs-value,.tex .hljs-formula{color:#2aa198}.css .hljs-function,.hljs-built_in,.hljs-chunk,.hljs-decorator,.hljs-id,.hljs-identifier,.hljs-localvars,.hljs-title,.vhdl .hljs-literal{color:#268bd2}.hljs-attribute,.hljs-class .hljs-title,.hljs-constant,.hljs-link_reference,.hljs-parent,.hljs-type,.hljs-variable,.lisp .hljs-body,.smalltalk .hljs-number{color:#b58900}.css .hljs-pseudo,.diff .hljs-change,.hljs-attr_selector,.hljs-cdata,.hljs-header,.hljs-pragma,.hljs-preprocessor,.hljs-preprocessor .hljs-keyword,.hljs-shebang,.hljs-special,.hljs-subst,.hljs-symbol,.hljs-symbol .hljs-string{color:#cb4b16}.hljs-deletion,.hljs-important{color:#dc322f}.hljs-link_label{color:#6c71c4}.tex .hljs-formula{background:#eee8d5}.MathJax_Hover_Frame{border-radius:.25em;-webkit-border-radius:.25em;-moz-border-radius:.25em;-khtml-border-radius:.25em;box-shadow:0 0 15px #83A;-webkit-box-shadow:0 0 15px #83A;-moz-box-shadow:0 0 15px #83A;-khtml-box-shadow:0 0 15px #83A;border:1px solid #A6D!important;display:inline-block;position:absolute}.MathJax_Hover_Arrow{position:absolute;width:15px;height:11px;cursor:pointer}#MathJax_About{position:fixed;left:50%;width:auto;text-align:center;border:3px outset;padding:1em 2em;background-color:#DDD;color:#000;cursor:default;font-family:message-box;font-size:120%;font-style:normal;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;border-radius:15px;-webkit-border-radius:15px;-moz-border-radius:15px;-khtml-border-radius:15px;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_Menu{position:absolute;background-color:#fff;color:#000;width:auto;padding:2px;border:1px solid #CCC;margin:0;cursor:default;font:menu;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;z-index:201;box-shadow:0 10px 20px gray;-webkit-box-shadow:0 10px 20px gray;-moz-box-shadow:0 10px 20px gray;-khtml-box-shadow:0 10px 20px gray;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}.MathJax_MenuItem{padding:2px 2em;background:0 0}.MathJax_MenuArrow{position:absolute;right:.5em;color:#666}.MathJax_MenuActive .MathJax_MenuArrow{color:#fff}.MathJax_MenuArrow.RTL{left:.5em;right:auto}.MathJax_MenuCheck{position:absolute;left:.7em}.MathJax_MenuCheck.RTL{right:.7em;left:auto}.MathJax_MenuRadioCheck{position:absolute;left:1em}.MathJax_MenuRadioCheck.RTL{right:1em;left:auto}.MathJax_MenuLabel{padding:2px 2em 4px 1.33em;font-style:italic}.MathJax_MenuRule{border-top:1px solid #CCC;margin:4px 1px 0}.MathJax_MenuDisabled{color:GrayText}.MathJax_MenuActive{background-color:Highlight;color:HighlightText}.MathJax_Menu_Close{position:absolute;width:31px;height:31px;top:-15px;left:-15px}#MathJax_Zoom{position:absolute;background-color:#F0F0F0;overflow:auto;display:block;z-index:301;padding:.5em;border:1px solid #000;margin:0;font-weight:400;font-style:normal;text-align:left;text-indent:0;text-transform:none;line-height:normal;letter-spacing:normal;word-spacing:normal;word-wrap:normal;white-space:nowrap;float:none;box-shadow:5px 5px 15px #AAA;-webkit-box-shadow:5px 5px 15px #AAA;-moz-box-shadow:5px 5px 15px #AAA;-khtml-box-shadow:5px 5px 15px #AAA;filter:progid:DXImageTransform.Microsoft.dropshadow(OffX=2, OffY=2, Color='gray', Positive='true')}#MathJax_ZoomOverlay{position:absolute;left:0;top:0;z-index:300;display:inline-block;width:100%;height:100%;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}#MathJax_ZoomFrame{position:relative;display:inline-block;height:0;width:0}#MathJax_ZoomEventTrap{position:absolute;left:0;top:0;z-index:302;display:inline-block;border:0;padding:0;margin:0;background-color:#fff;opacity:0;filter:alpha(opacity=0)}.MathJax_Preview{color:#888}#MathJax_Message{position:fixed;left:1px;bottom:2px;background-color:#E6E6E6;border:1px solid #959595;margin:0;padding:2px 8px;z-index:102;color:#000;font-size:80%;width:auto;white-space:nowrap}#MathJax_MSIE_Frame{position:absolute;top:0;left:0;width:0;z-index:101;border:0;margin:0;padding:0}.MathJax_Error{color:#C00;font-style:italic}footer{position:fixed;font-size:.8em;text-align:right;bottom:0;margin-left:-25px;height:20px;width:100%}</style>
</head>
<body class="markdown haroopad">
<h1 id="multi-version:-12.2.0-added-better-priority-management,-function-chaining,-and-some-bug-fixes"><a name="multi-version:-12.2.0-added-better-priority-management,-function-chaining,-and-some-bug-fixes" href="#multi-version:-12.2.0-added-better-priority-management,-function-chaining,-and-some-bug-fixes"></a>multi Version: 12.2.0 Added better priority management, function chaining, and some bug fixes</h1><p>My multitasking library for lua. It is a pure lua binding, if you ignore the integrations and the love2d compat. If you find any bugs or have any issues, please let me know . <strong>If you don’t see a table of contents try using the ReadMe.html file. It is easier to navigate than readme</strong><br></p><p class="toc" style="undefined"></p><ul>
<li><ul>
<li><span class="title">
<a href="#installing" title="INSTALLING">INSTALLING</a>
</span>
<!--span class="number">
0
</span-->
</li>
<li><span class="title">
<a href="#discord" title="Discord">Discord</a>
</span>
<!--span class="number">
1
</span-->
</li>
<li><span class="title">
<a href="#planned-features/todo" title="Planned features/TODO">Planned features/TODO</a>
</span>
<!--span class="number">
2
</span-->
</li>
<li><span class="title">
<a href="#known-bugs/issues" title="Known Bugs/Issues">Known Bugs/Issues</a>
</span>
<!--span class="number">
3
</span-->
</li>
<li><span class="title">
<a href="#usage:" title="Usage:">Usage:</a>
</span>
<!--span class="number">
4
</span-->
</li>
<li><span class="title">
<a href="#loops" title="LOOPS">LOOPS</a>
</span>
<!--span class="number">
5
</span-->
</li>
<li><span class="title">
<a href="#events" title="EVENTS">EVENTS</a>
</span>
<!--span class="number">
6
</span-->
</li>
<li><span class="title">
<a href="#steps" title="STEPS">STEPS</a>
</span>
<!--span class="number">
7
</span-->
</li>
<li><span class="title">
<a href="#tloops" title="TLOOPS">TLOOPS</a>
</span>
<!--span class="number">
8
</span-->
</li>
<li><span class="title">
<a href="#connections" title="Connections">Connections</a>
</span>
<!--span class="number">
9
</span-->
</li>
<li><span class="title">
<a href="#timers" title="TIMERS">TIMERS</a>
</span>
<!--span class="number">
10
</span-->
</li>
<li><span class="title">
<a href="#updater" title="UPDATER">UPDATER</a>
</span>
<!--span class="number">
11
</span-->
</li>
<li><span class="title">
<a href="#processes" title="Processes">Processes</a>
</span>
<!--span class="number">
12
</span-->
</li>
<li><span class="title">
<a href="#queuer-(wip)" title="Queuer (WIP)">Queuer (WIP)</a>
</span>
<!--span class="number">
13
</span-->
</li>
<li><span class="title">
<a href="#threads" title="Threads">Threads</a>
</span>
<!--span class="number">
14
</span-->
</li>
<li><span class="title">
<a href="#threadable-actors" title="Threadable Actors">Threadable Actors</a>
</span>
<!--span class="number">
15
</span-->
</li>
<li><span class="title">
<a href="#functions" title="Functions">Functions</a>
</span>
<!--span class="number">
16
</span-->
</li>
<li><span class="title">
<a href="#threadedupdater" title="ThreadedUpdater">ThreadedUpdater</a>
</span>
<!--span class="number">
17
</span-->
</li>
<li><span class="title">
<a href="#triggers" title="Triggers">Triggers</a>
</span>
<!--span class="number">
18
</span-->
</li>
<li><span class="title">
<a href="#tasks" title="Tasks">Tasks</a>
</span>
<!--span class="number">
19
</span-->
</li>
<li><span class="title">
<a href="#jobs" title="Jobs">Jobs</a>
</span>
<!--span class="number">
20
</span-->
</li>
<li><span class="title">
<a href="#watchers" title="Watchers">Watchers</a>
</span>
<!--span class="number">
21
</span-->
</li>
<li><span class="title">
<a href="#timeout-management" title="Timeout management">Timeout management</a>
</span>
<!--span class="number">
22
</span-->
</li>
<li><span class="title">
<a href="#rambling" title="Rambling">Rambling</a>
</span>
<!--span class="number">
23
</span-->
</li>
</ul>
</li>

</ul>
<p></p><h2 id="installing"><a name="installing" href="#installing"></a>INSTALLING</h2><p>Note: The latest version of Lua lanes is required if you want to make use of system threads on lua 5.1+. I will update the dependencies for Lua rocks since this library should work fine on lua 5.1+ You also need the lua-net library and the bin library. all installed automatically using luarocks. however you can do this manually if lanes and luasocket are installed. Links:<br><a href="https://github.com/rayaman/bin">https://github.com/rayaman/bin</a><br><a href="https://github.com/rayaman/multi">https://github.com/rayaman/multi</a><br><a href="https://github.com/rayaman/net">https://github.com/rayaman/net</a></p><p>To install copy the multi folder into your environment and you are good to go<br><br>If you want to use the system threads, then you’ll need to install lanes!<br><strong>or</strong> use luarocks</p><pre><code data-origin="<pre><code>luarocks install multi
</code></pre>">luarocks install multi
</code></pre><p>Note: Soon you may be able to run multitasking code on multiple machines, network parallelism. This however will have to wait until I hammer out some bugs within the core of system threading itself.</p><p>See the rambling section to get an idea of how this will work.</p><h2 id="discord"><a name="discord" href="#discord"></a>Discord</h2><p>For real-time assistance with my libraries! A place where you can ask questions and get help with any of my libraries. Also, you can request features and stuff there as well.<br><br><a href="https://discord.gg/U8UspuA">https://discord.gg/U8UspuA</a><br></p><p><strong>Upcoming Plans:</strong> Adding network support for threading. Kind of like your own lua cloud. This will require the bin, net, and multi library. Once that happens I will include those libraries as a set. This also means that you can expect both a standalone and joined versions of the libraries.</p><h2 id="planned-features/todo"><a name="planned-features/todo" href="#planned-features/todo"></a>Planned features/TODO</h2><ul>
<li style="list-style: none"><input type="checkbox" class="task-list-item" data-task-index="0"> Make practical examples that show how you can solve real problems</li><li style="list-style: none"><input type="checkbox" class="task-list-item" data-task-index="1"> Finish the wiki stuff. (11% done) — It’s been at 11% for so long. I really need to get on this!</li><li style="list-style: none"><input type="checkbox" class="task-list-item" data-task-index="2"> Test for unknown bugs — This is always going on</li><li style="list-style: none"><input type="checkbox" class="task-list-item" checked="" data-task-index="3"> <del>Network Parallelism</del></li></ul><h2 id="known-bugs/issues"><a name="known-bugs/issues" href="#known-bugs/issues"></a>Known Bugs/Issues</h2><p>A bug concerns the SystemThreadedJobQueue, only 1 can be used for now. Might change in a future update</p><h2 id="usage:"><a name="usage:" href="#usage:"></a>Usage:<br></h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Basic usage Alarms: Have been moved to the core of the library require(&quot;multi&quot;) would work as well
require(&quot;multi&quot;) -- gets the entire library
alarm=multi:newAlarm(3) -- in seconds can go to .001 uses the built in os.clock()
alarm:OnRing(function(a)
  print(&quot;3 Seconds have passed!&quot;)
  a:Reset(n) -- if n were nil it will reset back to 3, or it would reset to n seconds
end)
multi:mainloop() -- the main loop of the program, multi:umanager() exists as well to allow integration in other loops Ex: love2d love.update function. More on this binding in the wiki!
</code></pre>"><span class="hljs-comment">-- Basic usage Alarms: Have been moved to the core of the library require("multi") would work as well</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>) <span class="hljs-comment">-- gets the entire library</span>
alarm=multi:newAlarm(<span class="hljs-number">3</span>) <span class="hljs-comment">-- in seconds can go to .001 uses the built in os.clock()</span>
alarm:OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(a)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"3 Seconds have passed!"</span>)
  a:Reset(n) <span class="hljs-comment">-- if n were nil it will reset back to 3, or it would reset to n seconds</span>
<span class="hljs-keyword">end</span>)
multi:mainloop() <span class="hljs-comment">-- the main loop of the program, multi:umanager() exists as well to allow integration in other loops Ex: love2d love.update function. More on this binding in the wiki!</span>
</code></pre><p>The library is modular, so you only need to require what you need to. Because of this, the global environment is altered<br></p><p>There are many useful objects that you can use<br><br>Check out the wiki for detailed usage, but here are the objects:<br></p><ul>
<li>Process#<br></li><li>Queue#<br></li><li>Alarm<br></li><li>Loop<br></li><li>Event<br></li><li>Step<br></li><li>Range<br></li><li>TStep<br></li><li>TLoop<br></li><li>Condition<br></li><li>Connection<br></li><li>Timer<br></li><li>Updater<br></li><li>Thread*<br></li><li>Trigger<br></li><li>Task<br></li><li>Job<br></li><li>Function<br></li><li>Watcher<br><br>Note: <em>Both a process and queue act like the multi namespace but allows for some cool things. Because they use the other objects an example on them will be done last</em><br><br>*Uses the built in coroutine features of lua, these have an interesting interaction with the other means of multi-tasking<br><br>Triggers are kind of useless after the creation of the Connection<br><br>Watchers have no real purpose as well I made it just because.<br></li></ul><h1 id="examples-of-each-object-being-used"><a name="examples-of-each-object-being-used" href="#examples-of-each-object-being-used"></a>Examples of each object being used<br></h1><p>We already showed alarms in action so let’s move on to a Loop object</p><p>Throughout these examples I am going to do some strange things to show other features of the library!</p><h2 id="loops"><a name="loops" href="#loops"></a>LOOPS</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Loops: Have been moved to the core of the library require(&quot;multi&quot;) would work as well
require(&quot;multi&quot;) -- gets the entire library
count=0
loop=multi:newLoop(function(self,dt) -- dt is delta time and self are a reference to itself
  count=count+1
  if count &amp;gt; 10 then
    self:Break() -- All methods on the multi objects are upper camel case, whereas methods on the multi or process/queuer namespace are lower camel case
    -- self:Break() will stop the loop and trigger the OnBreak(func) method
    -- Stopping is the act of Pausing and deactivating the object! All objects can have the multiobj:Break() command on it!
  else
    print(&quot;Loop #&quot;..count..&quot;!&quot;)
  end
end)
loop:OnBreak(function(self)
  print(&quot;You broke me :(&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- Loops: Have been moved to the core of the library require("multi") would work as well</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>) <span class="hljs-comment">-- gets the entire library</span>
count=<span class="hljs-number">0</span>
loop=multi:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span> <span class="hljs-comment">-- dt is delta time and self are a reference to itself</span>
  count=count+<span class="hljs-number">1</span>
  <span class="hljs-keyword">if</span> count &gt; <span class="hljs-number">10</span> <span class="hljs-keyword">then</span>
    self:Break() <span class="hljs-comment">-- All methods on the multi objects are upper camel case, whereas methods on the multi or process/queuer namespace are lower camel case</span>
    <span class="hljs-comment">-- self:Break() will stop the loop and trigger the OnBreak(func) method</span>
    <span class="hljs-comment">-- Stopping is the act of Pausing and deactivating the object! All objects can have the multiobj:Break() command on it!</span>
  <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Loop #"</span>..count..<span class="hljs-string">"!"</span>)
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
loop:OnBreak(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"You broke me :("</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Loop #1!<br><br>Loop #2!<br><br>Loop #3!<br><br>Loop #4!<br><br>Loop #5!<br><br>Loop #6!<br><br>Loop #7!<br><br>Loop #8!<br><br>Loop #9!<br><br>Loop #10!<br><br>You broke me :(<br></p><p>With loops out of the way lets go down the line</p><p>This library aims to be Async like. Everything is still on one thread <em>unless you are using the lanes integration module WIP</em> (A stable WIP, more on that later)</p><h2 id="events"><a name="events" href="#events"></a>EVENTS</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Events, these were the first objects introduced into the library. I seldomly use them in their pure form though, but later you'll see their advance uses!
-- Events on their own don't really do much... We are going to need 2 objects at least to get something going
require(&quot;multi&quot;) -- gets the entire library
count=0
-- let’s use the loop again to add to count!
loop=multi:newLoop(function(self,dt)
  count=count+1
end)
event=multi:newEvent(function() return count==100 end) -- set the event
event:OnEvent(function(self) -- connect to the event object
  loop:Pause() -- pauses the loop from running!
  print(&quot;Stopped that loop!&quot;)
end) -- events like alarms need to be reset the Reset() command works here as well
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- Events, these were the first objects introduced into the library. I seldomly use them in their pure form though, but later you'll see their advance uses!</span>
<span class="hljs-comment">-- Events on their own don't really do much... We are going to need 2 objects at least to get something going</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>) <span class="hljs-comment">-- gets the entire library</span>
count=<span class="hljs-number">0</span>
<span class="hljs-comment">-- let’s use the loop again to add to count!</span>
loop=multi:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
  count=count+<span class="hljs-number">1</span>
<span class="hljs-keyword">end</span>)
event=multi:newEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> count==<span class="hljs-number">100</span> <span class="hljs-keyword">end</span>) <span class="hljs-comment">-- set the event</span>
event:OnEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span> <span class="hljs-comment">-- connect to the event object</span>
  loop:Pause() <span class="hljs-comment">-- pauses the loop from running!</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Stopped that loop!"</span>)
<span class="hljs-keyword">end</span>) <span class="hljs-comment">-- events like alarms need to be reset the Reset() command works here as well</span>
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Stopped that loop!</p><h2 id="steps"><a name="steps" href="#steps"></a>STEPS</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
-- Steps, are like for loops but non-blocking... You can run a loop to infinity and everything will still run I will combine Steps with Ranges in this example.
step1=multi:newStep(1,10,1,0) -- Some explaining is due. Argument 1 is the Start # Argument 2 is the ResetAt # (inclusive) Argument 3 is the count # (in our case we are counting by +1, this can be -1 but you need to adjust your start and resetAt numbers)
-- The 4th Argument is for skipping. This is useful for timing and for basic priority management. A priority management system is included!
step2=multi:newStep(10,1,-1,1) -- a second step, notice the slight changes!
step1:OnStart(function(self)
  print(&quot;Step Started!&quot;)
end)
step1:OnStep(function(self,pos)
  if pos&amp;lt;=10 then -- The step only goes to 10
    print(&quot;Stepping... &quot;..pos)
   else
    print(&quot;How did I get here?&quot;)
   end
end)
step1:OnEnd(function(self)
  print(&quot;Done!&quot;)
  -- We finished here, but I feel like we could have reused this step in some way... I could use Reset() , but what if I wanted to change it...
  if self.endAt==10 then -- lets only loop once
    self:Update(1,11,1,0) -- oh now we can reach that else condition!
  end
  -- Note Update() will restart the step!
end)

-- step2 is bored let’s give it some love :P
step2.range=step2:newRange() -- Set up a range object to have a nested step in a sense! Each nest requires a new range
-- it is in your interest not to share ranges between objects! You can however do it if it suits your needs though
step2:OnStep(function(self,pos)
  -- for 1=1,math.huge do
    --  print(&quot;I am holding the code up because I can!&quot;)
  --end
  -- We don’t want to hold things up, but we want to nest.
  -- Note a range is not necessary if the nested for loop has a small range, if however, the range is rather large you may want to allow other objects to do some work
  for i in self.range(1,100) do
    print(pos,i) -- Now our nested for loop is using a range object which allows for other objects to get some CPU time while this one is running
  end
end)
-- TSteps are just like alarms and steps mixed together, the only difference in construction is the 4th Argument. On a TStep that argument controls time. The default is 1
-- The Reset(n) works just like you would figure!
step3=multi:newTStep(1,10,.5,2) -- lets go from 1 to 10 counting by .5 every 2 seconds
step3:OnStep(function(self,pos)
  print(&quot;Ok &quot;..pos..&quot;!&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-comment">-- Steps, are like for loops but non-blocking... You can run a loop to infinity and everything will still run I will combine Steps with Ranges in this example.</span>
step1=multi:newStep(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">-- Some explaining is due. Argument 1 is the Start # Argument 2 is the ResetAt # (inclusive) Argument 3 is the count # (in our case we are counting by +1, this can be -1 but you need to adjust your start and resetAt numbers)</span>
<span class="hljs-comment">-- The 4th Argument is for skipping. This is useful for timing and for basic priority management. A priority management system is included!</span>
step2=multi:newStep(<span class="hljs-number">10</span>,<span class="hljs-number">1</span>,-<span class="hljs-number">1</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">-- a second step, notice the slight changes!</span>
step1:OnStart(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Step Started!"</span>)
<span class="hljs-keyword">end</span>)
step1:OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,pos)</span></span>
  <span class="hljs-keyword">if</span> pos&lt;=<span class="hljs-number">10</span> <span class="hljs-keyword">then</span> <span class="hljs-comment">-- The step only goes to 10</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Stepping... "</span>..pos)
   <span class="hljs-keyword">else</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"How did I get here?"</span>)
   <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
step1:OnEnd(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Done!"</span>)
  <span class="hljs-comment">-- We finished here, but I feel like we could have reused this step in some way... I could use Reset() , but what if I wanted to change it...</span>
  <span class="hljs-keyword">if</span> self.endAt==<span class="hljs-number">10</span> <span class="hljs-keyword">then</span> <span class="hljs-comment">-- lets only loop once</span>
    self:Update(<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">1</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">-- oh now we can reach that else condition!</span>
  <span class="hljs-keyword">end</span>
  <span class="hljs-comment">-- Note Update() will restart the step!</span>
<span class="hljs-keyword">end</span>)

<span class="hljs-comment">-- step2 is bored let’s give it some love :P</span>
step2.range=step2:newRange() <span class="hljs-comment">-- Set up a range object to have a nested step in a sense! Each nest requires a new range</span>
<span class="hljs-comment">-- it is in your interest not to share ranges between objects! You can however do it if it suits your needs though</span>
step2:OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,pos)</span></span>
  <span class="hljs-comment">-- for 1=1,math.huge do</span>
    <span class="hljs-comment">--  print("I am holding the code up because I can!")</span>
  <span class="hljs-comment">--end</span>
  <span class="hljs-comment">-- We don’t want to hold things up, but we want to nest.</span>
  <span class="hljs-comment">-- Note a range is not necessary if the nested for loop has a small range, if however, the range is rather large you may want to allow other objects to do some work</span>
  <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> self.range(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>) <span class="hljs-keyword">do</span>
    <span class="hljs-built_in">print</span>(pos,i) <span class="hljs-comment">-- Now our nested for loop is using a range object which allows for other objects to get some CPU time while this one is running</span>
  <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- TSteps are just like alarms and steps mixed together, the only difference in construction is the 4th Argument. On a TStep that argument controls time. The default is 1</span>
<span class="hljs-comment">-- The Reset(n) works just like you would figure!</span>
step3=multi:newTStep(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,.<span class="hljs-number">5</span>,<span class="hljs-number">2</span>) <span class="hljs-comment">-- lets go from 1 to 10 counting by .5 every 2 seconds</span>
step3:OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,pos)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Ok "</span>..pos..<span class="hljs-string">"!"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Note: the output on this one is huge!!! So, I had to … some parts! You need to run this for yourself to see what is going on!<br><br>Step Started!<br><br>Stepping… 1<br><br>10    1<br><br>Stepping… 2<br><br>10    2<br><br>Stepping… 3<br><br>10    3<br><br>…<br><br>Ok 9.5!<br><br>Ok 10!<br></p><h2 id="tloops"><a name="tloops" href="#tloops"></a>TLOOPS</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
-- TLoops are loops that run ever n second. We will also look at condition objects as well
-- Here we are going to modify the old loop to be a little different
count=0
loop=multi:newTLoop(function(self) -- We are only going to count with this loop but doing so using a condition!
  while self:condition(self.cond) do
    count=count+1
  end
  print(&quot;Count is &quot;..count..&quot;!&quot;)
  self:Destroy() -- Lets destroy this object, casting it to the dark abyss MUHAHAHA!!!
  -- the reference to this object will be a phantom object that does nothing!
end,1) -- Notice the ',1' after the function! This is where you put your time value!
loop.cond=multi:newCondition(function() return count&amp;lt;=100 end) -- conditions need a bit of work before I am happy with them
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-comment">-- TLoops are loops that run ever n second. We will also look at condition objects as well</span>
<span class="hljs-comment">-- Here we are going to modify the old loop to be a little different</span>
count=<span class="hljs-number">0</span>
loop=multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span> <span class="hljs-comment">-- We are only going to count with this loop but doing so using a condition!</span>
  <span class="hljs-keyword">while</span> self:condition(self.cond) <span class="hljs-keyword">do</span>
    count=count+<span class="hljs-number">1</span>
  <span class="hljs-keyword">end</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"Count is "</span>..count..<span class="hljs-string">"!"</span>)
  self:Destroy() <span class="hljs-comment">-- Lets destroy this object, casting it to the dark abyss MUHAHAHA!!!</span>
  <span class="hljs-comment">-- the reference to this object will be a phantom object that does nothing!</span>
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>) <span class="hljs-comment">-- Notice the ',1' after the function! This is where you put your time value!</span>
loop.cond=multi:newCondition(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> count&lt;=<span class="hljs-number">100</span> <span class="hljs-keyword">end</span>) <span class="hljs-comment">-- conditions need a bit of work before I am happy with them</span>
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Count is 101!</p><h2 id="connections"><a name="connections" href="#connections"></a>Connections</h2><p>These are my favorite objects and you’ll see why. They are very useful objects for ASync connections!</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
-- Let’s create the events
yawn={} -- ill just leave that there
OnCustomSafeEvent=multi:newConnection(true) -- lets pcall the calls in case something goes wrong default
OnCustomEvent=multi:newConnection(false) -- let’s not pcall the calls and let errors happen... We are good at coding though so let’s get a speed advantage by not pcalling. Pcalling is useful for plugins and stuff that may have been coded badly and you can ignore those connections if need be.
OnCustomEvent:Bind(yawn) -- create the connection lookup data in yawn

-- Let’s connect to them, a recent update adds a nice syntax to connect to these
cd1=OnCustomSafeEvent:Connect(function(arg1,arg2,...)
  print(&quot;CSE1&quot;,arg1,arg2,...)
end,&quot;bob&quot;) -- let’s give this connection a name
cd2=OnCustomSafeEvent:Connect(function(arg1,arg2,...)
  print(&quot;CSE2&quot;,arg1,arg2,...)
end,&quot;joe&quot;) -- let’s give this connection a name
cd3=OnCustomSafeEvent:Connect(function(arg1,arg2,...)
  print(&quot;CSE3&quot;,arg1,arg2,...)
end) -- let’s not give this connection a name

-- no need for connect, but I kept that function because of backwards compatibility.
OnCustomEvent(function(arg1,arg2,...)
  print(arg1,arg2,...)
end)

-- Now within some loop/other object you trigger the connection like
OnCustomEvent:Fire(1,2,&quot;Hello!!!&quot;) -- fire all connections

-- You may have noticed that some events have names! See the following example!
OnCustomSafeEvent:getConnection(&quot;bob&quot;):Fire(1,100,&quot;Bye!&quot;) -- fire only bob!
OnCustomSafeEvent:getConnection(&quot;joe&quot;):Fire(1,100,&quot;Hello!&quot;) -- fire only joe!!
OnCustomSafeEvent:Fire(1,100,&quot;Hi Ya Folks!!!&quot;) -- fire them all!!!

-- Connections have more to them than that though!
-- As seen above cd1-cd3 these are hooks to the connection object. This allows you to remove a connection
-- For Example:
cd1:Remove() -- remove this connection from the master connection object
print(&quot;------&quot;)
OnCustomSafeEvent:Fire(1,100,&quot;Hi Ya Folks!!!&quot;) -- fire them all again!!!
-- To remove all connections use:
OnCustomSafeEvent:Remove()
print(&quot;------&quot;)
OnCustomSafeEvent:Fire(1,100,&quot;Hi Ya Folks!!!&quot;) -- fire them all again!!!
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-comment">-- Let’s create the events</span>
yawn={} <span class="hljs-comment">-- ill just leave that there</span>
OnCustomSafeEvent=multi:newConnection(<span class="hljs-keyword">true</span>) <span class="hljs-comment">-- lets pcall the calls in case something goes wrong default</span>
OnCustomEvent=multi:newConnection(<span class="hljs-keyword">false</span>) <span class="hljs-comment">-- let’s not pcall the calls and let errors happen... We are good at coding though so let’s get a speed advantage by not pcalling. Pcalling is useful for plugins and stuff that may have been coded badly and you can ignore those connections if need be.</span>
OnCustomEvent:Bind(yawn) <span class="hljs-comment">-- create the connection lookup data in yawn</span>

<span class="hljs-comment">-- Let’s connect to them, a recent update adds a nice syntax to connect to these</span>
cd1=OnCustomSafeEvent:Connect(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1,arg2,...)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"CSE1"</span>,arg1,arg2,...)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"bob"</span>) <span class="hljs-comment">-- let’s give this connection a name</span>
cd2=OnCustomSafeEvent:Connect(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1,arg2,...)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"CSE2"</span>,arg1,arg2,...)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"joe"</span>) <span class="hljs-comment">-- let’s give this connection a name</span>
cd3=OnCustomSafeEvent:Connect(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1,arg2,...)</span></span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"CSE3"</span>,arg1,arg2,...)
<span class="hljs-keyword">end</span>) <span class="hljs-comment">-- let’s not give this connection a name</span>

<span class="hljs-comment">-- no need for connect, but I kept that function because of backwards compatibility.</span>
OnCustomEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(arg1,arg2,...)</span></span>
  <span class="hljs-built_in">print</span>(arg1,arg2,...)
<span class="hljs-keyword">end</span>)

<span class="hljs-comment">-- Now within some loop/other object you trigger the connection like</span>
OnCustomEvent:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-string">"Hello!!!"</span>) <span class="hljs-comment">-- fire all connections</span>

<span class="hljs-comment">-- You may have noticed that some events have names! See the following example!</span>
OnCustomSafeEvent:getConnection(<span class="hljs-string">"bob"</span>):Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Bye!"</span>) <span class="hljs-comment">-- fire only bob!</span>
OnCustomSafeEvent:getConnection(<span class="hljs-string">"joe"</span>):Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Hello!"</span>) <span class="hljs-comment">-- fire only joe!!</span>
OnCustomSafeEvent:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Hi Ya Folks!!!"</span>) <span class="hljs-comment">-- fire them all!!!</span>

<span class="hljs-comment">-- Connections have more to them than that though!</span>
<span class="hljs-comment">-- As seen above cd1-cd3 these are hooks to the connection object. This allows you to remove a connection</span>
<span class="hljs-comment">-- For Example:</span>
cd1:Remove() <span class="hljs-comment">-- remove this connection from the master connection object</span>
<span class="hljs-built_in">print</span>(<span class="hljs-string">"------"</span>)
OnCustomSafeEvent:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Hi Ya Folks!!!"</span>) <span class="hljs-comment">-- fire them all again!!!</span>
<span class="hljs-comment">-- To remove all connections use:</span>
OnCustomSafeEvent:Remove()
<span class="hljs-built_in">print</span>(<span class="hljs-string">"------"</span>)
OnCustomSafeEvent:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">100</span>,<span class="hljs-string">"Hi Ya Folks!!!"</span>) <span class="hljs-comment">-- fire them all again!!!</span>
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>1    2    Hello!!!<br><br>CSE1    1    100    Bye!<br><br>CSE2    1    100    Hello!<br><br>CSE1    1    100    Hi Ya Folks!!!<br><br>CSE2    1    100    Hi Ya Folks!!!<br><br>CSE3    1    100    Hi Ya Folks!!!<br><br>CSE2    1    100    Hi Ya Folks!!!<br><br>CSE3    1    100    Hi Ya Folks!!!<br><br><br></p><p>You may think timers should be bundled with alarms, but they are a bit different and have cool features<br></p><h2 id="timers"><a name="timers" href="#timers"></a>TIMERS</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- You see the thing is that all time-based objects use timers e.g. Alarms, TSteps, and Loops. Timers are more low level!
require(&quot;multi&quot;)
local clock = os.clock
function sleep(n)  -- seconds
  local t0 = clock()
  while clock() - t0 &amp;lt;= n do end
end -- we will use this later!

timer=multi:newTimer()
timer:Start()
-- let’s do a mock alarm
set=3 -- 3 seconds
a=0
while timer:Get()&amp;lt;=set do
  -- waiting...
  a=a+1
end
print(set..&quot; second(s) have passed!&quot;)
-- Timers can do one more thing that is interesting and that is pausing them!
timer:Pause()
print(timer:Get()) -- should be really close to 'set'
sleep(3)
print(timer:Get()) -- should be really close to 'set'
timer:Resume()
sleep(1)
print(timer:Get()) -- should be really close to the value of set + 1
timer:Pause()
print(timer:Get()) -- should be really close to 'set'
sleep(3)
print(timer:Get()) -- should be really close to 'set'
timer:Resume()
sleep(1)
print(timer:Get()) -- should be really close to the value of set + 2
</code></pre>"><span class="hljs-comment">-- You see the thing is that all time-based objects use timers e.g. Alarms, TSteps, and Loops. Timers are more low level!</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-keyword">local</span> clock = <span class="hljs-built_in">os</span>.clock
<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">sleep</span><span class="hljs-params">(n)</span></span>  <span class="hljs-comment">-- seconds</span>
  <span class="hljs-keyword">local</span> t0 = clock()
  <span class="hljs-keyword">while</span> clock() - t0 &lt;= n <span class="hljs-keyword">do</span> <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span> <span class="hljs-comment">-- we will use this later!</span>

timer=multi:newTimer()
timer:Start()
<span class="hljs-comment">-- let’s do a mock alarm</span>
set=<span class="hljs-number">3</span> <span class="hljs-comment">-- 3 seconds</span>
a=<span class="hljs-number">0</span>
<span class="hljs-keyword">while</span> timer:Get()&lt;=set <span class="hljs-keyword">do</span>
  <span class="hljs-comment">-- waiting...</span>
  a=a+<span class="hljs-number">1</span>
<span class="hljs-keyword">end</span>
<span class="hljs-built_in">print</span>(set..<span class="hljs-string">" second(s) have passed!"</span>)
<span class="hljs-comment">-- Timers can do one more thing that is interesting and that is pausing them!</span>
timer:Pause()
<span class="hljs-built_in">print</span>(timer:Get()) <span class="hljs-comment">-- should be really close to 'set'</span>
sleep(<span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(timer:Get()) <span class="hljs-comment">-- should be really close to 'set'</span>
timer:Resume()
sleep(<span class="hljs-number">1</span>)
<span class="hljs-built_in">print</span>(timer:Get()) <span class="hljs-comment">-- should be really close to the value of set + 1</span>
timer:Pause()
<span class="hljs-built_in">print</span>(timer:Get()) <span class="hljs-comment">-- should be really close to 'set'</span>
sleep(<span class="hljs-number">3</span>)
<span class="hljs-built_in">print</span>(timer:Get()) <span class="hljs-comment">-- should be really close to 'set'</span>
timer:Resume()
sleep(<span class="hljs-number">1</span>)
<span class="hljs-built_in">print</span>(timer:Get()) <span class="hljs-comment">-- should be really close to the value of set + 2</span>
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Note: This will make more sense when you run it for yourself<br><br>3 second(s) have passed!<br><br>3.001<br><br>3.001<br><br>4.002<br><br>4.002<br><br>4.002<br><br>5.003<br></p><h2 id="updater"><a name="updater" href="#updater"></a>UPDATER</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Updaters: Have been moved to the core of the library require(&quot;multi&quot;) would work as well
require(&quot;multi&quot;)
updater=multi:newUpdater(5) -- simple, think of a look with the skip feature of a step
updater:OnUpdate(function(self)
  --print(&quot;updating...&quot;)
end)
-- Here every 5 steps the updater will do stuff!
-- But I feel it is now time to touch into priority management, so let’s get into basic priority stuff and get into a more advance version of it
--[[
multi.Priority_Core -- Highest form of priority
multi.Priority_High
multi.Priority_Above_Normal
multi.Priority_Normal -- The default form of priority
multi.Priority_Below_Normal
multi.Priority_Low
multi.Priority_Idle -- Lowest form of priority

Note: These only take effect when you enable priority, otherwise everything is at a core like level!
We aren't going to use regular objects to test priority, but rather benchmarks!
to set priority on an object though you would do
multiobj:setPriority(one of the above)
]]
-- let’s bench for 3 seconds using the 3 forms of priority! First no Priority
multi:benchMark(3,nil,&quot;Regular Bench: &quot;):OnBench(function() -- the onbench() allows us to do each bench after each other!
  print(&quot;P1\n---------------&quot;)
  multi:enablePriority()
  multi:benchMark(3,multi.Priority_Core,&quot;Core:&quot;)
  multi:benchMark(3,multi.Priority_High,&quot;High:&quot;)
  multi:benchMark(3,multi.Priority_Above_Normal,&quot;Above_Normal:&quot;)
  multi:benchMark(3,multi.Priority_Normal,&quot;Normal:&quot;)
  multi:benchMark(3,multi.Priority_Below_Normal,&quot;Below_Normal:&quot;)
  multi:benchMark(3,multi.Priority_Low,&quot;Low:&quot;)
  multi:benchMark(3,multi.Priority_Idle,&quot;Idle:&quot;):OnBench(function()
    print(&quot;P2\n---------------&quot;)
    -- Finally, the 3rd form
    multi:enablePriority2()
    multi:benchMark(3,multi.Priority_Core,&quot;Core:&quot;)
    multi:benchMark(3,multi.Priority_High,&quot;High:&quot;)
    multi:benchMark(3,multi.Priority_Above_Normal,&quot;Above_Normal:&quot;)
    multi:benchMark(3,multi.Priority_Normal,&quot;Normal:&quot;)
    multi:benchMark(3,multi.Priority_Below_Normal,&quot;Below_Normal:&quot;)
    multi:benchMark(3,multi.Priority_Low,&quot;Low:&quot;)
    multi:benchMark(3,multi.Priority_Idle,&quot;Idle:&quot;)
  end)
end)
multi:mainloop() -- Notice how the past few examples did not need this, well only actors need to be in a loop! More on this in the wiki.
</code></pre>"><span class="hljs-comment">-- Updaters: Have been moved to the core of the library require("multi") would work as well</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
updater=multi:newUpdater(<span class="hljs-number">5</span>) <span class="hljs-comment">-- simple, think of a look with the skip feature of a step</span>
updater:OnUpdate(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
  <span class="hljs-comment">--print("updating...")</span>
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- Here every 5 steps the updater will do stuff!</span>
<span class="hljs-comment">-- But I feel it is now time to touch into priority management, so let’s get into basic priority stuff and get into a more advance version of it</span>
<span class="hljs-comment">--[[
multi.Priority_Core -- Highest form of priority
multi.Priority_High
multi.Priority_Above_Normal
multi.Priority_Normal -- The default form of priority
multi.Priority_Below_Normal
multi.Priority_Low
multi.Priority_Idle -- Lowest form of priority

Note: These only take effect when you enable priority, otherwise everything is at a core like level!
We aren't going to use regular objects to test priority, but rather benchmarks!
to set priority on an object though you would do
multiobj:setPriority(one of the above)
]]</span>
<span class="hljs-comment">-- let’s bench for 3 seconds using the 3 forms of priority! First no Priority</span>
multi:benchMark(<span class="hljs-number">3</span>,<span class="hljs-keyword">nil</span>,<span class="hljs-string">"Regular Bench: "</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-comment">-- the onbench() allows us to do each bench after each other!</span>
  <span class="hljs-built_in">print</span>(<span class="hljs-string">"P1\n---------------"</span>)
  multi:enablePriority()
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Core,<span class="hljs-string">"Core:"</span>)
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_High,<span class="hljs-string">"High:"</span>)
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Above_Normal,<span class="hljs-string">"Above_Normal:"</span>)
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Normal,<span class="hljs-string">"Normal:"</span>)
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Below_Normal,<span class="hljs-string">"Below_Normal:"</span>)
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Low,<span class="hljs-string">"Low:"</span>)
  multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Idle,<span class="hljs-string">"Idle:"</span>):OnBench(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"P2\n---------------"</span>)
    <span class="hljs-comment">-- Finally, the 3rd form</span>
    multi:enablePriority2()
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Core,<span class="hljs-string">"Core:"</span>)
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_High,<span class="hljs-string">"High:"</span>)
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Above_Normal,<span class="hljs-string">"Above_Normal:"</span>)
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Normal,<span class="hljs-string">"Normal:"</span>)
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Below_Normal,<span class="hljs-string">"Below_Normal:"</span>)
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Low,<span class="hljs-string">"Low:"</span>)
    multi:benchMark(<span class="hljs-number">3</span>,multi.Priority_Idle,<span class="hljs-string">"Idle:"</span>)
  <span class="hljs-keyword">end</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop() <span class="hljs-comment">-- Notice how the past few examples did not need this, well only actors need to be in a loop! More on this in the wiki.</span>
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Note: These numbers will vary drastically depending on your compiler and CPU power<br><br>Regular Bench:  2094137 Steps in 3 second(s)!<br><br>P1<br><br>Below_Normal: 236022 Steps in 3 second(s)!<br><br>Normal: 314697 Steps in 3 second(s)!<br><br>Above_Normal: 393372 Steps in 3 second(s)!<br><br>High: 472047 Steps in 3 second(s)!<br><br>Core: 550722 Steps in 3 second(s)!<br><br>Low: 157348 Steps in 3 second(s)!<br><br>Idle: 78674 Steps in 3 second(s)!<br><br>P2<br><br>Core: 994664 Steps in 3 second(s)!<br><br>High: 248666 Steps in 3 second(s)!<br><br>Above_Normal: 62166 Steps in 3 second(s)!<br><br>Normal: 15541 Steps in 3 second(s)!<br><br>Below_Normal: 3885 Steps in 3 second(s)!<br><br>Idle: 242 Steps in 3 second(s)!<br><br>Low: 971 Steps in 3 second(s)!<br></p><p>Notice: Even though I started each bench at the same time the order that they finished differed the order is likely to vary on your machine as well!<br></p><h2 id="processes"><a name="processes" href="#processes"></a>Processes</h2><p>A process allows you to group the Actor objects within a controllable interface</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
proc=multi:newProcess() -- takes an optional file as an argument, but for this example we aren't going to use that
-- a process works just like the multi object!
b=0
loop=proc:newTLoop(function(self)
    a=a+1
    proc:Pause() -- pauses the CPU cycler for this processor! Individual objects are not paused, however because they aren't getting CPU time they act as if they were paused
end,.1)
updater=proc:newUpdater(multi.Priority_Idle) -- priority can be used in skip arguments as well to manage priority without enabling it!
updater:OnUpdate(function(self)
    b=b+1
end)
a=0 -- a counter
loop2=proc:newLoop(function(self,dt)
    print(&quot;Let’s Go!&quot;)
    self:hold(3) -- this will keep this object from doing anything! Note: You can only have one hold active at a time! Multiple are possible, but results may not be as they seem see * for how hold works
    -- Within a process using hold will keep it alive until the hold is satisfied!
    print(&quot;Done being held for 1 second&quot;)
    self:hold(function() return a&amp;gt;10 end)
    print(&quot;A is now: &quot;..a..&quot; b is also: &quot;..b)
    self:Destroy()
    self.Parent:Pause() -- let’s say you don't have the reference to the process!
    os.exit()
end)
-- Notice this is now being created on the multi namespace
event=multi:newEvent(function() return os.clock()&amp;gt;=1 end)
event:OnEvent(function(self)
    proc:Resume()
    self:Destroy()
end)
proc:Start()
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
proc=multi:newProcess() <span class="hljs-comment">-- takes an optional file as an argument, but for this example we aren't going to use that</span>
<span class="hljs-comment">-- a process works just like the multi object!</span>
b=<span class="hljs-number">0</span>
loop=proc:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    a=a+<span class="hljs-number">1</span>
    proc:Pause() <span class="hljs-comment">-- pauses the CPU cycler for this processor! Individual objects are not paused, however because they aren't getting CPU time they act as if they were paused</span>
<span class="hljs-keyword">end</span>,.<span class="hljs-number">1</span>)
updater=proc:newUpdater(multi.Priority_Idle) <span class="hljs-comment">-- priority can be used in skip arguments as well to manage priority without enabling it!</span>
updater:OnUpdate(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    b=b+<span class="hljs-number">1</span>
<span class="hljs-keyword">end</span>)
a=<span class="hljs-number">0</span> <span class="hljs-comment">-- a counter</span>
loop2=proc:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Let’s Go!"</span>)
    self:hold(<span class="hljs-number">3</span>) <span class="hljs-comment">-- this will keep this object from doing anything! Note: You can only have one hold active at a time! Multiple are possible, but results may not be as they seem see * for how hold works</span>
    <span class="hljs-comment">-- Within a process using hold will keep it alive until the hold is satisfied!</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Done being held for 1 second"</span>)
    self:hold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> a&gt;<span class="hljs-number">10</span> <span class="hljs-keyword">end</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"A is now: "</span>..a..<span class="hljs-string">" b is also: "</span>..b)
    self:Destroy()
    self.Parent:Pause() <span class="hljs-comment">-- let’s say you don't have the reference to the process!</span>
    <span class="hljs-built_in">os</span>.exit()
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- Notice this is now being created on the multi namespace</span>
event=multi:newEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> <span class="hljs-built_in">os</span>.clock()&gt;=<span class="hljs-number">1</span> <span class="hljs-keyword">end</span>)
event:OnEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    proc:Resume()
    self:Destroy()
<span class="hljs-keyword">end</span>)
proc:Start()
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Let’s Go!<br><br>Done being held for 1 second<br><br>A is now: 29 b is also: 479<br></p><p><strong>Hold: This method works as follows</strong></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>function multi:hold(task)
    self:Pause() -- pause the current object
    self.held=true -- set held
    if type(task)=='number' then -- a sleep cmd
        local timer=multi:newTimer()
        timer:Start()
        while timer:Get()&amp;lt;task do -- This while loop is what makes using multiple holds tricky... If the outer while is good before the nested one then the outer one will have to wait! There is a way around this though!
            if love then
                self.Parent:lManager()
            else
                self.Parent:Do_Order()
            end
        end
        self:Resume()
        self.held=false
    elseif type(task)=='function' then
        local env=self.Parent:newEvent(task)
        env:OnEvent(function(envt) envt:Pause() envt.Active=false end)
        while env.Active do
            if love then
                self.Parent:lManager()
            else
                self.Parent:Do_Order()
            end
        end
        env:Destroy()
        self:Resume()
        self.held=false
    else
        print('Error Data Type!!!')
    end
end
</code></pre>"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">multi:hold</span><span class="hljs-params">(task)</span></span>
    self:Pause() <span class="hljs-comment">-- pause the current object</span>
    self.held=<span class="hljs-keyword">true</span> <span class="hljs-comment">-- set held</span>
    <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(task)==<span class="hljs-string">'number'</span> <span class="hljs-keyword">then</span> <span class="hljs-comment">-- a sleep cmd</span>
        <span class="hljs-keyword">local</span> timer=multi:newTimer()
        timer:Start()
        <span class="hljs-keyword">while</span> timer:Get()&lt;task <span class="hljs-keyword">do</span> <span class="hljs-comment">-- This while loop is what makes using multiple holds tricky... If the outer while is good before the nested one then the outer one will have to wait! There is a way around this though!</span>
            <span class="hljs-keyword">if</span> love <span class="hljs-keyword">then</span>
                self.Parent:lManager()
            <span class="hljs-keyword">else</span>
                self.Parent:Do_Order()
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
        self:Resume()
        self.held=<span class="hljs-keyword">false</span>
    <span class="hljs-keyword">elseif</span> <span class="hljs-built_in">type</span>(task)==<span class="hljs-string">'function'</span> <span class="hljs-keyword">then</span>
        <span class="hljs-keyword">local</span> env=self.Parent:newEvent(task)
        env:OnEvent(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(envt)</span></span> envt:Pause() envt.Active=<span class="hljs-keyword">false</span> <span class="hljs-keyword">end</span>)
        <span class="hljs-keyword">while</span> env.Active <span class="hljs-keyword">do</span>
            <span class="hljs-keyword">if</span> love <span class="hljs-keyword">then</span>
                self.Parent:lManager()
            <span class="hljs-keyword">else</span>
                self.Parent:Do_Order()
            <span class="hljs-keyword">end</span>
        <span class="hljs-keyword">end</span>
        env:Destroy()
        self:Resume()
        self.held=<span class="hljs-keyword">false</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">'Error Data Type!!!'</span>)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>
</code></pre><h2 id="queuer-(wip)"><a name="queuer-(wip)" href="#queuer-(wip)"></a>Queuer (WIP)</h2><p>A queuer works just like a process however objects are processed in order that they were created…</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
queue = multi:newQueuer()
queue:newAlarm(3):OnRing(function()
    print(&quot;Ring ring!!!&quot;)
end)
queue:newStep(1,10):OnStep(function(self,pos)
    print(pos)
end)
queue:newLoop(function(self,dt)
    if dt==3 then
        self:Break()
        print(&quot;Done&quot;)
    end
end)
queue:Start()
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
queue = multi:newQueuer()
queue:newAlarm(<span class="hljs-number">3</span>):OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Ring ring!!!"</span>)
<span class="hljs-keyword">end</span>)
queue:newStep(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>):OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,pos)</span></span>
    <span class="hljs-built_in">print</span>(pos)
<span class="hljs-keyword">end</span>)
queue:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-keyword">if</span> dt==<span class="hljs-number">3</span> <span class="hljs-keyword">then</span>
        self:Break()
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Done"</span>)
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
queue:Start()
multi:mainloop()
</code></pre><h1 id="expected-output"><a name="expected-output" href="#expected-output"></a>Expected Output</h1><p>Note: the queuer still does not work as expected!<br><br>Ring ring!!!<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>Done<br></p><h1 id="actual-output"><a name="actual-output" href="#actual-output"></a>Actual Output</h1><p>Done<br><br>1<br><br>2<br><br>3<br><br>4<br><br>5<br><br>6<br><br>7<br><br>8<br><br>9<br><br>10<br><br>Ring ring!!!<br></p><h2 id="threads"><a name="threads" href="#threads"></a>Threads</h2><p>These fix the hold problem that you get with regular objects, and they work the same! They even have some extra features that make them really useful.<br></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
test=multi:newThreadedProcess(&quot;main&quot;) -- you can thread processors and all Actors see note for a list of actors you can thread!
test2=multi:newThreadedProcess(&quot;main2&quot;)
count=0
test:newLoop(function(self,dt)
    count=count+1
    thread.sleep(.01)
end)
test2:newLoop(function(self,dt)
    print(&quot;Hello!&quot;)
    thread.sleep(1) -- sleep for some time
end)
-- threads take a name object then the rest as normal
step=multi:newThreadedTStep(&quot;step&quot;,1,10)
step:OnStep(function(self,p)
    print(&quot;step&quot;,p)
    thread.skip(21) -- skip n cycles
end)
step:OnEnd(function()
    print(&quot;Killing thread!&quot;)
    thread.kill() -- kill the thread
end)
loop=multi:newThreadedLoop(&quot;loop&quot;,function(self,dt)
    print(dt)
    thread.sleep(1.1)
end)
loop2=multi:newThreadedLoop(&quot;loop&quot;,function(self,dt)
    print(dt)
    thread.hold(function() return count&amp;gt;=100 end)
    print(&quot;Count is &quot;..count)
    os.exit()
end)
alarm=multi:newThreadedAlarm(&quot;alarm&quot;,1)
alarm:OnRing(function(self)
    print(&quot;Ring&quot;)
    self:Reset()
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
test=multi:newThreadedProcess(<span class="hljs-string">"main"</span>) <span class="hljs-comment">-- you can thread processors and all Actors see note for a list of actors you can thread!</span>
test2=multi:newThreadedProcess(<span class="hljs-string">"main2"</span>)
count=<span class="hljs-number">0</span>
test:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    count=count+<span class="hljs-number">1</span>
    thread.sleep(.<span class="hljs-number">01</span>)
<span class="hljs-keyword">end</span>)
test2:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello!"</span>)
    thread.sleep(<span class="hljs-number">1</span>) <span class="hljs-comment">-- sleep for some time</span>
<span class="hljs-keyword">end</span>)
<span class="hljs-comment">-- threads take a name object then the rest as normal</span>
step=multi:newThreadedTStep(<span class="hljs-string">"step"</span>,<span class="hljs-number">1</span>,<span class="hljs-number">10</span>)
step:OnStep(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,p)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"step"</span>,p)
    thread.skip(<span class="hljs-number">21</span>) <span class="hljs-comment">-- skip n cycles</span>
<span class="hljs-keyword">end</span>)
step:OnEnd(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Killing thread!"</span>)
    thread.kill() <span class="hljs-comment">-- kill the thread</span>
<span class="hljs-keyword">end</span>)
loop=multi:newThreadedLoop(<span class="hljs-string">"loop"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-built_in">print</span>(dt)
    thread.sleep(<span class="hljs-number">1.1</span>)
<span class="hljs-keyword">end</span>)
loop2=multi:newThreadedLoop(<span class="hljs-string">"loop"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-built_in">print</span>(dt)
    thread.hold(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span> <span class="hljs-keyword">return</span> count&gt;=<span class="hljs-number">100</span> <span class="hljs-keyword">end</span>)
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Count is "</span>..count)
    <span class="hljs-built_in">os</span>.exit()
<span class="hljs-keyword">end</span>)
alarm=multi:newThreadedAlarm(<span class="hljs-string">"alarm"</span>,<span class="hljs-number">1</span>)
alarm:OnRing(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Ring"</span>)
    self:Reset()
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Ring<br><br>0.992<br><br>0.992<br><br>Hello!<br><br>step    1<br><br>step    2<br><br>Hello!<br><br>Ring<br><br>2.092<br><br>step    3<br><br>Hello!<br><br>Ring<br><br>Count is 100<br></p><h2 id="threadable-actors"><a name="threadable-actors" href="#threadable-actors"></a>Threadable Actors</h2><ul>
<li>Alarms</li><li>Events</li><li>Loop/TLoop</li><li>Process</li><li>Step/TStep</li></ul><h2 id="functions"><a name="functions" href="#functions"></a>Functions</h2><p>If you ever wanted to pause a function then great now you can<br>The use of the Function object allows one to have a method that can run free in a sense</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
func=multi:newFunction(function(self,arg1,arg2,...)
    self:Pause()
    return arg1
end)
print(func(&quot;Hello&quot;))
print(func(&quot;Hello2&quot;)) -- returns PAUSED allows for the calling of functions that should only be called once. returns PAUSED instantly if paused
func:Resume()
print(func(&quot;Hello3&quot;))
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
func=multi:newFunction(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,arg1,arg2,...)</span></span>
    self:Pause()
    <span class="hljs-keyword">return</span> arg1
<span class="hljs-keyword">end</span>)
<span class="hljs-built_in">print</span>(func(<span class="hljs-string">"Hello"</span>))
<span class="hljs-built_in">print</span>(func(<span class="hljs-string">"Hello2"</span>)) <span class="hljs-comment">-- returns PAUSED allows for the calling of functions that should only be called once. returns PAUSED instantly if paused</span>
func:Resume()
<span class="hljs-built_in">print</span>(func(<span class="hljs-string">"Hello3"</span>))
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Hello<br><br>PAUSED<br><br>Hello3<br></p><h2 id="threadedupdater"><a name="threadedupdater" href="#threadedupdater"></a>ThreadedUpdater</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Works the same as a regular updater!
require(&quot;multi&quot;)
multi:newThreadedUpdater(&quot;Test&quot;,10000):OnUpdate(function(self)
    print(self.pos)
end)
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- Works the same as a regular updater!</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
multi:newThreadedUpdater(<span class="hljs-string">"Test"</span>,<span class="hljs-number">10000</span>):OnUpdate(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    <span class="hljs-built_in">print</span>(self.pos)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>1<br><br>2<br><br>…<br><br>.inf<br></p><h2 id="triggers"><a name="triggers" href="#triggers"></a>Triggers</h2><p>Triggers were what I used before connections became a thing, also Function objects are a lot like triggers and can be paused as well, while triggers cannot…<br><br>They are simple to use, but in most cases you are better off using a connection<br></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
-- They work like connections but can only have one event binded to them
trig=multi:newTrigger(function(self,a,b,c,...)
    print(a,b,c,...)
end)
trig:Fire(1,2,3)
trig:Fire(1,2,3,&quot;Hello&quot;,true)
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
<span class="hljs-comment">-- They work like connections but can only have one event binded to them</span>
trig=multi:newTrigger(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,a,b,c,...)</span></span>
    <span class="hljs-built_in">print</span>(a,b,c,...)
<span class="hljs-keyword">end</span>)
trig:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>)
trig:Fire(<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-string">"Hello"</span>,<span class="hljs-keyword">true</span>)
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>1    2    3<br><br>1    2    3    Hello    true<br></p><h2 id="tasks"><a name="tasks" href="#tasks"></a>Tasks</h2><p>Tasks allow you to run a block of code before the multi mainloop does it thing. Tasks still have a use but depending on how you program they aren’t needed.<br></p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
multi:newTask(function()
    print(&quot;Hi!&quot;)
end)
multi:newLoop(function(self,dt)
    print(&quot;Which came first the task or the loop?&quot;)
    self:Break()
end)
multi:newTask(function()
    print(&quot;Hello there!&quot;)
end)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
multi:newTask(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hi!"</span>)
<span class="hljs-keyword">end</span>)
multi:newLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,dt)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Which came first the task or the loop?"</span>)
    self:Break()
<span class="hljs-keyword">end</span>)
multi:newTask(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Hello there!"</span>)
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>Hi!<br><br>Hello there!<br><br>Which came first the task or the loop?<br></p><p>As seen in the example above the tasks were done before anything else in the mainloop! This is useful when making libraries around the multitasking features and you need things to happen in a certain order!<br></p><h2 id="jobs"><a name="jobs" href="#jobs"></a>Jobs</h2><p>Jobs were a strange feature that was created for throttling connections! When I was building an IRC bot around this library I couldn’t have messages posting too fast due to restrictions. Jobs allowed functions to be added to a queue that were executed after a certain amount of time has passed</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;) -- jobs use alarms I am pondering if alarms should be added to the core or if jobs should use timers instead...
-- jobs are built into the core of the library so no need to require them
print(multi:hasJobs())
multi:setJobSpeed(1) -- set job speed to 1 second
multi:newJob(function()
    print(&quot;A job!&quot;)
end,&quot;test&quot;)

multi:newJob(function()
    print(&quot;Another job!&quot;)
    multi:removeJob(&quot;test&quot;) -- removes all jobs with name &quot;test&quot;
end,&quot;test&quot;)

multi:newJob(function()
    print(&quot;Almost done!&quot;)
end,&quot;test&quot;)

multi:newJob(function()
    print(&quot;Final job!&quot;)
end,&quot;test&quot;)
print(multi:hasJobs())
print(&quot;There are &quot;..multi:getJobs()..&quot; jobs in the queue!&quot;)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>) <span class="hljs-comment">-- jobs use alarms I am pondering if alarms should be added to the core or if jobs should use timers instead...</span>
<span class="hljs-comment">-- jobs are built into the core of the library so no need to require them</span>
<span class="hljs-built_in">print</span>(multi:hasJobs())
multi:setJobSpeed(<span class="hljs-number">1</span>) <span class="hljs-comment">-- set job speed to 1 second</span>
multi:newJob(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"A job!"</span>)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"test"</span>)

multi:newJob(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Another job!"</span>)
    multi:removeJob(<span class="hljs-string">"test"</span>) <span class="hljs-comment">-- removes all jobs with name "test"</span>
<span class="hljs-keyword">end</span>,<span class="hljs-string">"test"</span>)

multi:newJob(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Almost done!"</span>)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"test"</span>)

multi:newJob(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">()</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Final job!"</span>)
<span class="hljs-keyword">end</span>,<span class="hljs-string">"test"</span>)
<span class="hljs-built_in">print</span>(multi:hasJobs())
<span class="hljs-built_in">print</span>(<span class="hljs-string">"There are "</span>..multi:getJobs()..<span class="hljs-string">" jobs in the queue!"</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>false    0<br><br>true    4<br><br>There are 4 jobs in the queue!<br><br>A job!<br><br><br>Another job!<br></p><h2 id="watchers"><a name="watchers" href="#watchers"></a>Watchers</h2><p>Watchers allow you to monitor a variable and trigger an event when the variable has changed!</p><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>require(&quot;multi&quot;)
a=0
watcher=multi:newWatcher(_G,&quot;a&quot;) -- watch a in the global environment
watcher:OnValueChanged(function(self,old,new)
    print(old,new)
end)
tloop=multi:newTLoop(function(self)
    a=a+1
end,1)
multi:mainloop()
</code></pre>"><span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
a=<span class="hljs-number">0</span>
watcher=multi:newWatcher(<span class="hljs-built_in">_G</span>,<span class="hljs-string">"a"</span>) <span class="hljs-comment">-- watch a in the global environment</span>
watcher:OnValueChanged(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,old,new)</span></span>
    <span class="hljs-built_in">print</span>(old,new)
<span class="hljs-keyword">end</span>)
tloop=multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    a=a+<span class="hljs-number">1</span>
<span class="hljs-keyword">end</span>,<span class="hljs-number">1</span>)
multi:mainloop()
</code></pre><h1 id="output"><a name="output" href="#output"></a>Output</h1><p>0    1<br><br>1    2<br><br>2    3<br><br>…<br><br>.inf-1    inf<br></p><h2 id="timeout-management"><a name="timeout-management" href="#timeout-management"></a>Timeout management</h2><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>-- Note: I used a tloop, so I could control the output of the program a bit.
require(&quot;multi&quot;)
a=0
inc=1 -- change to 0 to see it not met at all, 1 if you want to see the first condition not met but the second and 2 if you want to see it meet the condition on the first go.
loop=multi:newTLoop(function(self)
    print(&quot;Looping...&quot;)
    a=a+inc
    if a==14 then
        self:ResolveTimer(&quot;1&quot;,&quot;2&quot;,&quot;3&quot;) -- ... any number of arguments can be passed to the resolve handler
        -- this will also automatically pause the object that it is binded to
    end
end,.1)
loop:SetTime(1)
loop:OnTimerResolved(function(self,a,b,c) -- the handler will return the self and the passed arguments
    print(&quot;We did it!&quot;,a,b,c)
end)
loop:OnTimedOut(function(self)
    if not TheSecondTry then
        print(&quot;Loop timed out!&quot;,self.Type,&quot;Trying again...&quot;)
        self:ResetTime(2)
        self:Resume()
        TheSecondTry=true
    else
        print(&quot;We just couldn't do it!&quot;) -- print if we don't get anything working
    end
end)
multi:mainloop()
</code></pre>"><span class="hljs-comment">-- Note: I used a tloop, so I could control the output of the program a bit.</span>
<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi"</span>)
a=<span class="hljs-number">0</span>
inc=<span class="hljs-number">1</span> <span class="hljs-comment">-- change to 0 to see it not met at all, 1 if you want to see the first condition not met but the second and 2 if you want to see it meet the condition on the first go.</span>
loop=multi:newTLoop(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"Looping..."</span>)
    a=a+inc
    <span class="hljs-keyword">if</span> a==<span class="hljs-number">14</span> <span class="hljs-keyword">then</span>
        self:ResolveTimer(<span class="hljs-string">"1"</span>,<span class="hljs-string">"2"</span>,<span class="hljs-string">"3"</span>) <span class="hljs-comment">-- ... any number of arguments can be passed to the resolve handler</span>
        <span class="hljs-comment">-- this will also automatically pause the object that it is binded to</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>,.<span class="hljs-number">1</span>)
loop:SetTime(<span class="hljs-number">1</span>)
loop:OnTimerResolved(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self,a,b,c)</span></span> <span class="hljs-comment">-- the handler will return the self and the passed arguments</span>
    <span class="hljs-built_in">print</span>(<span class="hljs-string">"We did it!"</span>,a,b,c)
<span class="hljs-keyword">end</span>)
loop:OnTimedOut(<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(self)</span></span>
    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> TheSecondTry <span class="hljs-keyword">then</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"Loop timed out!"</span>,self.Type,<span class="hljs-string">"Trying again..."</span>)
        self:ResetTime(<span class="hljs-number">2</span>)
        self:Resume()
        TheSecondTry=<span class="hljs-keyword">true</span>
    <span class="hljs-keyword">else</span>
        <span class="hljs-built_in">print</span>(<span class="hljs-string">"We just couldn't do it!"</span>) <span class="hljs-comment">-- print if we don't get anything working</span>
    <span class="hljs-keyword">end</span>
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="output-(change-the-value-inc-as-indicated-in-the-comment-to-see-the-outcomes!)"><a name="output-(change-the-value-inc-as-indicated-in-the-comment-to-see-the-outcomes!)" href="#output-(change-the-value-inc-as-indicated-in-the-comment-to-see-the-outcomes!)"></a>Output (Change the value inc as indicated in the comment to see the outcomes!)</h1><p>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Loop timed out!    tloop    Trying again…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>Looping…<br><br>We did it!    1    2    3<br></p><h2 id="rambling"><a name="rambling" href="#rambling"></a>Rambling</h2><p>5/23/18:<br>When it comes to running code across different systems we run into a problem. It takes time to send objects from one matching to another. In the beginning only, local networks will be supported. I may add support to send commands to another network to do computing. Like having your own lua cloud. userdata will never be allowed to run on other machines. It is not possible unless the library you are using allows userdata to be turned into a string and back into an object. With this feature you want to send a command that will take time or needs tons of them done millions+, reason being networks are not that “fast” and only simple objects can be sent. If you mirror your environment then you can do some cool things.</p><p>The planned structure will be something like this:<br>multi-Single Threaded Multitasking<br>multi-Threads<br>multi-System Threads<br>multi-Network threads</p><p>where netThreads can contain systemThreads which can intern contain both Threads and single threaded multitasking</p><p>Nothing has been built yet, but the system will work something like this:</p><h1 id="host:"><a name="host:" href="#host:"></a>host:</h1><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>sGLOBAL, nGlobal,sThread=require(&quot;multi.integration.networkManager&quot;).init() -- This will determine if one is using lanes,love2d, or luvit
multi:Host(&quot;MainSystem&quot;) -- tell the network that this is the main system. Uses broadcast so that nodes know how to find the host!
nThread = multi:newNetworkThread(&quot;NetThread_1&quot;,function(...)
    -- basic usage
    nGLOBAL[&quot;RemoteVaraible&quot;] = true -- will sync data to all nodes and the host
    sGLOBAL[&quot;LocalMachineVaraible&quot;] = true -- will sync data to all system threads on the local machine
    return &quot;Hello Network!&quot; -- send &quot;Hello Network&quot; back to the host node
end)
multi:mainloop()
</code></pre>">sGLOBAL, nGlobal,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.networkManager"</span>).init() <span class="hljs-comment">-- This will determine if one is using lanes,love2d, or luvit</span>
multi:Host(<span class="hljs-string">"MainSystem"</span>) <span class="hljs-comment">-- tell the network that this is the main system. Uses broadcast so that nodes know how to find the host!</span>
nThread = multi:newNetworkThread(<span class="hljs-string">"NetThread_1"</span>,<span class="hljs-function"><span class="hljs-keyword">function</span><span class="hljs-params">(...)</span></span>
    <span class="hljs-comment">-- basic usage</span>
    nGLOBAL[<span class="hljs-string">"RemoteVaraible"</span>] = <span class="hljs-keyword">true</span> <span class="hljs-comment">-- will sync data to all nodes and the host</span>
    sGLOBAL[<span class="hljs-string">"LocalMachineVaraible"</span>] = <span class="hljs-keyword">true</span> <span class="hljs-comment">-- will sync data to all system threads on the local machine</span>
    <span class="hljs-keyword">return</span> <span class="hljs-string">"Hello Network!"</span> <span class="hljs-comment">-- send "Hello Network" back to the host node</span>
<span class="hljs-keyword">end</span>)
multi:mainloop()
</code></pre><h1 id="node"><a name="node" href="#node"></a>node</h1><pre class="lua hljs"><code class="lua" data-origin="<pre><code class=&quot;lua&quot;>GLOBAL,sThread=require(&quot;multi.integration.networkManager&quot;).init() -- This will determine if one is using lanes,love2d, or luvit
node = multi:newNode(&quot;NodeName&quot;,&quot;MainSystem&quot;) -- Search the network for the host, connect to it and be ready for requests!
-- On the main thread, a simple multi:newNetworkThread thread and non-system threads, you can access global data without an issue. When dealing with system threads is when you have a problem.
node:setLog{
    maxLines = 10000,
    cleanOnInterval = true,
    cleanInterval = &quot;day&quot;, -- every day Supports(day, week, month, year)
    noLog = false -- default is false, make true if you do not need a log
}
node:settings{
    maxJobs = 100, -- Job queues will respect this as well as the host when it is figuring out which node is under the least load. Default: 0 or infinite
    sendLoadInterval = 60 -- every 60 seconds update the host of the nodes load
    sendLoad = true -- default is true, tells the server how stressed the system is
}
multi:mainloop()
-- Note: the node will contain a log of all the commands that it gets. A file called &quot;NodeName.log&quot; will contain the info. You can set the limit by lines or file size. Also, you can set it to clear the log every interval of time if an error does not exist. All errors are both logged and sent to the host as well. You can have more than one host and more than one node(duh :P).
</code></pre>">GLOBAL,sThread=<span class="hljs-built_in">require</span>(<span class="hljs-string">"multi.integration.networkManager"</span>).init() <span class="hljs-comment">-- This will determine if one is using lanes,love2d, or luvit</span>
node = multi:newNode(<span class="hljs-string">"NodeName"</span>,<span class="hljs-string">"MainSystem"</span>) <span class="hljs-comment">-- Search the network for the host, connect to it and be ready for requests!</span>
<span class="hljs-comment">-- On the main thread, a simple multi:newNetworkThread thread and non-system threads, you can access global data without an issue. When dealing with system threads is when you have a problem.</span>
node:setLog{
    maxLines = <span class="hljs-number">10000</span>,
    cleanOnInterval = <span class="hljs-keyword">true</span>,
    cleanInterval = <span class="hljs-string">"day"</span>, <span class="hljs-comment">-- every day Supports(day, week, month, year)</span>
    noLog = <span class="hljs-keyword">false</span> <span class="hljs-comment">-- default is false, make true if you do not need a log</span>
}
node:settings{
    maxJobs = <span class="hljs-number">100</span>, <span class="hljs-comment">-- Job queues will respect this as well as the host when it is figuring out which node is under the least load. Default: 0 or infinite</span>
    sendLoadInterval = <span class="hljs-number">60</span> <span class="hljs-comment">-- every 60 seconds update the host of the nodes load</span>
    sendLoad = <span class="hljs-keyword">true</span> <span class="hljs-comment">-- default is true, tells the server how stressed the system is</span>
}
multi:mainloop()
<span class="hljs-comment">-- Note: the node will contain a log of all the commands that it gets. A file called "NodeName.log" will contain the info. You can set the limit by lines or file size. Also, you can set it to clear the log every interval of time if an error does not exist. All errors are both logged and sent to the host as well. You can have more than one host and more than one node(duh :P).</span>
</code></pre><p>The goal of the node is to set up a simple and easy way to run commands on a remote machine.</p><p>There are 2 main ways you can use this feature. 1. One node per machine with system threads being able to use the full processing power of the machine. 2. Multiple nodes on one machine where each node is acting like its own thread. And of course, a mix of the two is indeed possible.</p><p>Love2d Sleeping reduces the CPU time making my load detection think the system is under more load, thus preventing it from sleeping… I will investigate other means. As of right now it will not eat all your CPU if threads are active. For now, I suggest killing threads that aren’t needed anymore. On lanes threads at idle use 0% CPU and it is amazing. A state machine may solve what I need though. One state being idle state that sleeps and only goes into the active state if a job request or data is sent to it… after some time of not being under load it will switch back into the idle state… We’ll see what happens.</p><p>Love2d doesn’t like to send functions through channels. By default, it does not support this. I achieve this by dumping the function and loadstring it on the thread. This however is slow. For the System Threaded Job Queue, I had to change my original idea of sending functions as jobs. The current way you do it now is register a job functions once and then call that job across the thread through a queue. Each worker thread pops from the queue and returns the job. The Job ID is automatically updated and allows you to keep track of the order that the data comes in. A table with # indexes can be used to organize the data…</p><p>Regarding benchmarking. If you see my bench marks and are wondering they are 10x better it’s because I am using luajit for my tests. I highly recommend using luajit for my library, but lua 5.1 will work just as well, but not as fast.</p><p>So, while working on the jobQueue:doToAll() method I figured out why love2d’s threaded tables were acting up when more than 1 thread was sharing the table. It turns out 1 thread was eating all the pops from the queue and starved all the other queues… I’ll need to use the same trick I did with GLOBAL to fix the problem… However, at the rate I am going threading in love will become way slower. I might use the regular GLOBAL to manage data internally for threadedtables…</p><p>I have been using this (EventManager —&gt; MultiManager —&gt; now multi) for my own purposes and started making this when I first started learning lua. You can see how the code changed and evolved throughout the years. I tried to include all the versions that still existed on my HDD.</p><p>I added my old versions to this library… It started out as the EventManager and was kind of crappy, but it was the start to this library. It kept getting better and better until it became what it is today. There are some features that no longer exist in the latest version, but they were remove because they were useless… I added these files to the GitHub so for those interested can see into my mind in a sense and see how I developed the library before I used GitHub.</p><p>The first version of the EventManager was function based not object based and benched at about 2000 steps per second… Yeah that was bad… I used loadstring and it was a mess… Look and see how it grew throughout the years I think it may interest some of you guys!</p>

<footer style="position:fixed; font-size:.8em; text-align:right; bottom:0px; margin-left:-25px; height:20px; width:100%;">generated by <a href="http://pad.haroopress.com" target="_blank">haroopad</a></footer>
</body>
</html>
